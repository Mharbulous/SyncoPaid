name: Daily Story Approval

# Run at 4:20 AM PST (12:20 UTC) every day - after plan-stories
# Auto-approves vetted concept stories (no holds, no conflicts)
on:
  schedule:
    - cron: '20 12 * * *'
  workflow_dispatch:  # Manual trigger for testing

concurrency:
  group: daily-story-approval
  cancel-in-progress: false

permissions:
  contents: write
  issues: write
  pull-requests: write
  id-token: write

jobs:
  approve-stories:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 0  # Full history for git operations

      - name: Run Claude Code to approve stories
        id: claude
        uses: anthropics/claude-code-action@v1
        with:
          # GitHub token for repository operations (required for scheduled workflows)
          github_token: ${{ secrets.GITHUB_TOKEN }}

          # Use OAuth token for Max subscription
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}

          # Show full output for debugging
          show_full_output: true

          # Direct prompt mode for scheduled automation (CI-optimized)
          # Simple transition: concept (no hold) → approved
          prompt: |
            MODE: Daily Story Approval (CI - fully autonomous)

            This workflow auto-approves concept stories that have passed vetting
            (no holds, no disposition = clean concepts ready for planning).

            ## Step 1: Find Concepts Ready for Approval

            Query concept stories without holds:

            ```python
            python3 << 'QUERY_SCRIPT'
            import sqlite3
            import json

            conn = sqlite3.connect('.claude/data/story-tree.db')
            conn.row_factory = sqlite3.Row

            # Find all concept stories without holds (vetted and clean)
            concepts = conn.execute("""
                SELECT id, title, description
                FROM story_nodes
                WHERE stage = 'concept'
                  AND hold_reason IS NULL
                  AND disposition IS NULL
                ORDER BY updated_at ASC
            """).fetchall()

            print(f"Found {len(concepts)} concept(s) ready for approval:")
            for c in concepts:
                print(f"  - {c['id']}: {c['title'][:60]}...")

            print(json.dumps({
                'count': len(concepts),
                'stories': [{'id': c['id'], 'title': c['title']} for c in concepts]
            }))
            conn.close()
            QUERY_SCRIPT
            ```

            If count is 0, output "✓ No concepts ready for approval" and exit successfully.

            ## Step 2: Auto-Approve Concepts

            Approve each concept by updating stage to 'approved':

            ```python
            python3 << 'APPROVE_SCRIPT'
            import sqlite3
            import json
            from datetime import datetime

            conn = sqlite3.connect('.claude/data/story-tree.db')
            conn.row_factory = sqlite3.Row

            # Find all concept stories without holds
            concepts = conn.execute("""
                SELECT id, title
                FROM story_nodes
                WHERE stage = 'concept'
                  AND hold_reason IS NULL
                  AND disposition IS NULL
                ORDER BY updated_at ASC
            """).fetchall()

            approved = []
            for concept in concepts:
                # Update stage to approved
                conn.execute("""
                    UPDATE story_nodes
                    SET stage = 'approved',
                        notes = COALESCE(notes || char(10), '') ||
                                'AUTO-APPROVED: Concept passed vetting, ready for planning. ' ||
                                datetime('now'),
                        updated_at = datetime('now')
                    WHERE id = ?
                """, (concept['id'],))
                approved.append({'id': concept['id'], 'title': concept['title']})

            conn.commit()

            print("=== Story Approval Complete ===")
            print(f"Approved: {len(approved)} concept(s)")
            print("")
            if approved:
                print("Approved stories:")
                for a in approved:
                    print(f"  - {a['id']}: {a['title'][:60]}...")

            print(json.dumps({'approved': approved}, indent=2))
            conn.close()
            APPROVE_SCRIPT
            ```

            ## Step 3: Git Operations

            After approving stories:
            ```bash
            git checkout main && git pull origin main
            git add -A
            git diff --cached --quiet || git commit -m "ci: auto-approve concepts $(date -u +'%Y-%m-%d')"
            git push origin main
            ```

            **CRITICAL**: Push changes before exiting.

            ## Constraints
            - Process all eligible concepts in one run
            - 15-minute timeout (simple operation)

          # Tool permissions for file operations, database access, and git
          claude_args: |
            --allowedTools "Task,Read,Write,Edit,Glob,Grep,Bash(git:*),Bash(python:*),Bash(python3:*),Bash(sqlite3:*),Skill,SlashCommand,TodoWrite"
            --model claude-sonnet-4-5-20250929

      - name: Report Token Usage
        if: always()
        run: |
          echo "## Token Usage Report" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          EXEC_FILE="${{ steps.claude.outputs.execution_file }}"
          if [ -f "$EXEC_FILE" ]; then
            # Determine file format (JSONL vs JSON array) and extract data
            if jq -e 'type == "array"' "$EXEC_FILE" > /dev/null 2>&1; then
              # JSON array format
              INPUT_TOKENS=$(jq '[.[] | select(.message?.usage?) | .message.usage.input_tokens // 0] | add // 0' "$EXEC_FILE")
              OUTPUT_TOKENS=$(jq '[.[] | select(.message?.usage?) | .message.usage.output_tokens // 0] | add // 0' "$EXEC_FILE")
              TOTAL_COST=$(jq '[.[] | select(.type == "result")] | last | .total_cost_usd // .cost_usd // "N/A"' "$EXEC_FILE" | tr -d '"')
            else
              # JSONL format
              INPUT_TOKENS=$(grep -o '"input_tokens":[0-9]*' "$EXEC_FILE" | cut -d: -f2 | awk '{s+=$1} END {print s+0}')
              OUTPUT_TOKENS=$(grep -o '"output_tokens":[0-9]*' "$EXEC_FILE" | cut -d: -f2 | awk '{s+=$1} END {print s+0}')
              RESULT=$(grep '"type":"result"' "$EXEC_FILE" | tail -1)
              TOTAL_COST=$(echo "$RESULT" | jq -r '.total_cost_usd // .cost_usd // "N/A"' 2>/dev/null || echo "N/A")
            fi

            # Validate we got numeric values
            if ! [[ "$INPUT_TOKENS" =~ ^[0-9]+$ ]]; then INPUT_TOKENS=0; fi
            if ! [[ "$OUTPUT_TOKENS" =~ ^[0-9]+$ ]]; then OUTPUT_TOKENS=0; fi

            echo "| Metric | Value |" >> $GITHUB_STEP_SUMMARY
            echo "|--------|-------|" >> $GITHUB_STEP_SUMMARY
            echo "| Input Tokens | $INPUT_TOKENS |" >> $GITHUB_STEP_SUMMARY
            echo "| Output Tokens | $OUTPUT_TOKENS |" >> $GITHUB_STEP_SUMMARY
            echo "| Total Cost | \$$TOTAL_COST |" >> $GITHUB_STEP_SUMMARY
          else
            echo "⚠️ Execution file not found" >> $GITHUB_STEP_SUMMARY
          fi
