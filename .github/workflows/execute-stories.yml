name: 4. Execute Story

on:
  schedule:
    - cron: '*/20 * * * *'
  workflow_dispatch:

concurrency:
  group: daily-story-execution
  cancel-in-progress: false

permissions:
  contents: write
  issues: write
  pull-requests: write
  id-token: write

jobs:
  execute-stories:
    runs-on: ubuntu-latest
    timeout-minutes: 60

    steps:
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # PHASE 1: SETUP
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      - name: "1.1 Checkout repository"
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # PHASE 2: PLAN SELECTION
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      - name: "2.1 Find available plans"
        id: find-plans
        run: |
          echo "## Plan Discovery" >> $GITHUB_STEP_SUMMARY

          PLANS_DIR=".claude/data/plans"
          if [ ! -d "$PLANS_DIR" ]; then
            echo "plans_found=0" >> $GITHUB_OUTPUT
            echo "âŒ Plans directory not found: $PLANS_DIR" >> $GITHUB_STEP_SUMMARY
            exit 0
          fi

          # Count plan files (excluding subdirectories)
          PLAN_COUNT=$(find "$PLANS_DIR" -maxdepth 1 -name "*.md" -type f | wc -l)
          echo "plans_found=$PLAN_COUNT" >> $GITHUB_OUTPUT
          echo "Found **$PLAN_COUNT** plan files in $PLANS_DIR" >> $GITHUB_STEP_SUMMARY

          # List them for visibility
          if [ "$PLAN_COUNT" -gt 0 ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| Plan File | Sequence |" >> $GITHUB_STEP_SUMMARY
            echo "|-----------|----------|" >> $GITHUB_STEP_SUMMARY
            for f in $(ls -1 "$PLANS_DIR"/*.md 2>/dev/null | head -10); do
              FNAME=$(basename "$f")
              SEQ=$(echo "$FNAME" | grep -oP '^\d{3}[A-Z]?' || echo "?")
              echo "| $FNAME | $SEQ |" >> $GITHUB_STEP_SUMMARY
            done
          fi

      - name: "2.2 Select earliest plan"
        id: select-plan
        if: steps.find-plans.outputs.plans_found != '0'
        run: |
          python3 << 'PYEOF'
          import os, re, json

          plans_dir = '.claude/data/plans'
          pattern = re.compile(r'^(\d{3})([A-Z])?_(.+)\.md$')

          plans = []
          for f in os.listdir(plans_dir):
              path = os.path.join(plans_dir, f)
              if os.path.isfile(path) and f.endswith('.md'):
                  m = pattern.match(f)
                  if m:
                      plans.append({
                          'filename': f,
                          'path': path,
                          'sequence': int(m.group(1)),
                          'letter': m.group(2) or '',
                      })

          plans.sort(key=lambda x: (x['sequence'], x['letter']))

          if plans:
              selected = plans[0]
              with open(os.environ['GITHUB_OUTPUT'], 'a') as out:
                  out.write(f"selected=true\n")
                  out.write(f"filename={selected['filename']}\n")
                  out.write(f"path={selected['path']}\n")
                  out.write(f"sequence={selected['sequence']}{selected['letter']}\n")
              print(f"Selected: {selected['filename']}")
          else:
              with open(os.environ['GITHUB_OUTPUT'], 'a') as out:
                  out.write("selected=false\n")
              print("No valid plan files found")
          PYEOF

      - name: "2.3 Extract Story ID from plan"
        id: extract-story
        if: steps.select-plan.outputs.selected == 'true'
        run: |
          PLAN_PATH="${{ steps.select-plan.outputs.path }}"

          # Extract Story ID using multiple patterns
          STORY_ID=$(grep -oP 'Story ID[:\s]*\K\d+(\.\d+)*' "$PLAN_PATH" | head -1)

          if [ -z "$STORY_ID" ]; then
            STORY_ID=$(grep -oP '\*\*Story ID:\*\*\s*\K\d+(\.\d+)*' "$PLAN_PATH" | head -1)
          fi

          echo "story_id=${STORY_ID:-none}" >> $GITHUB_OUTPUT
          echo "Story ID: ${STORY_ID:-'(not found)'}"

      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # PHASE 3: VALIDATION
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      - name: "3.1 Check if story already executed"
        id: check-executed
        if: steps.select-plan.outputs.selected == 'true' && steps.extract-story.outputs.story_id != 'none'
        run: |
          STORY_ID="${{ steps.extract-story.outputs.story_id }}"
          DB_PATH=".claude/data/story-tree.db"

          if [ ! -f "$DB_PATH" ]; then
            echo "already_executed=false" >> $GITHUB_OUTPUT
            echo "Database not found, assuming not executed"
            exit 0
          fi

          STAGE=$(python3 -c "
          import sqlite3
          conn = sqlite3.connect('$DB_PATH')
          r = conn.execute('SELECT stage FROM story_nodes WHERE id = ?', ('$STORY_ID',)).fetchone()
          print(r[0] if r else 'unknown')
          conn.close()
          ")

          echo "Current stage: $STAGE"

          case "$STAGE" in
            reviewing|verifying|implemented|ready|polish|released)
              echo "already_executed=true" >> $GITHUB_OUTPUT
              echo "current_stage=$STAGE" >> $GITHUB_OUTPUT
              echo "âš ï¸ Story $STORY_ID already at stage: $STAGE"
              ;;
            *)
              echo "already_executed=false" >> $GITHUB_OUTPUT
              echo "current_stage=$STAGE" >> $GITHUB_OUTPUT
              echo "âœ“ Story $STORY_ID ready for execution (stage: $STAGE)"
              ;;
          esac

      - name: "3.2 Check story dependencies"
        id: check-deps
        if: steps.select-plan.outputs.selected == 'true' && steps.check-executed.outputs.already_executed != 'true'
        run: |
          STORY_ID="${{ steps.extract-story.outputs.story_id }}"
          PLAN_PATH="${{ steps.select-plan.outputs.path }}"
          DB_PATH=".claude/data/story-tree.db"

          if [ "$STORY_ID" = "none" ] || [ ! -f "$DB_PATH" ]; then
            echo "deps_met=true" >> $GITHUB_OUTPUT
            echo "No Story ID or database, skipping dependency check"
            exit 0
          fi

          python3 << PYEOF
          import sqlite3, re, os

          story_id = "$STORY_ID"
          db_path = "$DB_PATH"
          plan_path = "$PLAN_PATH"

          conn = sqlite3.connect(db_path)

          # Get story description and notes
          result = conn.execute('SELECT description, notes FROM story_nodes WHERE id = ?', (story_id,)).fetchone()
          if not result:
              with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                  f.write("deps_met=true\n")
              print("Story not in database, proceeding")
              exit(0)

          text = (result[0] or '') + ' ' + (result[1] or '')

          # Also check plan file for dependency mentions
          with open(plan_path, 'r') as f:
              text += ' ' + f.read()

          # Find dependency patterns
          dep_pattern = r'(?:depends on|requires|after|blocked by)\s+(\d+(?:\.\d+)*)'
          deps = set(re.findall(dep_pattern, text, re.IGNORECASE))
          deps.discard(story_id)

          if not deps:
              with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                  f.write("deps_met=true\n")
              print("No dependencies found")
              exit(0)

          # Check each dependency
          IMPLEMENTED = ('implemented', 'ready', 'polish', 'released')
          unmet = []
          for dep_id in deps:
              r = conn.execute('SELECT stage FROM story_nodes WHERE id = ? AND disposition IS NULL', (dep_id,)).fetchone()
              if r and r[0] not in IMPLEMENTED:
                  unmet.append(f"{dep_id} ({r[0]})")

          conn.close()

          if unmet:
              with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                  f.write("deps_met=false\n")
                  f.write(f"unmet_deps={', '.join(unmet)}\n")
              print(f"âŒ Unmet dependencies: {', '.join(unmet)}")
          else:
              with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                  f.write("deps_met=true\n")
              print("âœ“ All dependencies met")
          PYEOF

      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # PHASE 4: HANDLE SKIP CONDITIONS
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      - name: "4.1 Archive already-executed plan"
        if: steps.check-executed.outputs.already_executed == 'true'
        run: |
          PLAN_PATH="${{ steps.select-plan.outputs.path }}"
          FILENAME="${{ steps.select-plan.outputs.filename }}"
          ARCHIVE_DIR=".claude/data/executed"

          mkdir -p "$ARCHIVE_DIR"
          mv "$PLAN_PATH" "$ARCHIVE_DIR/"
          echo "Archived already-executed plan: $FILENAME â†’ $ARCHIVE_DIR/"

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add -A
          git commit -m "ci: archive already-executed plan $FILENAME"
          git push origin main

      - name: "4.2 Move blocked plan to blocked folder"
        if: steps.check-deps.outputs.deps_met == 'false'
        run: |
          PLAN_PATH="${{ steps.select-plan.outputs.path }}"
          FILENAME="${{ steps.select-plan.outputs.filename }}"
          BLOCKED_DIR=".claude/data/plans/blocked"
          UNMET="${{ steps.check-deps.outputs.unmet_deps }}"

          mkdir -p "$BLOCKED_DIR"
          mv "$PLAN_PATH" "$BLOCKED_DIR/"
          echo "Moved blocked plan: $FILENAME â†’ $BLOCKED_DIR/"
          echo "Unmet dependencies: $UNMET"

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add -A
          git commit -m "ci: move blocked plan $FILENAME (deps: $UNMET)"
          git push origin main

      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # PHASE 5: EXECUTE PLAN (Multi-Call Claude AI)
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      # --- 5.0: Initialize shared state ---
      - name: "5.0 Initialize temp-CI-notes.json"
        id: init-state
        if: |
          steps.select-plan.outputs.selected == 'true' &&
          steps.check-executed.outputs.already_executed != 'true' &&
          steps.check-deps.outputs.deps_met != 'false'
        run: |
          STATE_FILE=".claude/skills/story-execution/temp-CI-notes.json"
          cat > "$STATE_FILE" << EOF
          {
            "version": 1,
            "plan_file": "${{ steps.select-plan.outputs.filename }}",
            "story_id": "${{ steps.extract-story.outputs.story_id }}",
            "review": {"outcome": null, "blocking_issues": [], "deferrable_issues": [], "notes": null},
            "tasks": [],
            "batches": [],
            "current_batch": 0,
            "total_tasks": 0,
            "tasks_remaining": 0,
            "final_status": "not_started"
          }
          EOF
          echo "initialized=true" >> $GITHUB_OUTPUT
          echo "Initialized state file: $STATE_FILE"

      # --- 5.1: Critical Review ---
      - name: "5.1 Review plan critically"
        id: review
        if: steps.init-state.outputs.initialized == 'true'
        uses: anthropics/claude-code-action@v1
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          show_full_output: true
          prompt: |
            Use story-execution skill in CI mode.
            Phase: REVIEW
            Plan: ${{ steps.select-plan.outputs.path }}
            Story ID: ${{ steps.extract-story.outputs.story_id }}

            Read/write state: .claude/skills/story-execution/temp-CI-notes.json

            INSTRUCTIONS:
            1. Read the plan file completely
            2. Review critically - identify any blocking or deferrable issues
            3. Extract task list from the plan
            4. Update temp-CI-notes.json with:
               - review.outcome: "proceed", "pause", or "proceed_with_review"
               - review.blocking_issues: [] if none
               - review.deferrable_issues: [] if none
               - tasks: [{id, name, status: "pending"}] extracted from plan
               - total_tasks: count of tasks
               - tasks_remaining: same as total_tasks initially
            5. If blocking issues exist, set outcome to "pause"
            6. If deferrable issues exist, set outcome to "proceed_with_review"
            7. If no issues, set outcome to "proceed"

            Load references:
            - references/critical-review.md

          claude_args: |
            --allowedTools "Read,Write,Edit,Glob,Grep,Bash(python:*),Bash(python3:*),TodoWrite"
            --model claude-sonnet-4-5-20250929
            --max-turns 20

      - name: "5.1a Read review output"
        id: review-output
        if: always() && steps.init-state.outputs.initialized == 'true'
        run: |
          STATE_FILE=".claude/skills/story-execution/temp-CI-notes.json"
          if [ -f "$STATE_FILE" ]; then
            OUTCOME=$(python3 -c "import json; d=json.load(open('$STATE_FILE')); print(d.get('review',{}).get('outcome','unknown'))")
            # Check if review was actually completed (has a valid outcome)
            if [ "$OUTCOME" = "proceed" ] || [ "$OUTCOME" = "proceed_with_review" ] || [ "$OUTCOME" = "pause" ]; then
              TASKS=$(python3 -c "import json; d=json.load(open('$STATE_FILE')); print(d.get('total_tasks',0))")
              echo "outcome=$OUTCOME" >> $GITHUB_OUTPUT
              echo "total_tasks=$TASKS" >> $GITHUB_OUTPUT
              echo "review_completed=true" >> $GITHUB_OUTPUT
              echo "Review outcome: $OUTCOME, Total tasks: $TASKS"
            else
              echo "outcome=failed" >> $GITHUB_OUTPUT
              echo "total_tasks=0" >> $GITHUB_OUTPUT
              echo "review_completed=false" >> $GITHUB_OUTPUT
              echo "Review not completed - outcome in state: $OUTCOME"
            fi
          else
            echo "outcome=failed" >> $GITHUB_OUTPUT
            echo "total_tasks=0" >> $GITHUB_OUTPUT
            echo "review_completed=false" >> $GITHUB_OUTPUT
            echo "State file not found"
          fi

      # --- 5.2: Execute Batch 1 (tasks 1-3) ---
      - name: "5.2 Execute batch 1"
        id: batch1
        if: |
          steps.review-output.outputs.review_completed == 'true' &&
          (steps.review-output.outputs.outcome == 'proceed' || steps.review-output.outputs.outcome == 'proceed_with_review') &&
          steps.review-output.outputs.total_tasks != '0'
        uses: anthropics/claude-code-action@v1
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          show_full_output: true
          prompt: |
            Use story-execution skill in CI mode.
            Phase: EXECUTE_BATCH
            Batch: 1
            Task Range: 1-3
            Plan: ${{ steps.select-plan.outputs.path }}
            Story ID: ${{ steps.extract-story.outputs.story_id }}

            Read/write state: .claude/skills/story-execution/temp-CI-notes.json

            INSTRUCTIONS:
            1. Read temp-CI-notes.json for task list
            2. Execute tasks 1-3 (or fewer if less than 3 tasks total)
            3. For each task: RED (failing test) -> GREEN (implementation) -> COMMIT
            4. Commit format: "feat: [task] Story: ${{ steps.extract-story.outputs.story_id }}"
            5. Update task status to "completed" or "failed" in temp-CI-notes.json
            6. Update batches[0] with status and commit hashes
            7. Update current_batch to 1 and tasks_remaining

            Load references:
            - references/tdd-execution.md
            - references/database-updates.md

          claude_args: |
            --allowedTools "Read,Write,Edit,Glob,Grep,Bash(git:*),Bash(python:*),Bash(python3:*),Bash(pytest:*),Bash(pip:*),BashOutput,TodoWrite"
            --model claude-sonnet-4-5-20250929
            --max-turns 30

      - name: "5.2a Read batch 1 output"
        id: batch1-output
        if: always() && steps.review-output.outputs.review_completed == 'true'
        run: |
          STATE_FILE=".claude/skills/story-execution/temp-CI-notes.json"
          if [ -f "$STATE_FILE" ]; then
            # Check if batch 1 exists in state
            BATCH_EXISTS=$(python3 -c "import json; d=json.load(open('$STATE_FILE')); b=d.get('batches',[]); print('true' if len(b) >= 1 else 'false')")
            if [ "$BATCH_EXISTS" = "true" ]; then
              STATUS=$(python3 -c "import json; d=json.load(open('$STATE_FILE')); b=d.get('batches',[]); print(b[0].get('status','unknown'))")
              REMAINING=$(python3 -c "import json; d=json.load(open('$STATE_FILE')); print(d.get('tasks_remaining',0))")
              echo "status=$STATUS" >> $GITHUB_OUTPUT
              echo "tasks_remaining=$REMAINING" >> $GITHUB_OUTPUT
              echo "batch_ran=true" >> $GITHUB_OUTPUT
              echo "Batch 1 status: $STATUS, Remaining: $REMAINING"
            else
              echo "status=skipped" >> $GITHUB_OUTPUT
              echo "tasks_remaining=0" >> $GITHUB_OUTPUT
              echo "batch_ran=false" >> $GITHUB_OUTPUT
              echo "Batch 1 did not run"
            fi
          else
            echo "status=failed" >> $GITHUB_OUTPUT
            echo "tasks_remaining=0" >> $GITHUB_OUTPUT
            echo "batch_ran=false" >> $GITHUB_OUTPUT
          fi

      # --- 5.3: Execute Batch 2 (tasks 4-6) ---
      - name: "5.3 Execute batch 2"
        id: batch2
        if: |
          steps.batch1-output.outputs.batch_ran == 'true' &&
          steps.batch1-output.outputs.status == 'completed' &&
          steps.batch1-output.outputs.tasks_remaining != '0'
        uses: anthropics/claude-code-action@v1
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          show_full_output: true
          prompt: |
            Use story-execution skill in CI mode.
            Phase: EXECUTE_BATCH
            Batch: 2
            Task Range: 4-6
            Plan: ${{ steps.select-plan.outputs.path }}
            Story ID: ${{ steps.extract-story.outputs.story_id }}

            Read/write state: .claude/skills/story-execution/temp-CI-notes.json

            INSTRUCTIONS:
            1. Read temp-CI-notes.json for task list and current progress
            2. Execute tasks 4-6 (or remaining tasks if fewer)
            3. For each task: RED -> GREEN -> COMMIT
            4. Update task status and batches[1] in temp-CI-notes.json
            5. Update current_batch to 2 and tasks_remaining

            Load references:
            - references/tdd-execution.md

          claude_args: |
            --allowedTools "Read,Write,Edit,Glob,Grep,Bash(git:*),Bash(python:*),Bash(python3:*),Bash(pytest:*),Bash(pip:*),BashOutput,TodoWrite"
            --model claude-sonnet-4-5-20250929
            --max-turns 30

      - name: "5.3a Read batch 2 output"
        id: batch2-output
        if: always() && steps.batch1-output.outputs.batch_ran == 'true'
        run: |
          STATE_FILE=".claude/skills/story-execution/temp-CI-notes.json"
          if [ -f "$STATE_FILE" ]; then
            BATCH_EXISTS=$(python3 -c "import json; d=json.load(open('$STATE_FILE')); b=d.get('batches',[]); print('true' if len(b) >= 2 else 'false')")
            if [ "$BATCH_EXISTS" = "true" ]; then
              STATUS=$(python3 -c "import json; d=json.load(open('$STATE_FILE')); b=d.get('batches',[]); print(b[1].get('status','unknown'))")
              REMAINING=$(python3 -c "import json; d=json.load(open('$STATE_FILE')); print(d.get('tasks_remaining',0))")
              echo "status=$STATUS" >> $GITHUB_OUTPUT
              echo "tasks_remaining=$REMAINING" >> $GITHUB_OUTPUT
              echo "batch_ran=true" >> $GITHUB_OUTPUT
              echo "Batch 2 status: $STATUS, Remaining: $REMAINING"
            else
              echo "status=skipped" >> $GITHUB_OUTPUT
              echo "tasks_remaining=0" >> $GITHUB_OUTPUT
              echo "batch_ran=false" >> $GITHUB_OUTPUT
              echo "Batch 2 did not run"
            fi
          else
            echo "status=failed" >> $GITHUB_OUTPUT
            echo "tasks_remaining=0" >> $GITHUB_OUTPUT
            echo "batch_ran=false" >> $GITHUB_OUTPUT
          fi

      # --- 5.4: Execute Batch 3 (tasks 7-9) ---
      - name: "5.4 Execute batch 3"
        id: batch3
        if: |
          steps.batch2-output.outputs.batch_ran == 'true' &&
          steps.batch2-output.outputs.status == 'completed' &&
          steps.batch2-output.outputs.tasks_remaining != '0'
        uses: anthropics/claude-code-action@v1
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          show_full_output: true
          prompt: |
            Use story-execution skill in CI mode.
            Phase: EXECUTE_BATCH
            Batch: 3
            Task Range: 7-9
            Plan: ${{ steps.select-plan.outputs.path }}
            Story ID: ${{ steps.extract-story.outputs.story_id }}

            Read/write state: .claude/skills/story-execution/temp-CI-notes.json

            Load references:
            - references/tdd-execution.md

          claude_args: |
            --allowedTools "Read,Write,Edit,Glob,Grep,Bash(git:*),Bash(python:*),Bash(python3:*),Bash(pytest:*),Bash(pip:*),BashOutput,TodoWrite"
            --model claude-sonnet-4-5-20250929
            --max-turns 30

      - name: "5.4a Read batch 3 output"
        id: batch3-output
        if: always() && steps.batch2-output.outputs.batch_ran == 'true'
        run: |
          STATE_FILE=".claude/skills/story-execution/temp-CI-notes.json"
          if [ -f "$STATE_FILE" ]; then
            BATCH_EXISTS=$(python3 -c "import json; d=json.load(open('$STATE_FILE')); b=d.get('batches',[]); print('true' if len(b) >= 3 else 'false')")
            if [ "$BATCH_EXISTS" = "true" ]; then
              STATUS=$(python3 -c "import json; d=json.load(open('$STATE_FILE')); b=d.get('batches',[]); print(b[2].get('status','unknown'))")
              REMAINING=$(python3 -c "import json; d=json.load(open('$STATE_FILE')); print(d.get('tasks_remaining',0))")
              echo "status=$STATUS" >> $GITHUB_OUTPUT
              echo "tasks_remaining=$REMAINING" >> $GITHUB_OUTPUT
              echo "batch_ran=true" >> $GITHUB_OUTPUT
            else
              echo "status=skipped" >> $GITHUB_OUTPUT
              echo "tasks_remaining=0" >> $GITHUB_OUTPUT
              echo "batch_ran=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "status=failed" >> $GITHUB_OUTPUT
            echo "tasks_remaining=0" >> $GITHUB_OUTPUT
            echo "batch_ran=false" >> $GITHUB_OUTPUT
          fi

      # --- 5.5: Execute Batch 4 (tasks 10-12) ---
      - name: "5.5 Execute batch 4"
        id: batch4
        if: |
          steps.batch3-output.outputs.batch_ran == 'true' &&
          steps.batch3-output.outputs.status == 'completed' &&
          steps.batch3-output.outputs.tasks_remaining != '0'
        uses: anthropics/claude-code-action@v1
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          show_full_output: true
          prompt: |
            Use story-execution skill in CI mode.
            Phase: EXECUTE_BATCH
            Batch: 4
            Task Range: 10-12
            Plan: ${{ steps.select-plan.outputs.path }}
            Story ID: ${{ steps.extract-story.outputs.story_id }}

            Read/write state: .claude/skills/story-execution/temp-CI-notes.json

            Load references:
            - references/tdd-execution.md

          claude_args: |
            --allowedTools "Read,Write,Edit,Glob,Grep,Bash(git:*),Bash(python:*),Bash(python3:*),Bash(pytest:*),Bash(pip:*),BashOutput,TodoWrite"
            --model claude-sonnet-4-5-20250929
            --max-turns 30

      - name: "5.5a Read batch 4 output"
        id: batch4-output
        if: always() && steps.batch3-output.outputs.batch_ran == 'true'
        run: |
          STATE_FILE=".claude/skills/story-execution/temp-CI-notes.json"
          if [ -f "$STATE_FILE" ]; then
            BATCH_EXISTS=$(python3 -c "import json; d=json.load(open('$STATE_FILE')); b=d.get('batches',[]); print('true' if len(b) >= 4 else 'false')")
            if [ "$BATCH_EXISTS" = "true" ]; then
              STATUS=$(python3 -c "import json; d=json.load(open('$STATE_FILE')); b=d.get('batches',[]); print(b[3].get('status','unknown'))")
              REMAINING=$(python3 -c "import json; d=json.load(open('$STATE_FILE')); print(d.get('tasks_remaining',0))")
              echo "status=$STATUS" >> $GITHUB_OUTPUT
              echo "tasks_remaining=$REMAINING" >> $GITHUB_OUTPUT
              echo "batch_ran=true" >> $GITHUB_OUTPUT
            else
              echo "status=skipped" >> $GITHUB_OUTPUT
              echo "tasks_remaining=0" >> $GITHUB_OUTPUT
              echo "batch_ran=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "status=failed" >> $GITHUB_OUTPUT
            echo "tasks_remaining=0" >> $GITHUB_OUTPUT
            echo "batch_ran=false" >> $GITHUB_OUTPUT
          fi

      # --- 5.6: Determine final execution status ---
      - name: "5.6 Determine execution outcome"
        id: claude
        if: always() && steps.init-state.outputs.initialized == 'true'
        run: |
          STATE_FILE=".claude/skills/story-execution/temp-CI-notes.json"

          # Determine overall outcome based on state file, not step outcomes
          REVIEW_COMPLETED="${{ steps.review-output.outputs.review_completed }}"
          if [ "$REVIEW_COMPLETED" != "true" ]; then
            echo "outcome=failure" >> $GITHUB_OUTPUT
            echo "reason=review_failed" >> $GITHUB_OUTPUT
            exit 0
          fi

          REVIEW_OUTCOME="${{ steps.review-output.outputs.outcome }}"
          if [ "$REVIEW_OUTCOME" = "pause" ]; then
            echo "outcome=paused" >> $GITHUB_OUTPUT
            echo "reason=blocking_issues" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Check final state
          if [ -f "$STATE_FILE" ]; then
            REMAINING=$(python3 -c "import json; d=json.load(open('$STATE_FILE')); print(d.get('tasks_remaining',0))")
            FINAL=$(python3 -c "import json; d=json.load(open('$STATE_FILE')); print(d.get('final_status','unknown'))")

            if [ "$REMAINING" = "0" ] || [ "$FINAL" = "completed" ]; then
              if [ "$REVIEW_OUTCOME" = "proceed_with_review" ]; then
                echo "outcome=success" >> $GITHUB_OUTPUT
                echo "needs_review=true" >> $GITHUB_OUTPUT
              else
                echo "outcome=success" >> $GITHUB_OUTPUT
                echo "needs_review=false" >> $GITHUB_OUTPUT
              fi
            else
              # Check if any batch failed
              FAILED=$(python3 -c "import json; d=json.load(open('$STATE_FILE')); print('yes' if any(b.get('status')=='failed' for b in d.get('batches',[])) else 'no')")
              if [ "$FAILED" = "yes" ]; then
                echo "outcome=failure" >> $GITHUB_OUTPUT
                echo "reason=batch_failed" >> $GITHUB_OUTPUT
              else
                echo "outcome=success" >> $GITHUB_OUTPUT
                echo "needs_review=false" >> $GITHUB_OUTPUT
              fi
            fi
          else
            echo "outcome=failure" >> $GITHUB_OUTPUT
            echo "reason=no_state_file" >> $GITHUB_OUTPUT
          fi

      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # PHASE 6: FINALIZE
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      - name: "6.1 Archive executed plan"
        if: steps.claude.outputs.outcome == 'success'
        run: |
          PLAN_PATH="${{ steps.select-plan.outputs.path }}"
          FILENAME="${{ steps.select-plan.outputs.filename }}"
          ARCHIVE_DIR=".claude/data/executed"

          if [ -f "$PLAN_PATH" ]; then
            mkdir -p "$ARCHIVE_DIR"
            mv "$PLAN_PATH" "$ARCHIVE_DIR/"
            echo "âœ“ Archived: $FILENAME â†’ $ARCHIVE_DIR/"
          else
            echo "Plan already archived or moved"
          fi

      - name: "6.2 Update story status in database"
        if: steps.claude.outputs.outcome == 'success' && steps.extract-story.outputs.story_id != 'none'
        run: |
          STORY_ID="${{ steps.extract-story.outputs.story_id }}"
          DB_PATH=".claude/data/story-tree.db"
          NEEDS_REVIEW="${{ steps.claude.outputs.needs_review }}"

          if [ ! -f "$DB_PATH" ]; then
            echo "Database not found, skipping status update"
            exit 0
          fi

          # Set stage based on whether review is needed
          if [ "$NEEDS_REVIEW" = "true" ]; then
            STAGE="reviewing"
            NOTE="CI execution complete (review required)"
          else
            STAGE="verifying"
            NOTE="CI execution complete"
          fi

          python3 << PYEOF
          import sqlite3
          conn = sqlite3.connect("$DB_PATH")
          conn.execute('''
              UPDATE story_nodes
              SET stage = '$STAGE',
                  human_review = $( [ "$NEEDS_REVIEW" = "true" ] && echo 1 || echo 0 ),
                  notes = COALESCE(notes || char(10), '') || '$NOTE: ' || datetime('now'),
                  updated_at = datetime('now')
              WHERE id = ?
          ''', ("$STORY_ID",))
          conn.commit()
          print(f"âœ“ Updated story $STORY_ID â†’ $STAGE")
          conn.close()
          PYEOF

      - name: "6.3 Stage all changes"
        if: steps.claude.outputs.outcome == 'success'
        run: |
          git add -A
          if git diff --cached --quiet; then
            echo "has_changes=false" >> $GITHUB_OUTPUT
            echo "No changes to commit"
          else
            echo "has_changes=true" >> $GITHUB_OUTPUT
            echo "Changes staged for commit:"
            git diff --cached --stat
          fi
        id: stage

      - name: "6.4 Commit changes"
        if: steps.stage.outputs.has_changes == 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          FILENAME="${{ steps.select-plan.outputs.filename }}"
          STORY_ID="${{ steps.extract-story.outputs.story_id }}"

          git commit -m "ci: execute plan $FILENAME

          Story: $STORY_ID"

          echo "âœ“ Committed changes"

      - name: "6.5 Push to remote"
        if: steps.stage.outputs.has_changes == 'true'
        run: |
          for attempt in 1 2 3 4; do
            if git push origin main; then
              echo "âœ“ Push successful"
              exit 0
            else
              echo "Push failed (attempt $attempt), retrying in $((2 ** attempt))s..."
              sleep $((2 ** attempt))
            fi
          done
          echo "âŒ Push failed after 4 attempts"
          exit 1

      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # PHASE 7: REPORTING
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      - name: "7.1 Generate execution summary"
        if: always()
        run: |
          echo "## Execution Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Plan info
          if [ "${{ steps.select-plan.outputs.selected }}" = "true" ]; then
            echo "| Field | Value |" >> $GITHUB_STEP_SUMMARY
            echo "|-------|-------|" >> $GITHUB_STEP_SUMMARY
            echo "| Plan | \`${{ steps.select-plan.outputs.filename }}\` |" >> $GITHUB_STEP_SUMMARY
            echo "| Sequence | ${{ steps.select-plan.outputs.sequence }} |" >> $GITHUB_STEP_SUMMARY
            echo "| Story ID | ${{ steps.extract-story.outputs.story_id }} |" >> $GITHUB_STEP_SUMMARY

            # Outcome
            if [ "${{ steps.check-executed.outputs.already_executed }}" = "true" ]; then
              echo "| Outcome | â­ï¸ Skipped (already executed) |" >> $GITHUB_STEP_SUMMARY
            elif [ "${{ steps.check-deps.outputs.deps_met }}" = "false" ]; then
              echo "| Outcome | ğŸš§ Blocked (unmet deps) |" >> $GITHUB_STEP_SUMMARY
              echo "| Unmet Deps | ${{ steps.check-deps.outputs.unmet_deps }} |" >> $GITHUB_STEP_SUMMARY
            elif [ "${{ steps.claude.outputs.outcome }}" = "success" ]; then
              if [ "${{ steps.claude.outputs.needs_review }}" = "true" ]; then
                echo "| Outcome | âœ… Success (review required) |" >> $GITHUB_STEP_SUMMARY
              else
                echo "| Outcome | âœ… Success |" >> $GITHUB_STEP_SUMMARY
              fi
            elif [ "${{ steps.claude.outputs.outcome }}" = "paused" ]; then
              echo "| Outcome | â¸ï¸ Paused (blocking issues) |" >> $GITHUB_STEP_SUMMARY
            elif [ "${{ steps.claude.outputs.outcome }}" = "failure" ]; then
              echo "| Outcome | âŒ Failed |" >> $GITHUB_STEP_SUMMARY
              echo "| Reason | ${{ steps.claude.outputs.reason }} |" >> $GITHUB_STEP_SUMMARY
            else
              echo "| Outcome | âš ï¸ Unknown |" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "No plan files available for execution." >> $GITHUB_STEP_SUMMARY
          fi

      - name: "7.2 Report token usage"
        if: always() && steps.init-state.outputs.initialized == 'true'
        run: |
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Token Usage (Multi-Call)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Aggregate tokens from all Claude calls
          TOTAL_INPUT=0
          TOTAL_OUTPUT=0

          for STEP in review batch1 batch2 batch3 batch4; do
            EXEC_FILE=""
            case "$STEP" in
              review) EXEC_FILE="${{ steps.review.outputs.execution_file }}" ;;
              batch1) EXEC_FILE="${{ steps.batch1.outputs.execution_file }}" ;;
              batch2) EXEC_FILE="${{ steps.batch2.outputs.execution_file }}" ;;
              batch3) EXEC_FILE="${{ steps.batch3.outputs.execution_file }}" ;;
              batch4) EXEC_FILE="${{ steps.batch4.outputs.execution_file }}" ;;
            esac

            if [ -f "$EXEC_FILE" ]; then
              INPUT=$(grep -o '"input_tokens":[0-9]*' "$EXEC_FILE" | cut -d: -f2 | awk '{s+=$1} END {print s+0}')
              OUTPUT=$(grep -o '"output_tokens":[0-9]*' "$EXEC_FILE" | cut -d: -f2 | awk '{s+=$1} END {print s+0}')
              TOTAL_INPUT=$((TOTAL_INPUT + INPUT))
              TOTAL_OUTPUT=$((TOTAL_OUTPUT + OUTPUT))
            fi
          done

          echo "| Metric | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|--------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Input Tokens | $TOTAL_INPUT |" >> $GITHUB_STEP_SUMMARY
          echo "| Output Tokens | $TOTAL_OUTPUT |" >> $GITHUB_STEP_SUMMARY
          echo "| Total Tokens | $((TOTAL_INPUT + TOTAL_OUTPUT)) |" >> $GITHUB_STEP_SUMMARY

      - name: "7.3 Post results to story issue"
        if: always() && steps.extract-story.outputs.story_id != 'none' && steps.extract-story.outputs.story_id != ''
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          STORY_ID="${{ steps.extract-story.outputs.story_id }}"
          FILENAME="${{ steps.select-plan.outputs.filename }}"
          DB_PATH=".claude/data/story-tree.db"

          # Get story title
          TITLE=""
          if [ -f "$DB_PATH" ]; then
            TITLE=$(python3 -c "import sqlite3; c=sqlite3.connect('$DB_PATH'); r=c.execute('SELECT title FROM story_nodes WHERE id=?',('$STORY_ID',)).fetchone(); print(r[0] if r else '')" 2>/dev/null)
          fi
          TITLE="${TITLE:-Story $STORY_ID}"

          ISSUE_TITLE="$STORY_ID - $TITLE"

          # Find or create issue
          ISSUE_NUM=$(gh issue list --state all --search "\"$ISSUE_TITLE\" in:title" --json number,title --jq ".[] | select(.title == \"$ISSUE_TITLE\") | .number" | head -1)

          if [ -z "$ISSUE_NUM" ]; then
            ISSUE_NUM=$(gh issue create --title "$ISSUE_TITLE" --body "Tracking issue for story **$STORY_ID**" --label "story-tracking" 2>/dev/null | grep -oP 'issues/\K[0-9]+' || \
                        gh issue create --title "$ISSUE_TITLE" --body "Tracking issue for story **$STORY_ID**" | grep -oP 'issues/\K[0-9]+' || echo "")
          fi

          if [ -z "$ISSUE_NUM" ]; then
            echo "Could not find/create issue"
            exit 0
          fi

          # Determine status emoji
          CLAUDE="${{ steps.claude.outputs.outcome }}"
          if [ "${{ steps.check-executed.outputs.already_executed }}" = "true" ]; then
            STATUS="â­ï¸ Skipped (already executed)"
          elif [ "${{ steps.check-deps.outputs.deps_met }}" = "false" ]; then
            STATUS="ğŸš§ Blocked (unmet dependencies)"
          elif [ "$CLAUDE" = "success" ]; then
            if [ "${{ steps.claude.outputs.needs_review }}" = "true" ]; then
              STATUS="âœ… Success (review required)"
            else
              STATUS="âœ… Success"
            fi
          elif [ "$CLAUDE" = "paused" ]; then
            STATUS="â¸ï¸ Paused (blocking issues)"
          elif [ "$CLAUDE" = "failure" ]; then
            STATUS="âŒ Failed"
          else
            STATUS="âš ï¸ $CLAUDE"
          fi

          RUN_URL="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"

          BODY="## $STATUS

          **Plan:** \`$FILENAME\`
          **Time:** $(date -u +'%Y-%m-%d %H:%M:%S UTC')
          **Run:** [View Details]($RUN_URL)

          ---
          *Posted by [execute-stories workflow]($RUN_URL)*"

          echo "$BODY" | gh issue comment "$ISSUE_NUM" --body-file -
          echo "Posted to issue #$ISSUE_NUM"
