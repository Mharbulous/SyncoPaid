name: 4. Execute Story

on:
  schedule:
    - cron: '*/20 * * * *'
  workflow_dispatch:

concurrency:
  group: daily-story-execution
  cancel-in-progress: false

permissions:
  contents: write
  issues: write
  pull-requests: write
  id-token: write

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# PIPELINE VISUALIZATION
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# This workflow uses 5 semantically meaningful stages:
#
#   setup-and-plan ‚Üí review-plan ‚Üí decompose ‚Üí execute ‚Üí finalize
#
# Each stage has a clear purpose:
# - setup-and-plan: Find plan, validate deps, initialize state
# - review-plan: Critical review, decide proceed/pause
# - decompose: Assess complexity, split if needed (Opus)
# - execute: Follow plan's TDD steps directly (Sonnet)
# - finalize: Archive, commit, report
#
# State is passed between jobs via:
# - Job outputs: simple strings (outcome, status, paths)
# - The plan document itself is the source of truth
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

jobs:
  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  # SETUP-AND-PLAN: Find plan, validate dependencies, initialize state
  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  setup-and-plan:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      plan_selected: ${{ steps.select-plan.outputs.selected }}
      plan_path: ${{ steps.select-plan.outputs.path }}
      plan_filename: ${{ steps.select-plan.outputs.filename }}
      plan_sequence: ${{ steps.select-plan.outputs.sequence }}
      story_id: ${{ steps.extract-story.outputs.story_id }}
      should_execute: ${{ steps.determine.outputs.should_execute }}
      skip_reason: ${{ steps.determine.outputs.skip_reason }}

    steps:
      # ‚îÄ‚îÄ PHASE 1: SETUP ‚îÄ‚îÄ
      - name: "1.1 Checkout repository"
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      # ‚îÄ‚îÄ PHASE 2: PLAN SELECTION ‚îÄ‚îÄ
      - name: "2.1 Find available plans"
        id: find-plans
        run: |
          echo "## Plan Discovery" >> $GITHUB_STEP_SUMMARY

          PLANS_DIR=".claude/data/plans"
          if [ ! -d "$PLANS_DIR" ]; then
            echo "plans_found=0" >> $GITHUB_OUTPUT
            echo "‚ùå Plans directory not found: $PLANS_DIR" >> $GITHUB_STEP_SUMMARY
            exit 0
          fi

          PLAN_COUNT=$(find "$PLANS_DIR" -maxdepth 1 -name "*.md" -type f | wc -l)
          echo "plans_found=$PLAN_COUNT" >> $GITHUB_OUTPUT
          echo "Found **$PLAN_COUNT** plan files in $PLANS_DIR" >> $GITHUB_STEP_SUMMARY

          if [ "$PLAN_COUNT" -gt 0 ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| Plan File | Sequence |" >> $GITHUB_STEP_SUMMARY
            echo "|-----------|----------|" >> $GITHUB_STEP_SUMMARY
            for f in $(ls -1 "$PLANS_DIR"/*.md 2>/dev/null | head -10); do
              FNAME=$(basename "$f")
              SEQ=$(echo "$FNAME" | grep -oP '^\d{3}[A-Z]?' || echo "?")
              echo "| $FNAME | $SEQ |" >> $GITHUB_STEP_SUMMARY
            done
          fi

      - name: "2.2 Select earliest plan"
        id: select-plan
        if: steps.find-plans.outputs.plans_found != '0'
        run: |
          python3 << 'PYEOF'
          import os, re, json

          plans_dir = '.claude/data/plans'
          pattern = re.compile(r'^(\d{3})([A-Z])?_(.+)\.md$')

          plans = []
          for f in os.listdir(plans_dir):
              path = os.path.join(plans_dir, f)
              if os.path.isfile(path) and f.endswith('.md'):
                  m = pattern.match(f)
                  if m:
                      plans.append({
                          'filename': f,
                          'path': path,
                          'sequence': int(m.group(1)),
                          'letter': m.group(2) or '',
                      })

          plans.sort(key=lambda x: (x['sequence'], x['letter']))

          if plans:
              selected = plans[0]
              with open(os.environ['GITHUB_OUTPUT'], 'a') as out:
                  out.write(f"selected=true\n")
                  out.write(f"filename={selected['filename']}\n")
                  out.write(f"path={selected['path']}\n")
                  out.write(f"sequence={selected['sequence']}{selected['letter']}\n")
              print(f"Selected: {selected['filename']}")
          else:
              with open(os.environ['GITHUB_OUTPUT'], 'a') as out:
                  out.write("selected=false\n")
              print("No valid plan files found")
          PYEOF

      - name: "2.3 Extract Story ID from plan"
        id: extract-story
        if: steps.select-plan.outputs.selected == 'true'
        run: |
          PLAN_PATH="${{ steps.select-plan.outputs.path }}"

          STORY_ID=$(grep -oP 'Story ID[:\s]*\K\d+(\.\d+)*' "$PLAN_PATH" | head -1)

          if [ -z "$STORY_ID" ]; then
            STORY_ID=$(grep -oP '\*\*Story ID:\*\*\s*\K\d+(\.\d+)*' "$PLAN_PATH" | head -1)
          fi

          echo "story_id=${STORY_ID:-none}" >> $GITHUB_OUTPUT
          echo "Story ID: ${STORY_ID:-'(not found)'}"

      # ‚îÄ‚îÄ PHASE 3: VALIDATION ‚îÄ‚îÄ
      - name: "3.1 Check if story already executed"
        id: check-executed
        if: steps.select-plan.outputs.selected == 'true' && steps.extract-story.outputs.story_id != 'none'
        run: |
          STORY_ID="${{ steps.extract-story.outputs.story_id }}"
          DB_PATH=".claude/data/story-tree.db"

          if [ ! -f "$DB_PATH" ]; then
            echo "already_executed=false" >> $GITHUB_OUTPUT
            echo "Database not found, assuming not executed"
            exit 0
          fi

          STAGE=$(python3 -c "
          import sqlite3
          conn = sqlite3.connect('$DB_PATH')
          r = conn.execute('SELECT stage FROM story_nodes WHERE id = ?', ('$STORY_ID',)).fetchone()
          print(r[0] if r else 'unknown')
          conn.close()
          ")

          echo "Current stage: $STAGE"

          case "$STAGE" in
            reviewing|verifying|implemented|ready|polish|released)
              echo "already_executed=true" >> $GITHUB_OUTPUT
              echo "current_stage=$STAGE" >> $GITHUB_OUTPUT
              echo "‚ö†Ô∏è Story $STORY_ID already at stage: $STAGE"
              ;;
            *)
              echo "already_executed=false" >> $GITHUB_OUTPUT
              echo "current_stage=$STAGE" >> $GITHUB_OUTPUT
              echo "‚úì Story $STORY_ID ready for execution (stage: $STAGE)"
              ;;
          esac

      - name: "3.2 Check story dependencies"
        id: check-deps
        if: steps.select-plan.outputs.selected == 'true' && steps.check-executed.outputs.already_executed != 'true'
        run: |
          STORY_ID="${{ steps.extract-story.outputs.story_id }}"
          PLAN_PATH="${{ steps.select-plan.outputs.path }}"
          DB_PATH=".claude/data/story-tree.db"

          if [ "$STORY_ID" = "none" ] || [ ! -f "$DB_PATH" ]; then
            echo "deps_met=true" >> $GITHUB_OUTPUT
            echo "No Story ID or database, skipping dependency check"
            exit 0
          fi

          python3 << PYEOF
          import sqlite3, re, os

          story_id = "$STORY_ID"
          db_path = "$DB_PATH"
          plan_path = "$PLAN_PATH"

          conn = sqlite3.connect(db_path)

          result = conn.execute('SELECT description, notes FROM story_nodes WHERE id = ?', (story_id,)).fetchone()
          if not result:
              with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                  f.write("deps_met=true\n")
              print("Story not in database, proceeding")
              exit(0)

          text = (result[0] or '') + ' ' + (result[1] or '')

          with open(plan_path, 'r') as f:
              text += ' ' + f.read()

          dep_pattern = r'(?:depends on|requires|after|blocked by)\s+(\d+(?:\.\d+)*)'
          deps = set(re.findall(dep_pattern, text, re.IGNORECASE))
          deps.discard(story_id)

          if not deps:
              with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                  f.write("deps_met=true\n")
              print("No dependencies found")
              exit(0)

          IMPLEMENTED = ('implemented', 'ready', 'polish', 'released')
          unmet = []
          for dep_id in deps:
              r = conn.execute('SELECT stage FROM story_nodes WHERE id = ? AND disposition IS NULL', (dep_id,)).fetchone()
              if r and r[0] not in IMPLEMENTED:
                  unmet.append(f"{dep_id} ({r[0]})")

          conn.close()

          if unmet:
              with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                  f.write("deps_met=false\n")
                  f.write(f"unmet_deps={', '.join(unmet)}\n")
              print(f"‚ùå Unmet dependencies: {', '.join(unmet)}")
          else:
              with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                  f.write("deps_met=true\n")
              print("‚úì All dependencies met")
          PYEOF

      # ‚îÄ‚îÄ PHASE 4: HANDLE SKIP CONDITIONS ‚îÄ‚îÄ
      - name: "4.1 Archive already-executed plan"
        if: steps.check-executed.outputs.already_executed == 'true'
        run: |
          PLAN_PATH="${{ steps.select-plan.outputs.path }}"
          FILENAME="${{ steps.select-plan.outputs.filename }}"
          ARCHIVE_DIR=".claude/data/executed"

          mkdir -p "$ARCHIVE_DIR"
          mv "$PLAN_PATH" "$ARCHIVE_DIR/"
          echo "Archived already-executed plan: $FILENAME ‚Üí $ARCHIVE_DIR/"

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add -A
          git commit -m "ci: archive already-executed plan $FILENAME"
          git push origin main

      - name: "4.2 Move blocked plan to blocked folder"
        if: steps.check-deps.outputs.deps_met == 'false'
        run: |
          PLAN_PATH="${{ steps.select-plan.outputs.path }}"
          FILENAME="${{ steps.select-plan.outputs.filename }}"
          BLOCKED_DIR=".claude/data/plans/blocked"
          UNMET="${{ steps.check-deps.outputs.unmet_deps }}"

          mkdir -p "$BLOCKED_DIR"
          mv "$PLAN_PATH" "$BLOCKED_DIR/"
          echo "Moved blocked plan: $FILENAME ‚Üí $BLOCKED_DIR/"
          echo "Unmet dependencies: $UNMET"

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add -A
          git commit -m "ci: move blocked plan $FILENAME (deps: $UNMET)"
          git push origin main

      # ‚îÄ‚îÄ DETERMINE IF EXECUTION SHOULD PROCEED ‚îÄ‚îÄ
      - name: "4.3 Determine execution eligibility"
        id: determine
        run: |
          SELECTED="${{ steps.select-plan.outputs.selected }}"
          ALREADY_EXECUTED="${{ steps.check-executed.outputs.already_executed }}"
          DEPS_MET="${{ steps.check-deps.outputs.deps_met }}"

          if [ "$SELECTED" != "true" ]; then
            echo "should_execute=false" >> $GITHUB_OUTPUT
            echo "skip_reason=no_plans" >> $GITHUB_OUTPUT
          elif [ "$ALREADY_EXECUTED" = "true" ]; then
            echo "should_execute=false" >> $GITHUB_OUTPUT
            echo "skip_reason=already_executed" >> $GITHUB_OUTPUT
          elif [ "$DEPS_MET" = "false" ]; then
            echo "should_execute=false" >> $GITHUB_OUTPUT
            echo "skip_reason=deps_unmet" >> $GITHUB_OUTPUT
          else
            echo "should_execute=true" >> $GITHUB_OUTPUT
            echo "skip_reason=" >> $GITHUB_OUTPUT
          fi

  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  # REVIEW-PLAN: Critical review - validate plan is actionable
  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  review-plan:
    needs: setup-and-plan
    if: needs.setup-and-plan.outputs.should_execute == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 15
    outputs:
      outcome: ${{ steps.review-output.outputs.outcome }}
      review_completed: ${{ steps.review-output.outputs.review_completed }}

    steps:
      - name: "1.0 Checkout repository"
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: "1.1 Review plan critically"
        id: review
        uses: anthropics/claude-code-action@v1
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          show_full_output: true
          prompt: |
            You are reviewing a plan document for CI execution.

            Plan: ${{ needs.setup-and-plan.outputs.plan_path }}
            Story ID: ${{ needs.setup-and-plan.outputs.story_id }}

            ## YOUR TASK

            1. Read the plan file completely
            2. Review it critically - identify any blocking or deferrable issues
            3. Determine if the plan is ready to execute

            ## ISSUE CLASSIFICATION

            ### Blocking Issues (set outcome to "pause")
            - Architectural choices with significant trade-offs
            - Security implications (auth, data exposure, permissions)
            - Breaking changes to existing functionality
            - Missing critical information
            - Conflicting requirements
            - Dependencies not implemented

            ### Deferrable Issues (set outcome to "proceed_with_review")
            - Code style preferences
            - Minor optimizations
            - Naming conventions
            - Documentation gaps
            - Non-critical edge cases

            ### No Issues (set outcome to "proceed")
            - Plan is clear and actionable
            - Prerequisites are met
            - TDD steps are well-defined

            ## OUTPUT REQUIRED

            Write a JSON file to `.claude/skills/story-execution/ci-review-result.json`:

            ```json
            {
              "outcome": "proceed|pause|proceed_with_review",
              "blocking_issues": [],
              "deferrable_issues": [],
              "notes": "Brief summary of review findings"
            }
            ```

            Do NOT extract tasks from the plan. The execute stage will read the plan directly.

          claude_args: |
            --allowedTools "Read,Write,Edit,Glob,Grep,Bash(python:*),Bash(python3:*),Bash(mkdir:*)"
            --model claude-sonnet-4-5-20250929
            --max-turns 15

      - name: "1.2 Read review output"
        id: review-output
        if: always()
        run: |
          RESULT_FILE=".claude/skills/story-execution/ci-review-result.json"
          if [ -f "$RESULT_FILE" ]; then
            OUTCOME=$(python3 -c "import json; d=json.load(open('$RESULT_FILE')); print(d.get('outcome','unknown'))")
            if [ "$OUTCOME" = "proceed" ] || [ "$OUTCOME" = "proceed_with_review" ] || [ "$OUTCOME" = "pause" ]; then
              echo "outcome=$OUTCOME" >> $GITHUB_OUTPUT
              echo "review_completed=true" >> $GITHUB_OUTPUT
              echo "Review outcome: $OUTCOME"
            else
              echo "outcome=failed" >> $GITHUB_OUTPUT
              echo "review_completed=false" >> $GITHUB_OUTPUT
              echo "Review not completed - outcome: $OUTCOME"
            fi
          else
            echo "outcome=failed" >> $GITHUB_OUTPUT
            echo "review_completed=false" >> $GITHUB_OUTPUT
            echo "Result file not found"
          fi

      - name: "1.3 Upload review result"
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: review-result
          path: .claude/skills/story-execution/ci-review-result.json
          retention-days: 1
          if-no-files-found: ignore

  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  # DECOMPOSE: Assess complexity, split into sub-plans if needed (Opus)
  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  decompose:
    needs: [setup-and-plan, review-plan]
    if: |
      needs.review-plan.outputs.review_completed == 'true' &&
      (needs.review-plan.outputs.outcome == 'proceed' || needs.review-plan.outputs.outcome == 'proceed_with_review')
    runs-on: ubuntu-latest
    timeout-minutes: 20
    outputs:
      complexity: ${{ steps.decompose-output.outputs.complexity }}
      execute_plan: ${{ steps.decompose-output.outputs.execute_plan }}
      sub_plans_created: ${{ steps.decompose-output.outputs.sub_plans_created }}

    steps:
      - name: "2.0 Checkout repository"
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: "2.1 Assess plan complexity"
        id: decompose
        uses: anthropics/claude-code-action@v1
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          show_full_output: true
          prompt: |
            You are assessing plan complexity and potentially decomposing it into sub-plans.

            Plan: ${{ needs.setup-and-plan.outputs.plan_path }}
            Story ID: ${{ needs.setup-and-plan.outputs.story_id }}
            Plan filename: ${{ needs.setup-and-plan.outputs.plan_filename }}

            ## YOUR TASK

            1. Read the plan file completely
            2. Count the number of TDD tasks
            3. Assess overall complexity based on:
               - Number of tasks (>6 is complex)
               - Cross-file dependencies
               - Integration complexity
               - Test complexity

            ## COMPLEXITY LEVELS

            - **simple**: 1-3 tasks, straightforward changes
            - **medium**: 4-6 tasks, moderate complexity
            - **complex**: 7+ tasks OR high integration complexity

            ## DECOMPOSITION RULES

            If complexity is "complex":
            1. Split into logical sub-plans of 3-5 tasks each
            2. Name sub-plans with letter suffixes: 016A_..., 016B_..., 016C_...
            3. First sub-plan (A) executes now, others saved for future runs
            4. Each sub-plan must be independently executable
            5. Save sub-plans to `.claude/data/plans/`

            ## OUTPUT REQUIRED

            Write a JSON file to `.claude/skills/story-execution/ci-decompose-result.json`:

            ```json
            {
              "complexity": "simple|medium|complex",
              "task_count": 5,
              "execute_plan": ".claude/data/plans/016_configurable-idle-threshold.md",
              "sub_plans_created": [],
              "notes": "Brief explanation"
            }
            ```

            If decomposed:
            ```json
            {
              "complexity": "complex",
              "task_count": 12,
              "execute_plan": ".claude/data/plans/016A_configurable-idle-threshold.md",
              "sub_plans_created": [
                ".claude/data/plans/016B_idle-threshold-integration.md",
                ".claude/data/plans/016C_idle-threshold-ui.md"
              ],
              "notes": "Split into 3 sub-plans: A (validation), B (integration), C (UI)"
            }
            ```

            IMPORTANT: If you create sub-plans, you must:
            1. Move the original plan to executed folder OR keep it if you're just extracting sub-plans
            2. Create the new sub-plan files with proper content
            3. The execute_plan should be the FIRST sub-plan to execute (A suffix)

          claude_args: |
            --allowedTools "Read,Write,Edit,Glob,Grep,Bash(python:*),Bash(python3:*),Bash(mkdir:*),Bash(mv:*),Bash(cp:*)"
            --model claude-opus-4-5-20251101
            --max-turns 25

      - name: "2.2 Read decompose output"
        id: decompose-output
        if: always()
        run: |
          RESULT_FILE=".claude/skills/story-execution/ci-decompose-result.json"
          PLAN_PATH="${{ needs.setup-and-plan.outputs.plan_path }}"

          if [ -f "$RESULT_FILE" ]; then
            COMPLEXITY=$(python3 -c "import json; d=json.load(open('$RESULT_FILE')); print(d.get('complexity','unknown'))")
            EXECUTE_PLAN=$(python3 -c "import json; d=json.load(open('$RESULT_FILE')); print(d.get('execute_plan',''))")
            SUB_PLANS=$(python3 -c "import json; d=json.load(open('$RESULT_FILE')); print(','.join(d.get('sub_plans_created',[])))")

            echo "complexity=$COMPLEXITY" >> $GITHUB_OUTPUT
            echo "execute_plan=${EXECUTE_PLAN:-$PLAN_PATH}" >> $GITHUB_OUTPUT
            echo "sub_plans_created=$SUB_PLANS" >> $GITHUB_OUTPUT

            echo "Complexity: $COMPLEXITY"
            echo "Execute plan: ${EXECUTE_PLAN:-$PLAN_PATH}"
            if [ -n "$SUB_PLANS" ]; then
              echo "Sub-plans created: $SUB_PLANS"
            fi
          else
            # Default to original plan if no result
            echo "complexity=unknown" >> $GITHUB_OUTPUT
            echo "execute_plan=$PLAN_PATH" >> $GITHUB_OUTPUT
            echo "sub_plans_created=" >> $GITHUB_OUTPUT
            echo "No decompose result, using original plan"
          fi

      - name: "2.3 Commit sub-plans if created"
        if: steps.decompose-output.outputs.sub_plans_created != ''
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add -A

          if ! git diff --cached --quiet; then
            STORY_ID="${{ needs.setup-and-plan.outputs.story_id }}"
            git commit -m "ci: decompose plan into sub-plans

            Story: $STORY_ID
            Complexity: ${{ steps.decompose-output.outputs.complexity }}
            Sub-plans: ${{ steps.decompose-output.outputs.sub_plans_created }}"

            git push origin main
            echo "‚úì Committed sub-plans"
          else
            echo "No changes to commit"
          fi

      - name: "2.4 Upload decompose result"
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: decompose-result
          path: .claude/skills/story-execution/ci-decompose-result.json
          retention-days: 1
          if-no-files-found: ignore

  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  # EXECUTE: Follow plan's TDD steps directly (Sonnet)
  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  execute:
    needs: [setup-and-plan, review-plan, decompose]
    if: |
      needs.decompose.outputs.execute_plan != ''
    runs-on: ubuntu-latest
    timeout-minutes: 45
    outputs:
      status: ${{ steps.execute-output.outputs.status }}
      commits_made: ${{ steps.execute-output.outputs.commits_made }}

    steps:
      - name: "3.0 Checkout repository"
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: "3.1 Pull latest changes"
        run: |
          git pull origin main --rebase || true

      - name: "3.2 Execute plan"
        id: execute
        uses: anthropics/claude-code-action@v1
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          show_full_output: true
          prompt: |
            You are executing a TDD implementation plan in CI mode.

            Plan to execute: ${{ needs.decompose.outputs.execute_plan }}
            Story ID: ${{ needs.setup-and-plan.outputs.story_id }}
            Review outcome: ${{ needs.review-plan.outputs.outcome }}

            ## YOUR TASK

            1. Read the plan document completely
            2. Follow EACH task's TDD steps EXACTLY as written in the plan:
               - RED: Write the failing test as specified
               - Verify RED: Run the test, confirm it fails for the right reason
               - GREEN: Implement the code as specified
               - Verify GREEN: Run the test, confirm it passes
               - COMMIT: Stage and commit with the message format shown
            3. Continue through ALL tasks in the plan
            4. After each task, immediately commit your changes

            ## TDD DISCIPLINE

            - Follow the plan's test code EXACTLY - do not modify tests
            - Follow the plan's implementation code as a guide
            - If a test already passes (RED fails to be RED), note it and move on
            - If you get stuck on a task, document what happened and continue

            ## COMMIT FORMAT

            Use the format specified in the plan, typically:
            ```
            feat: [task description]

            Story: ${{ needs.setup-and-plan.outputs.story_id }}
            Task: N of M
            ```

            ## OUTPUT REQUIRED

            After completing all tasks, write to `.claude/skills/story-execution/ci-execute-result.json`:

            ```json
            {
              "status": "completed|partial|failed",
              "tasks_completed": 5,
              "tasks_total": 5,
              "commits": ["abc1234", "def5678", ...],
              "notes": "Brief summary of execution"
            }
            ```

            ## IMPORTANT

            - Read the plan document directly - it contains all instructions
            - The plan has explicit test code and implementation code to follow
            - Do NOT skip the verification steps (run pytest after each RED and GREEN)
            - Push is handled by the finalize stage, just commit locally

          claude_args: |
            --allowedTools "Read,Write,Edit,Glob,Grep,Bash(git:*),Bash(python:*),Bash(python3:*),Bash(pytest:*),Bash(pip:*),Bash(mkdir:*),BashOutput,TodoWrite"
            --model claude-sonnet-4-5-20250929
            --max-turns 50

      - name: "3.3 Read execute output"
        id: execute-output
        if: always()
        run: |
          RESULT_FILE=".claude/skills/story-execution/ci-execute-result.json"

          if [ -f "$RESULT_FILE" ]; then
            STATUS=$(python3 -c "import json; d=json.load(open('$RESULT_FILE')); print(d.get('status','unknown'))")
            COMMITS=$(python3 -c "import json; d=json.load(open('$RESULT_FILE')); print(','.join(d.get('commits',[])))")
            COMPLETED=$(python3 -c "import json; d=json.load(open('$RESULT_FILE')); print(d.get('tasks_completed',0))")
            TOTAL=$(python3 -c "import json; d=json.load(open('$RESULT_FILE')); print(d.get('tasks_total',0))")

            echo "status=$STATUS" >> $GITHUB_OUTPUT
            echo "commits_made=$COMMITS" >> $GITHUB_OUTPUT

            echo "Status: $STATUS"
            echo "Tasks: $COMPLETED/$TOTAL"
            echo "Commits: $COMMITS"
          else
            # Check if there are uncommitted changes or new commits
            UNCOMMITTED=$(git status --porcelain | wc -l)
            NEW_COMMITS=$(git log origin/main..HEAD --oneline 2>/dev/null | wc -l)

            if [ "$NEW_COMMITS" -gt 0 ] || [ "$UNCOMMITTED" -gt 0 ]; then
              echo "status=partial" >> $GITHUB_OUTPUT
              echo "commits_made=" >> $GITHUB_OUTPUT
              echo "No result file, but found $NEW_COMMITS new commits and $UNCOMMITTED uncommitted changes"
            else
              echo "status=failed" >> $GITHUB_OUTPUT
              echo "commits_made=" >> $GITHUB_OUTPUT
              echo "No result file and no changes detected"
            fi
          fi

      - name: "3.4 Upload execute result"
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: execute-result
          path: .claude/skills/story-execution/ci-execute-result.json
          retention-days: 1
          if-no-files-found: ignore

  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  # FINALIZE: Archive, commit, push, report
  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  finalize:
    needs: [setup-and-plan, review-plan, decompose, execute]
    if: always()
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: "4.0 Checkout repository"
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: "4.0.1 Pull latest changes"
        run: |
          git pull origin main --rebase || true

      - name: "4.1 Determine final outcome"
        id: outcome
        run: |
          SHOULD_EXECUTE="${{ needs.setup-and-plan.outputs.should_execute }}"
          SKIP_REASON="${{ needs.setup-and-plan.outputs.skip_reason }}"

          # If setup determined we shouldn't execute, report that
          if [ "$SHOULD_EXECUTE" != "true" ]; then
            echo "outcome=skipped" >> $GITHUB_OUTPUT
            echo "reason=$SKIP_REASON" >> $GITHUB_OUTPUT
            exit 0
          fi

          REVIEW_COMPLETED="${{ needs.review-plan.outputs.review_completed }}"
          if [ "$REVIEW_COMPLETED" != "true" ]; then
            echo "outcome=failure" >> $GITHUB_OUTPUT
            echo "reason=review_failed" >> $GITHUB_OUTPUT
            exit 0
          fi

          REVIEW_OUTCOME="${{ needs.review-plan.outputs.outcome }}"
          if [ "$REVIEW_OUTCOME" = "pause" ]; then
            echo "outcome=paused" >> $GITHUB_OUTPUT
            echo "reason=blocking_issues" >> $GITHUB_OUTPUT
            exit 0
          fi

          EXECUTE_STATUS="${{ needs.execute.outputs.status }}"
          case "$EXECUTE_STATUS" in
            completed)
              if [ "$REVIEW_OUTCOME" = "proceed_with_review" ]; then
                echo "outcome=success" >> $GITHUB_OUTPUT
                echo "needs_review=true" >> $GITHUB_OUTPUT
              else
                echo "outcome=success" >> $GITHUB_OUTPUT
                echo "needs_review=false" >> $GITHUB_OUTPUT
              fi
              ;;
            partial)
              echo "outcome=partial" >> $GITHUB_OUTPUT
              echo "needs_review=true" >> $GITHUB_OUTPUT
              ;;
            failed|"")
              echo "outcome=failure" >> $GITHUB_OUTPUT
              echo "reason=execution_failed" >> $GITHUB_OUTPUT
              ;;
            *)
              echo "outcome=unknown" >> $GITHUB_OUTPUT
              echo "reason=unknown_status" >> $GITHUB_OUTPUT
              ;;
          esac

      - name: "4.2 Archive executed plan"
        if: steps.outcome.outputs.outcome == 'success'
        run: |
          EXECUTE_PLAN="${{ needs.decompose.outputs.execute_plan }}"
          ARCHIVE_DIR=".claude/data/executed"

          if [ -f "$EXECUTE_PLAN" ]; then
            mkdir -p "$ARCHIVE_DIR"
            mv "$EXECUTE_PLAN" "$ARCHIVE_DIR/"
            echo "‚úì Archived: $EXECUTE_PLAN ‚Üí $ARCHIVE_DIR/"
          else
            echo "Plan already archived or moved"
          fi

      - name: "4.3 Update story status in database"
        if: (steps.outcome.outputs.outcome == 'success' || steps.outcome.outputs.outcome == 'partial') && needs.setup-and-plan.outputs.story_id != 'none'
        run: |
          STORY_ID="${{ needs.setup-and-plan.outputs.story_id }}"
          DB_PATH=".claude/data/story-tree.db"
          NEEDS_REVIEW="${{ steps.outcome.outputs.needs_review }}"
          OUTCOME="${{ steps.outcome.outputs.outcome }}"

          if [ ! -f "$DB_PATH" ]; then
            echo "Database not found, skipping status update"
            exit 0
          fi

          if [ "$NEEDS_REVIEW" = "true" ]; then
            STAGE="reviewing"
            NOTE="CI execution $OUTCOME (review required)"
            REVIEW_FLAG=1
          else
            STAGE="verifying"
            NOTE="CI execution complete"
            REVIEW_FLAG=0
          fi

          python3 << PYEOF
          import sqlite3
          conn = sqlite3.connect("$DB_PATH")
          conn.execute('''
              UPDATE story_nodes
              SET stage = '$STAGE',
                  human_review = $REVIEW_FLAG,
                  notes = COALESCE(notes || char(10), '') || '$NOTE: ' || datetime('now'),
                  updated_at = datetime('now')
              WHERE id = ?
          ''', ("$STORY_ID",))
          conn.commit()
          print(f"‚úì Updated story $STORY_ID ‚Üí $STAGE")
          conn.close()
          PYEOF

      - name: "4.4 Stage all changes"
        if: steps.outcome.outputs.outcome == 'success' || steps.outcome.outputs.outcome == 'partial'
        id: stage
        run: |
          git add -A
          if git diff --cached --quiet; then
            echo "has_changes=false" >> $GITHUB_OUTPUT
            echo "No changes to commit"
          else
            echo "has_changes=true" >> $GITHUB_OUTPUT
            echo "Changes staged for commit:"
            git diff --cached --stat
          fi

      - name: "4.5 Commit changes"
        if: steps.stage.outputs.has_changes == 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          EXECUTE_PLAN="${{ needs.decompose.outputs.execute_plan }}"
          STORY_ID="${{ needs.setup-and-plan.outputs.story_id }}"
          PLAN_FILENAME=$(basename "$EXECUTE_PLAN")

          git commit -m "ci: execute plan $PLAN_FILENAME

          Story: $STORY_ID"

          echo "‚úì Committed changes"

      - name: "4.6 Push to remote"
        if: steps.stage.outputs.has_changes == 'true'
        run: |
          for attempt in 1 2 3 4; do
            if git push origin main; then
              echo "‚úì Push successful"
              exit 0
            else
              echo "Push failed (attempt $attempt), retrying in $((2 ** attempt))s..."
              sleep $((2 ** attempt))
            fi
          done
          echo "‚ùå Push failed after 4 attempts"
          exit 1

      # ‚îÄ‚îÄ REPORTING ‚îÄ‚îÄ
      - name: "4.7 Generate execution summary"
        if: always()
        run: |
          echo "## Execution Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          PLAN_SELECTED="${{ needs.setup-and-plan.outputs.plan_selected }}"
          if [ "$PLAN_SELECTED" = "true" ]; then
            echo "| Field | Value |" >> $GITHUB_STEP_SUMMARY
            echo "|-------|-------|" >> $GITHUB_STEP_SUMMARY
            echo "| Plan | \`${{ needs.setup-and-plan.outputs.plan_filename }}\` |" >> $GITHUB_STEP_SUMMARY
            echo "| Sequence | ${{ needs.setup-and-plan.outputs.plan_sequence }} |" >> $GITHUB_STEP_SUMMARY
            echo "| Story ID | ${{ needs.setup-and-plan.outputs.story_id }} |" >> $GITHUB_STEP_SUMMARY
            echo "| Complexity | ${{ needs.decompose.outputs.complexity }} |" >> $GITHUB_STEP_SUMMARY

            OUTCOME="${{ steps.outcome.outputs.outcome }}"
            case "$OUTCOME" in
              success)
                if [ "${{ steps.outcome.outputs.needs_review }}" = "true" ]; then
                  echo "| Outcome | ‚úÖ Success (review required) |" >> $GITHUB_STEP_SUMMARY
                else
                  echo "| Outcome | ‚úÖ Success |" >> $GITHUB_STEP_SUMMARY
                fi
                ;;
              partial)
                echo "| Outcome | ‚ö†Ô∏è Partial (review required) |" >> $GITHUB_STEP_SUMMARY
                ;;
              paused)
                echo "| Outcome | ‚è∏Ô∏è Paused (blocking issues) |" >> $GITHUB_STEP_SUMMARY
                ;;
              failure)
                echo "| Outcome | ‚ùå Failed |" >> $GITHUB_STEP_SUMMARY
                echo "| Reason | ${{ steps.outcome.outputs.reason }} |" >> $GITHUB_STEP_SUMMARY
                ;;
              skipped)
                SKIP_REASON="${{ needs.setup-and-plan.outputs.skip_reason }}"
                case "$SKIP_REASON" in
                  already_executed)
                    echo "| Outcome | ‚è≠Ô∏è Skipped (already executed) |" >> $GITHUB_STEP_SUMMARY
                    ;;
                  deps_unmet)
                    echo "| Outcome | üöß Blocked (unmet deps) |" >> $GITHUB_STEP_SUMMARY
                    ;;
                  *)
                    echo "| Outcome | ‚è≠Ô∏è Skipped ($SKIP_REASON) |" >> $GITHUB_STEP_SUMMARY
                    ;;
                esac
                ;;
              *)
                echo "| Outcome | ‚ö†Ô∏è Unknown |" >> $GITHUB_STEP_SUMMARY
                ;;
            esac
          else
            echo "No plan files available for execution." >> $GITHUB_STEP_SUMMARY
          fi

      - name: "4.8 Report pipeline status"
        if: always() && needs.setup-and-plan.outputs.should_execute == 'true'
        run: |
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Pipeline Stages" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Stage | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| setup-and-plan | ‚úÖ |" >> $GITHUB_STEP_SUMMARY

          REVIEW="${{ needs.review-plan.outputs.outcome }}"
          if [ -n "$REVIEW" ]; then
            echo "| review-plan | $REVIEW |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| review-plan | ‚è≠Ô∏è skipped |" >> $GITHUB_STEP_SUMMARY
          fi

          COMPLEXITY="${{ needs.decompose.outputs.complexity }}"
          if [ -n "$COMPLEXITY" ]; then
            echo "| decompose | $COMPLEXITY |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| decompose | ‚è≠Ô∏è skipped |" >> $GITHUB_STEP_SUMMARY
          fi

          EXECUTE="${{ needs.execute.outputs.status }}"
          if [ -n "$EXECUTE" ]; then
            echo "| execute | $EXECUTE |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| execute | ‚è≠Ô∏è skipped |" >> $GITHUB_STEP_SUMMARY
          fi

          echo "| finalize | ${{ steps.outcome.outputs.outcome }} |" >> $GITHUB_STEP_SUMMARY

      - name: "4.9 Post results to story issue"
        if: always() && needs.setup-and-plan.outputs.story_id != 'none' && needs.setup-and-plan.outputs.story_id != ''
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          STORY_ID="${{ needs.setup-and-plan.outputs.story_id }}"
          EXECUTE_PLAN="${{ needs.decompose.outputs.execute_plan }}"
          PLAN_FILENAME=$(basename "$EXECUTE_PLAN" 2>/dev/null || echo "${{ needs.setup-and-plan.outputs.plan_filename }}")
          DB_PATH=".claude/data/story-tree.db"

          TITLE=""
          if [ -f "$DB_PATH" ]; then
            TITLE=$(python3 -c "import sqlite3; c=sqlite3.connect('$DB_PATH'); r=c.execute('SELECT title FROM story_nodes WHERE id=?',('$STORY_ID',)).fetchone(); print(r[0] if r else '')" 2>/dev/null)
          fi
          TITLE="${TITLE:-Story $STORY_ID}"

          ISSUE_TITLE="$STORY_ID - $TITLE"

          ISSUE_NUM=$(gh issue list --state all --search "\"$ISSUE_TITLE\" in:title" --json number,title --jq ".[] | select(.title == \"$ISSUE_TITLE\") | .number" | head -1)

          if [ -z "$ISSUE_NUM" ]; then
            ISSUE_NUM=$(gh issue create --title "$ISSUE_TITLE" --body "Tracking issue for story **$STORY_ID**" --label "story-tracking" 2>/dev/null | grep -oP 'issues/\K[0-9]+' || \
                        gh issue create --title "$ISSUE_TITLE" --body "Tracking issue for story **$STORY_ID**" | grep -oP 'issues/\K[0-9]+' || echo "")
          fi

          if [ -z "$ISSUE_NUM" ]; then
            echo "Could not find/create issue"
            exit 0
          fi

          OUTCOME="${{ steps.outcome.outputs.outcome }}"
          case "$OUTCOME" in
            success)
              if [ "${{ steps.outcome.outputs.needs_review }}" = "true" ]; then
                STATUS="‚úÖ Success (review required)"
              else
                STATUS="‚úÖ Success"
              fi
              ;;
            partial)
              STATUS="‚ö†Ô∏è Partial (review required)"
              ;;
            paused)
              STATUS="‚è∏Ô∏è Paused (blocking issues)"
              ;;
            failure)
              STATUS="‚ùå Failed"
              ;;
            skipped)
              SKIP_REASON="${{ needs.setup-and-plan.outputs.skip_reason }}"
              case "$SKIP_REASON" in
                already_executed) STATUS="‚è≠Ô∏è Skipped (already executed)" ;;
                deps_unmet) STATUS="üöß Blocked (unmet dependencies)" ;;
                *) STATUS="‚è≠Ô∏è Skipped ($SKIP_REASON)" ;;
              esac
              ;;
            *)
              STATUS="‚ö†Ô∏è $OUTCOME"
              ;;
          esac

          RUN_URL="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"

          BODY="## $STATUS

          **Plan:** \`$PLAN_FILENAME\`
          **Complexity:** ${{ needs.decompose.outputs.complexity }}
          **Time:** $(date -u +'%Y-%m-%d %H:%M:%S UTC')
          **Run:** [View Details]($RUN_URL)

          ---
          *Posted by [execute-stories workflow]($RUN_URL)*"

          echo "$BODY" | gh issue comment "$ISSUE_NUM" --body-file -
          echo "Posted to issue #$ISSUE_NUM"
