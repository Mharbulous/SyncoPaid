name: 4. Execute Story

# Run every 20 minutes for intensive story execution
on:
  schedule:
    - cron: '*/20 * * * *'
  workflow_dispatch:

concurrency:
  group: daily-story-execution
  cancel-in-progress: false

permissions:
  contents: write
  issues: write
  pull-requests: write
  id-token: write

jobs:
  execute-stories:
    runs-on: ubuntu-latest
    timeout-minutes: 60

    steps:
      - name: Checkout repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      # ============================================================
      # STEP 1: Plan Selection (Pure Python - No AI needed)
      # ============================================================
      - name: Select next plan
        id: select-plan
        run: |
          python3 << 'EOF'
          import os
          import re
          import json
          import sqlite3

          plans_dir = '.claude/data/plans'
          db_path = '.claude/data/story-tree.db'
          pattern = re.compile(r'^(\d{3})([A-Z])?_(.+)\.md$')

          # Find all plan files
          plans = []
          if os.path.isdir(plans_dir):
              for f in os.listdir(plans_dir):
                  if f.endswith('.md') and not os.path.isdir(os.path.join(plans_dir, f)):
                      m = pattern.match(f)
                      if m:
                          plans.append({
                              'filename': f,
                              'path': os.path.join(plans_dir, f),
                              'sequence': int(m.group(1)),
                              'letter': m.group(2) or '',
                          })

          # Sort by sequence, then letter
          plans.sort(key=lambda x: (x['sequence'], x['letter']))

          if not plans:
              print("No plan files found")
              with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                  f.write("has_plan=false\n")
              exit(0)

          selected = plans[0]
          plan_path = selected['path']

          # Read plan content
          with open(plan_path, 'r') as f:
              content = f.read()

          # Extract Story ID
          story_id_match = re.search(r'Story ID[:\s]*(\d+(?:\.\d+)*)', content)
          story_id = story_id_match.group(1) if story_id_match else None

          # Check if story exists and is ready for execution
          ready = True
          skip_reason = None

          if story_id and os.path.exists(db_path):
              conn = sqlite3.connect(db_path)

              # Check if already executed
              result = conn.execute('SELECT stage FROM story_nodes WHERE id = ?', (story_id,)).fetchone()
              if result:
                  stage = result[0]
                  if stage in ('reviewing', 'verifying', 'implemented', 'ready', 'polish', 'released'):
                      ready = False
                      skip_reason = f"already_executed:{stage}"

              conn.close()

          # Output results
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write(f"has_plan=true\n")
              f.write(f"plan_filename={selected['filename']}\n")
              f.write(f"plan_path={plan_path}\n")
              f.write(f"story_id={story_id or ''}\n")
              f.write(f"ready={str(ready).lower()}\n")
              f.write(f"skip_reason={skip_reason or ''}\n")

          print(f"Selected: {selected['filename']} (Story ID: {story_id}, Ready: {ready})")
          EOF

      - name: Handle already-executed plan
        if: steps.select-plan.outputs.has_plan == 'true' && steps.select-plan.outputs.ready == 'false'
        run: |
          PLAN_PATH="${{ steps.select-plan.outputs.plan_path }}"
          ARCHIVE_DIR=".claude/data/executed"
          mkdir -p "$ARCHIVE_DIR"
          mv "$PLAN_PATH" "$ARCHIVE_DIR/"
          echo "Archived already-executed plan: $PLAN_PATH"

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add -A
          git commit -m "ci: archive already-executed plan ${{ steps.select-plan.outputs.plan_filename }}"
          git push origin main

      # ============================================================
      # STEP 2: Execute Plan (Claude - Focused context)
      # ============================================================
      - name: Execute plan with Claude
        id: claude
        if: steps.select-plan.outputs.has_plan == 'true' && steps.select-plan.outputs.ready == 'true'
        uses: anthropics/claude-code-action@v1
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          show_full_output: true

          # FOCUSED prompt - just the plan execution, nothing else
          prompt: |
            Execute the implementation plan in: ${{ steps.select-plan.outputs.plan_path }}
            Story ID: ${{ steps.select-plan.outputs.story_id }}

            INSTRUCTIONS:
            1. Read the plan file above
            2. For each task in the plan:
               - Write failing test (RED)
               - Write minimal code to pass (GREEN)
               - Commit with message including Story ID
            3. Run the verification commands from the plan
            4. If all tests pass, the execution is complete

            CONSTRAINTS:
            - Follow plan steps exactly as written
            - Do NOT modify unrelated files
            - Do NOT run commands in background - wait for completion
            - If a test fails unexpectedly, stop and report the error

            AVAILABLE TOOLS NOTE:
            - Use BashOutput (not TaskOutput) to check background command output
            - Prefer running commands with explicit timeouts

          claude_args: |
            --allowedTools "Read,Write,Edit,Glob,Grep,Bash(git:*),Bash(python:*),Bash(python3:*),Bash(pytest:*),Bash(pip:*),BashOutput,TodoWrite"
            --model claude-sonnet-4-5-20250929
            --max-turns 50

      # ============================================================
      # STEP 3: Finalize (Pure bash - archive, update DB, commit)
      # ============================================================
      - name: Archive executed plan
        if: steps.claude.outcome == 'success' && steps.select-plan.outputs.has_plan == 'true'
        run: |
          PLAN_PATH="${{ steps.select-plan.outputs.plan_path }}"
          PLAN_FILENAME="${{ steps.select-plan.outputs.plan_filename }}"
          STORY_ID="${{ steps.select-plan.outputs.story_id }}"
          ARCHIVE_DIR=".claude/data/executed"

          # Only archive if plan still exists (wasn't already moved)
          if [ -f "$PLAN_PATH" ]; then
            mkdir -p "$ARCHIVE_DIR"
            mv "$PLAN_PATH" "$ARCHIVE_DIR/"
            echo "Archived: $PLAN_PATH -> $ARCHIVE_DIR/"
          fi

          # Update story status in database
          if [ -n "$STORY_ID" ] && [ -f ".claude/data/story-tree.db" ]; then
            python3 << EOF
          import sqlite3
          conn = sqlite3.connect('.claude/data/story-tree.db')
          conn.execute('''
              UPDATE story_nodes
              SET stage = 'verifying',
                  notes = COALESCE(notes || char(10), '') || 'CI execution complete: ' || datetime('now'),
                  updated_at = datetime('now')
              WHERE id = ?
          ''', ('$STORY_ID',))
          conn.commit()
          print(f"Updated story $STORY_ID to verifying stage")
          conn.close()
          EOF
          fi

      - name: Commit and push changes
        if: steps.select-plan.outputs.has_plan == 'true' && steps.select-plan.outputs.ready == 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git add -A

          # Check if there are changes to commit
          if git diff --cached --quiet; then
            echo "No changes to commit"
          else
            PLAN_FILENAME="${{ steps.select-plan.outputs.plan_filename }}"
            STORY_ID="${{ steps.select-plan.outputs.story_id }}"
            git commit -m "ci: execute plan ${PLAN_FILENAME}

          Story: ${STORY_ID}"

            # Push with retry
            for i in 1 2 3 4; do
              if git push origin main; then
                echo "Push successful"
                break
              else
                echo "Push failed, retry $i..."
                sleep $((2 ** i))
              fi
            done
          fi

      # ============================================================
      # STEP 4: Reporting (unchanged from original)
      # ============================================================
      - name: Report Token Usage
        if: always() && steps.claude.outcome != 'skipped'
        run: |
          echo "## Token Usage Report" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          EXEC_FILE="${{ steps.claude.outputs.execution_file }}"
          if [ -f "$EXEC_FILE" ]; then
            echo "::debug::Execution file size: $(wc -c < "$EXEC_FILE") bytes"

            if jq -e 'type == "array"' "$EXEC_FILE" > /dev/null 2>&1; then
              INPUT_TOKENS=$(jq '[.[] | select(.message?.usage?) | .message.usage.input_tokens // 0] | add // 0' "$EXEC_FILE")
              OUTPUT_TOKENS=$(jq '[.[] | select(.message?.usage?) | .message.usage.output_tokens // 0] | add // 0' "$EXEC_FILE")
              CACHE_CREATION=$(jq '[.[] | select(.message?.usage?) | .message.usage.cache_creation_input_tokens // 0] | add // 0' "$EXEC_FILE")
              CACHE_READ=$(jq '[.[] | select(.message?.usage?) | .message.usage.cache_read_input_tokens // 0] | add // 0' "$EXEC_FILE")
              TOTAL_COST=$(jq '[.[] | select(.type == "result")] | last | .total_cost_usd // .cost_usd // "N/A"' "$EXEC_FILE" | tr -d '"')
              DURATION_MS=$(jq '[.[] | select(.type == "result")] | last | .duration_ms // "N/A"' "$EXEC_FILE" | tr -d '"')
            else
              INPUT_TOKENS=$(grep -o '"input_tokens":[0-9]*' "$EXEC_FILE" | cut -d: -f2 | awk '{s+=$1} END {print s+0}')
              OUTPUT_TOKENS=$(grep -o '"output_tokens":[0-9]*' "$EXEC_FILE" | cut -d: -f2 | awk '{s+=$1} END {print s+0}')
              CACHE_CREATION=$(grep -o '"cache_creation_input_tokens":[0-9]*' "$EXEC_FILE" | cut -d: -f2 | awk '{s+=$1} END {print s+0}')
              CACHE_READ=$(grep -o '"cache_read_input_tokens":[0-9]*' "$EXEC_FILE" | cut -d: -f2 | awk '{s+=$1} END {print s+0}')
              RESULT=$(grep '"type":"result"' "$EXEC_FILE" | tail -1)
              if [ -n "$RESULT" ]; then
                TOTAL_COST=$(echo "$RESULT" | jq -r '.total_cost_usd // .cost_usd // "N/A"')
                DURATION_MS=$(echo "$RESULT" | jq -r '.duration_ms // "N/A"')
              else
                TOTAL_COST="N/A"
                DURATION_MS="N/A"
              fi
            fi

            if ! [[ "$INPUT_TOKENS" =~ ^[0-9]+$ ]]; then INPUT_TOKENS=0; fi
            if ! [[ "$OUTPUT_TOKENS" =~ ^[0-9]+$ ]]; then OUTPUT_TOKENS=0; fi
            if ! [[ "$CACHE_CREATION" =~ ^[0-9]+$ ]]; then CACHE_CREATION=0; fi
            if ! [[ "$CACHE_READ" =~ ^[0-9]+$ ]]; then CACHE_READ=0; fi

            if [ "$INPUT_TOKENS" -gt 0 ] || [ "$OUTPUT_TOKENS" -gt 0 ]; then
              TOTAL_TOKENS=$((INPUT_TOKENS + OUTPUT_TOKENS))
            else
              TOTAL_TOKENS="N/A"
            fi

            if [[ "$DURATION_MS" =~ ^[0-9]+$ ]]; then
              DURATION_S=$(echo "scale=1; $DURATION_MS / 1000" | bc)
            else
              DURATION_S="N/A"
            fi

            echo "| Metric | Value |" >> $GITHUB_STEP_SUMMARY
            echo "|--------|-------|" >> $GITHUB_STEP_SUMMARY
            echo "| Plan | ${{ steps.select-plan.outputs.plan_filename }} |" >> $GITHUB_STEP_SUMMARY
            echo "| Story ID | ${{ steps.select-plan.outputs.story_id }} |" >> $GITHUB_STEP_SUMMARY
            echo "| Input Tokens | $INPUT_TOKENS |" >> $GITHUB_STEP_SUMMARY
            echo "| Output Tokens | $OUTPUT_TOKENS |" >> $GITHUB_STEP_SUMMARY
            echo "| Cache Creation | $CACHE_CREATION |" >> $GITHUB_STEP_SUMMARY
            echo "| Cache Read | $CACHE_READ |" >> $GITHUB_STEP_SUMMARY
            echo "| **Total Tokens** | **$TOTAL_TOKENS** |" >> $GITHUB_STEP_SUMMARY
            echo "| Total Cost | \$$TOTAL_COST |" >> $GITHUB_STEP_SUMMARY
            echo "| Duration | ${DURATION_S}s |" >> $GITHUB_STEP_SUMMARY
          else
            echo "⚠️ Execution file not found" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Post Results to Story Issue
        if: always() && steps.select-plan.outputs.has_plan == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          STORY_ID="${{ steps.select-plan.outputs.story_id }}"
          PLAN_FILENAME="${{ steps.select-plan.outputs.plan_filename }}"

          if [ -z "$STORY_ID" ]; then
            echo "No Story ID, skipping issue update" >> $GITHUB_STEP_SUMMARY
            exit 0
          fi

          # Get story title from database
          STORY_TITLE=""
          if [ -f ".claude/data/story-tree.db" ]; then
            STORY_TITLE=$(python3 -c "import sqlite3; conn = sqlite3.connect('.claude/data/story-tree.db'); r = conn.execute('SELECT title FROM story_nodes WHERE id = ?', ('$STORY_ID',)).fetchone(); print(r[0] if r else '')" 2>/dev/null)
          fi

          if [ -z "$STORY_TITLE" ]; then
            STORY_TITLE="Story $STORY_ID"
          fi

          ISSUE_TITLE="${STORY_ID} - ${STORY_TITLE}"

          # Find or create issue
          ISSUE_NUMBER=$(gh issue list --state all --search "\"${ISSUE_TITLE}\" in:title" --json number,title --jq ".[] | select(.title == \"${ISSUE_TITLE}\") | .number" | head -1)

          if [ -z "$ISSUE_NUMBER" ]; then
            ISSUE_BODY="Tracking issue for story node **${STORY_ID}**"$'\n\n'"## Description"$'\n'"${STORY_TITLE}"
            ISSUE_NUMBER=$(gh issue create --title "$ISSUE_TITLE" --body "$ISSUE_BODY" --label "story-tracking" 2>/dev/null | grep -oP 'issues/\K[0-9]+' || echo "")
            if [ -z "$ISSUE_NUMBER" ]; then
              ISSUE_NUMBER=$(gh issue create --title "$ISSUE_TITLE" --body "$ISSUE_BODY" | grep -oP 'issues/\K[0-9]+' || echo "")
            fi
          fi

          if [ -z "$ISSUE_NUMBER" ]; then
            echo "Could not find or create issue" >> $GITHUB_STEP_SUMMARY
            exit 0
          fi

          # Determine status
          JOB_STATUS="${{ job.status }}"
          CLAUDE_STATUS="${{ steps.claude.outcome }}"

          if [ "$CLAUDE_STATUS" = "success" ]; then
            STATUS_EMOJI="✅"
            STATUS_TEXT="Success"
          elif [ "$CLAUDE_STATUS" = "skipped" ]; then
            STATUS_EMOJI="⏭️"
            STATUS_TEXT="Skipped"
          else
            STATUS_EMOJI="❌"
            STATUS_TEXT="Failed"
          fi

          RUN_URL="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          TIMESTAMP=$(date -u +"%Y-%m-%d %H:%M:%S UTC")

          COMMENT_BODY="## ${STATUS_EMOJI} Execution: ${STATUS_TEXT}"$'\n\n'
          COMMENT_BODY+="**Plan:** \`${PLAN_FILENAME}\`"$'\n'
          COMMENT_BODY+="**Time:** ${TIMESTAMP}"$'\n'
          COMMENT_BODY+="**Run:** [View Details](${RUN_URL})"$'\n\n'
          COMMENT_BODY+="---"$'\n'
          COMMENT_BODY+="*Posted by [execute-stories workflow](${RUN_URL})*"

          echo "$COMMENT_BODY" | gh issue comment "$ISSUE_NUMBER" --body-file -
          echo "Posted to issue #${ISSUE_NUMBER}" >> $GITHUB_STEP_SUMMARY
