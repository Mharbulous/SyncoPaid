name: 4. Execute Story

# Temporary 2-hour schedule: runs every 10 min for hours 20-22 UTC on Dec 22, 2025
on:
  schedule:
    - cron: '0,10,20,30,40,50 20-22 22 12 *'
  workflow_dispatch:

concurrency:
  group: daily-story-execution
  cancel-in-progress: false

permissions:
  contents: write
  issues: write
  pull-requests: write
  id-token: write

# ══════════════════════════════════════════════════════════════════════════════
# PIPELINE VISUALIZATION
# ══════════════════════════════════════════════════════════════════════════════
# This workflow uses 7 semantically meaningful stages:
#
#   setup-and-plan → validate-plan → verify-implementation → review-plan → decompose → execute → finalize
#
# Each stage has a clear purpose:
# - setup-and-plan: Find plan, validate deps, initialize state
# - validate-plan: Ensure plan has valid Story ID (match to database if missing)
# - verify-implementation: Check if plan already implemented (for reviewing/verifying stages)
# - review-plan: Critical review, decide proceed/pause/verified
# - decompose: Assess complexity, split if needed (Opus)
# - execute: Follow plan's TDD steps directly (Sonnet)
# - finalize: Archive, commit, report
#
# State is passed between jobs via:
# - Job outputs: simple strings (outcome, status, paths)
# - The plan document itself is the source of truth
# ══════════════════════════════════════════════════════════════════════════════

jobs:
  # ════════════════════════════════════════════════════════════════════════════
  # SETUP-AND-PLAN: Find plan, validate dependencies, initialize state
  # ════════════════════════════════════════════════════════════════════════════
  setup-and-plan:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      plan_selected: ${{ steps.select-plan.outputs.selected }}
      plan_path: ${{ steps.select-plan.outputs.path }}
      plan_filename: ${{ steps.select-plan.outputs.filename }}
      plan_sequence: ${{ steps.select-plan.outputs.sequence }}
      story_id: ${{ steps.extract-story.outputs.story_id }}
      should_execute: ${{ steps.determine.outputs.should_execute }}
      skip_reason: ${{ steps.determine.outputs.skip_reason }}
      needs_verification: ${{ steps.determine.outputs.needs_verification }}
      current_stage: ${{ steps.check-executed.outputs.current_stage }}

    steps:
      # ── PHASE 1: SETUP ──
      - name: "1.1 Checkout repository"
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      # ── PHASE 2: PLAN SELECTION ──
      - name: "2.1 Find available plans"
        id: find-plans
        run: |
          echo "## Plan Discovery" >> $GITHUB_STEP_SUMMARY

          PLANS_DIR=".claude/data/plans"
          if [ ! -d "$PLANS_DIR" ]; then
            echo "plans_found=0" >> $GITHUB_OUTPUT
            echo "❌ Plans directory not found: $PLANS_DIR" >> $GITHUB_STEP_SUMMARY
            exit 0
          fi

          PLAN_COUNT=$(find "$PLANS_DIR" -maxdepth 1 -name "*.md" -type f | wc -l)
          echo "plans_found=$PLAN_COUNT" >> $GITHUB_OUTPUT
          echo "Found **$PLAN_COUNT** plan files in $PLANS_DIR" >> $GITHUB_STEP_SUMMARY

          if [ "$PLAN_COUNT" -gt 0 ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| Plan File | Sequence |" >> $GITHUB_STEP_SUMMARY
            echo "|-----------|----------|" >> $GITHUB_STEP_SUMMARY
            for f in $(ls -1 "$PLANS_DIR"/*.md 2>/dev/null | head -10); do
              FNAME=$(basename "$f")
              # Match hierarchical: 024, 024A, 024A1, 024A1a, 024A1a1
              SEQ=$(echo "$FNAME" | grep -oP '^\d{3}([A-Z](\d+([a-z](\d+)?)?)?)?' || echo "?")
              echo "| $FNAME | $SEQ |" >> $GITHUB_STEP_SUMMARY
            done
          fi

      - name: "2.2 Select earliest plan"
        id: select-plan
        if: steps.find-plans.outputs.plans_found != '0'
        run: |
          python3 << 'PYEOF'
          import os, re

          plans_dir = '.claude/data/plans'
          # Match hierarchical naming: 024, 024A, 024A1, 024A1a, 024A1a1, etc.
          pattern = re.compile(r'^(\d{3})([A-Z])?(\d+)?([a-z])?(\d+)?_(.+)\.md$')

          def parse_hierarchy(filename):
              """Parse hierarchical prefix into sortable tuple."""
              m = pattern.match(filename)
              if not m:
                  return None
              # Extract components: (seq, letter, num1, lower, num2)
              seq = int(m.group(1))
              letter = m.group(2) or ''      # A, B, C or ''
              num1 = int(m.group(3)) if m.group(3) else 0   # 1, 2, 3 or 0
              lower = m.group(4) or ''       # a, b, c or ''
              num2 = int(m.group(5)) if m.group(5) else 0   # 1, 2, 3 or 0
              # Build prefix string for output
              prefix = str(seq) + letter + (str(num1) if num1 else '') + lower + (str(num2) if num2 else '')
              return {
                  'sort_key': (seq, letter, num1, lower, num2),
                  'prefix': prefix
              }

          plans = []
          for f in os.listdir(plans_dir):
              path = os.path.join(plans_dir, f)
              if os.path.isfile(path) and f.endswith('.md'):
                  parsed = parse_hierarchy(f)
                  if parsed:
                      plans.append({
                          'filename': f,
                          'path': path,
                          'sort_key': parsed['sort_key'],
                          'prefix': parsed['prefix'],
                      })

          # Sort by hierarchical key: (seq, letter, num1, lower, num2)
          # Empty strings sort before letters, 0 sorts before numbers
          plans.sort(key=lambda x: x['sort_key'])

          if plans:
              selected = plans[0]
              with open(os.environ['GITHUB_OUTPUT'], 'a') as out:
                  out.write(f"selected=true\n")
                  out.write(f"filename={selected['filename']}\n")
                  out.write(f"path={selected['path']}\n")
                  out.write(f"sequence={selected['prefix']}\n")
              print(f"Selected: {selected['filename']}")
          else:
              with open(os.environ['GITHUB_OUTPUT'], 'a') as out:
                  out.write("selected=false\n")
              print("No valid plan files found")
          PYEOF

      - name: "2.3 Extract Story ID from plan"
        id: extract-story
        if: steps.select-plan.outputs.selected == 'true'
        run: |
          PLAN_PATH="${{ steps.select-plan.outputs.path }}"

          STORY_ID=$(grep -oP 'Story ID[:\s]*\K\d+(\.\d+)*' "$PLAN_PATH" | head -1)

          if [ -z "$STORY_ID" ]; then
            STORY_ID=$(grep -oP '\*\*Story ID:\*\*\s*\K\d+(\.\d+)*' "$PLAN_PATH" | head -1)
          fi

          echo "story_id=${STORY_ID:-none}" >> $GITHUB_OUTPUT
          echo "Story ID: ${STORY_ID:-'(not found)'}"

      # ── PHASE 3: VALIDATION ──
      - name: "3.1 Check if story already executed"
        id: check-executed
        if: steps.select-plan.outputs.selected == 'true' && steps.extract-story.outputs.story_id != 'none'
        run: |
          STORY_ID="${{ steps.extract-story.outputs.story_id }}"
          DB_PATH=".claude/data/story-tree.db"

          if [ ! -f "$DB_PATH" ]; then
            echo "already_executed=false" >> $GITHUB_OUTPUT
            echo "Database not found, assuming not executed"
            exit 0
          fi

          STAGE=$(python3 -c "
          import sqlite3
          conn = sqlite3.connect('$DB_PATH')
          r = conn.execute('SELECT stage FROM story_nodes WHERE id = ?', ('$STORY_ID',)).fetchone()
          print(r[0] if r else 'unknown')
          conn.close()
          ")

          echo "Current stage: $STAGE"

          case "$STAGE" in
            reviewing|verifying|implemented|ready|polish|released)
              echo "already_executed=true" >> $GITHUB_OUTPUT
              echo "current_stage=$STAGE" >> $GITHUB_OUTPUT
              echo "⚠️ Story $STORY_ID already at stage: $STAGE"
              ;;
            *)
              echo "already_executed=false" >> $GITHUB_OUTPUT
              echo "current_stage=$STAGE" >> $GITHUB_OUTPUT
              echo "✓ Story $STORY_ID ready for execution (stage: $STAGE)"
              ;;
          esac

      - name: "3.2 Check story dependencies"
        id: check-deps
        if: steps.select-plan.outputs.selected == 'true' && steps.check-executed.outputs.already_executed != 'true'
        run: |
          STORY_ID="${{ steps.extract-story.outputs.story_id }}"
          PLAN_PATH="${{ steps.select-plan.outputs.path }}"
          DB_PATH=".claude/data/story-tree.db"

          if [ "$STORY_ID" = "none" ] || [ ! -f "$DB_PATH" ]; then
            echo "deps_met=true" >> $GITHUB_OUTPUT
            echo "No Story ID or database, skipping dependency check"
            exit 0
          fi

          python3 << PYEOF
          import sqlite3, re, os

          story_id = "$STORY_ID"
          db_path = "$DB_PATH"
          plan_path = "$PLAN_PATH"

          conn = sqlite3.connect(db_path)

          result = conn.execute('SELECT description, notes FROM story_nodes WHERE id = ?', (story_id,)).fetchone()
          if not result:
              with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                  f.write("deps_met=true\n")
              print("Story not in database, proceeding")
              exit(0)

          text = (result[0] or '') + ' ' + (result[1] or '')

          with open(plan_path, 'r') as f:
              text += ' ' + f.read()

          dep_pattern = r'(?:depends on|requires|after|blocked by)\s+(\d+(?:\.\d+)*)'
          deps = set(re.findall(dep_pattern, text, re.IGNORECASE))
          deps.discard(story_id)

          if not deps:
              with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                  f.write("deps_met=true\n")
              print("No dependencies found")
              exit(0)

          IMPLEMENTED = ('implemented', 'ready', 'polish', 'released')
          unmet = []
          for dep_id in deps:
              r = conn.execute('SELECT stage FROM story_nodes WHERE id = ? AND disposition IS NULL', (dep_id,)).fetchone()
              if r and r[0] not in IMPLEMENTED:
                  unmet.append(f"{dep_id} ({r[0]})")

          conn.close()

          if unmet:
              with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                  f.write("deps_met=false\n")
                  f.write(f"unmet_deps={', '.join(unmet)}\n")
              print(f"❌ Unmet dependencies: {', '.join(unmet)}")
          else:
              with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                  f.write("deps_met=true\n")
              print("✓ All dependencies met")
          PYEOF

      # ── PHASE 4: HANDLE SKIP CONDITIONS ──
      - name: "4.1 Move blocked plan to blocked folder"
        if: steps.check-deps.outputs.deps_met == 'false'
        run: |
          PLAN_PATH="${{ steps.select-plan.outputs.path }}"
          FILENAME="${{ steps.select-plan.outputs.filename }}"
          BLOCKED_DIR=".claude/data/plans/blocked"
          UNMET="${{ steps.check-deps.outputs.unmet_deps }}"

          # Pull latest changes before making any modifications
          git fetch origin main
          git rebase origin/main || git rebase --abort

          mkdir -p "$BLOCKED_DIR"
          mv "$PLAN_PATH" "$BLOCKED_DIR/"
          echo "Moved blocked plan: $FILENAME → $BLOCKED_DIR/"
          echo "Unmet dependencies: $UNMET"

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add -A
          git commit -m "ci: move blocked plan $FILENAME (deps: $UNMET)"

          # Retry push with exponential backoff and pull before retry
          for attempt in 1 2 3 4; do
            if git push origin main; then
              echo "✓ Push successful"
              exit 0
            else
              echo "Push failed (attempt $attempt), pulling and retrying..."
              git pull --rebase origin main || true
              sleep $((2 ** attempt))
            fi
          done
          echo "❌ Push failed after 4 attempts"
          exit 1

      # ── DETERMINE IF EXECUTION SHOULD PROCEED ──
      - name: "4.2 Determine execution eligibility"
        id: determine
        run: |
          SELECTED="${{ steps.select-plan.outputs.selected }}"
          ALREADY_EXECUTED="${{ steps.check-executed.outputs.already_executed }}"
          CURRENT_STAGE="${{ steps.check-executed.outputs.current_stage }}"
          DEPS_MET="${{ steps.check-deps.outputs.deps_met }}"

          if [ "$SELECTED" != "true" ]; then
            echo "should_execute=false" >> $GITHUB_OUTPUT
            echo "skip_reason=no_plans" >> $GITHUB_OUTPUT
            echo "needs_verification=false" >> $GITHUB_OUTPUT
          elif [ "$ALREADY_EXECUTED" = "true" ]; then
            # Story is in reviewing/verifying/implemented stage but plan file still exists
            # This needs verification to check if implementation actually exists
            echo "should_execute=false" >> $GITHUB_OUTPUT
            echo "skip_reason=needs_verification" >> $GITHUB_OUTPUT
            echo "needs_verification=true" >> $GITHUB_OUTPUT
            echo "⚠️ Plan exists but story at stage '$CURRENT_STAGE' - needs verification"
          elif [ "$DEPS_MET" = "false" ]; then
            echo "should_execute=false" >> $GITHUB_OUTPUT
            echo "skip_reason=deps_unmet" >> $GITHUB_OUTPUT
            echo "needs_verification=false" >> $GITHUB_OUTPUT
          else
            echo "should_execute=true" >> $GITHUB_OUTPUT
            echo "skip_reason=" >> $GITHUB_OUTPUT
            echo "needs_verification=false" >> $GITHUB_OUTPUT
          fi

  # ════════════════════════════════════════════════════════════════════════════
  # VALIDATE-PLAN: Ensure plan has valid Story ID (match to database if missing)
  # ════════════════════════════════════════════════════════════════════════════
  validate-plan:
    needs: setup-and-plan
    if: needs.setup-and-plan.outputs.plan_selected == 'true' && needs.setup-and-plan.outputs.story_id == 'none'
    runs-on: ubuntu-latest
    timeout-minutes: 15
    outputs:
      story_id: ${{ steps.validate-output.outputs.story_id }}
      validation_passed: ${{ steps.validate-output.outputs.validation_passed }}
      plan_blocked: ${{ steps.validate-output.outputs.plan_blocked }}

    steps:
      - name: "VP.1 Checkout repository"
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: "VP.1.5 Extract database schema"
        id: schema
        run: |
          DB_PATH=".claude/data/story-tree.db"
          if [ -f "$DB_PATH" ]; then
            # Extract schema and sample data for Claude
            SCHEMA=$(sqlite3 "$DB_PATH" ".schema story_nodes" 2>/dev/null | head -40)
            SAMPLE=$(sqlite3 "$DB_PATH" "SELECT id, title, substr(description, 1, 100) FROM story_nodes WHERE disposition IS NULL LIMIT 3" 2>/dev/null)

            # Write to temp file for Claude to read
            echo "$SCHEMA" > /tmp/db_schema.txt
            echo "" >> /tmp/db_schema.txt
            echo "Sample rows (id|title|description_excerpt):" >> /tmp/db_schema.txt
            echo "$SAMPLE" >> /tmp/db_schema.txt

            echo "schema_available=true" >> $GITHUB_OUTPUT
          else
            echo "schema_available=false" >> $GITHUB_OUTPUT
          fi

      - name: "VP.2 Match plan to story in database"
        id: validate
        uses: anthropics/claude-code-action@v1
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          show_full_output: true
          prompt: |
            You are validating a plan document to ensure it has a valid Story ID.

            Plan: ${{ needs.setup-and-plan.outputs.plan_path }}
            Plan filename: ${{ needs.setup-and-plan.outputs.plan_filename }}

            ## CONTEXT

            This plan document does not contain a Story ID. Your task is to find the matching
            story in the database by comparing the plan's content to story nodes.

            ## YOUR TASK

            1. Read the plan document completely
            2. Extract key information:
               - Title/description of what the plan implements
               - Key features or functionality
               - Any mentioned story references
            3. Query the database at `.claude/data/story-tree.db` to find matching stories:
               - Compare plan content to story descriptions
               - Compare to story field (user story text)
               - Compare to success_criteria field
               - Look for similar keywords and concepts
            4. If a confident match is found (>80% confidence), update the plan
            5. If no match found, the plan should be blocked

            ## DATABASE SCHEMA

            The story_nodes table has these columns:
            - id: TEXT PRIMARY KEY (e.g., "7.6", "8.1.2")
            - title: TEXT NOT NULL
            - description: TEXT NOT NULL
            - story: TEXT (user story text: "As a... I want... So that...")
            - success_criteria: TEXT (acceptance criteria)
            - stage: TEXT (concept, approved, planned, active, reviewing, verifying, implemented, ready, polish, released)
            - hold_reason: TEXT (NULL if not held)
            - disposition: TEXT (NULL if active in pipeline)

            ## SQL QUERY EXAMPLES

            IMPORTANT: Do NOT use heredocs (<<EOF) for Python - they are blocked by security policy.
            Instead, write Python code to a .py file and execute it:

            ```python
            # Write this to a file like /tmp/query.py, then run: python3 /tmp/query.py
            import sqlite3
            conn = sqlite3.connect('.claude/data/story-tree.db')
            results = conn.execute('''
                SELECT id, title, description, story, success_criteria
                FROM story_nodes
                WHERE disposition IS NULL
                  AND (title LIKE ? OR description LIKE ? OR story LIKE ?)
            ''', ('%keyword%', '%keyword%', '%keyword%')).fetchall()
            for row in results:
                print(row)
            ```

            Or use sqlite3 CLI directly (simpler for quick queries):
            ```bash
            sqlite3 .claude/data/story-tree.db "SELECT id, title FROM story_nodes WHERE stage <> 'concept' AND disposition IS NULL"
            ```

            ## HOW TO UPDATE THE PLAN

            If you find a matching story, add a Story ID line in the plan's header section.
            Look for a metadata section near the top (often after the title) and add:

            ```markdown
            **Story ID:** 7.6
            ```

            Or if there's already a metadata table, add a row for Story ID.

            ## OUTPUT REQUIRED

            Write a JSON file to `.claude/skills/story-execution/ci-validate-result.json`:

            ```json
            {
              "validation_passed": true|false,
              "story_id": "7.6" or null,
              "confidence": 0.85,
              "match_reason": "Brief explanation of why this story matches",
              "plan_updated": true|false,
              "block_reason": null or "No matching story found in database"
            }
            ```

            IMPORTANT:
            - Only update the plan file if you find a confident match (>80%)
            - If you update the plan, set plan_updated=true
            - If no match found, set validation_passed=false and provide block_reason

          claude_args: |
            --allowedTools "Read,Write,Edit,Glob,Grep,Bash(python:*),Bash(python3:*),Bash(sqlite3:*)"
            --model claude-sonnet-4-5-20250929
            --max-turns 20

      - name: "VP.3 Read validation output"
        id: validate-output
        if: always()
        run: |
          RESULT_FILE=".claude/skills/story-execution/ci-validate-result.json"

          if [ -f "$RESULT_FILE" ]; then
            PASSED=$(python3 -c "import json; d=json.load(open('$RESULT_FILE')); print(str(d.get('validation_passed', False)).lower())")
            STORY_ID=$(python3 -c "import json; d=json.load(open('$RESULT_FILE')); print(d.get('story_id') or 'none')")
            PLAN_UPDATED=$(python3 -c "import json; d=json.load(open('$RESULT_FILE')); print(str(d.get('plan_updated', False)).lower())")

            echo "validation_passed=$PASSED" >> $GITHUB_OUTPUT
            echo "story_id=$STORY_ID" >> $GITHUB_OUTPUT

            if [ "$PASSED" = "true" ]; then
              echo "plan_blocked=false" >> $GITHUB_OUTPUT
              echo "✓ Validation passed - Story ID: $STORY_ID"
            else
              echo "plan_blocked=true" >> $GITHUB_OUTPUT
              echo "⚠️ Validation failed - plan will be blocked"
            fi

            echo "## Plan Validation" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| Field | Value |" >> $GITHUB_STEP_SUMMARY
            echo "|-------|-------|" >> $GITHUB_STEP_SUMMARY
            echo "| Passed | $PASSED |" >> $GITHUB_STEP_SUMMARY
            echo "| Story ID | $STORY_ID |" >> $GITHUB_STEP_SUMMARY
            echo "| Plan Updated | $PLAN_UPDATED |" >> $GITHUB_STEP_SUMMARY
          else
            echo "validation_passed=false" >> $GITHUB_OUTPUT
            echo "story_id=none" >> $GITHUB_OUTPUT
            echo "plan_blocked=true" >> $GITHUB_OUTPUT
            echo "⚠️ Validation result file not found"
          fi

      - name: "VP.4 Commit plan update if Story ID was added"
        if: steps.validate-output.outputs.validation_passed == 'true'
        run: |
          # Pull latest changes before making any modifications
          git fetch origin main
          git rebase origin/main || git rebase --abort

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add -A

          if ! git diff --cached --quiet; then
            PLAN_FILENAME="${{ needs.setup-and-plan.outputs.plan_filename }}"
            STORY_ID="${{ steps.validate-output.outputs.story_id }}"

            git commit -m "ci: add Story ID $STORY_ID to plan $PLAN_FILENAME

            Matched plan to story via content analysis"

            # Retry push with exponential backoff
            for attempt in 1 2 3 4; do
              if git push origin main; then
                echo "✓ Pushed plan update with Story ID"
                exit 0
              else
                echo "Push failed (attempt $attempt), pulling and retrying..."
                git pull --rebase origin main || true
                sleep $((2 ** attempt))
              fi
            done
            echo "❌ Push failed after 4 attempts"
            exit 1
          else
            echo "No changes to commit (Story ID may have already been present)"
          fi

      - name: "VP.5 Move blocked plan if no Story ID found"
        if: steps.validate-output.outputs.plan_blocked == 'true'
        run: |
          PLAN_PATH="${{ needs.setup-and-plan.outputs.plan_path }}"
          FILENAME="${{ needs.setup-and-plan.outputs.plan_filename }}"
          BLOCKED_DIR=".claude/data/plans/blocked"

          # Pull latest changes before making any modifications
          git fetch origin main
          git rebase origin/main || git rebase --abort

          mkdir -p "$BLOCKED_DIR"
          mv "$PLAN_PATH" "$BLOCKED_DIR/"
          echo "Moved plan without Story ID: $FILENAME → $BLOCKED_DIR/"

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add -A
          git commit -m "ci: block plan $FILENAME (no matching Story ID found)

          Plan moved to blocked folder - requires manual Story ID assignment"

          # Retry push with exponential backoff
          for attempt in 1 2 3 4; do
            if git push origin main; then
              echo "✓ Push successful"
              exit 0
            else
              echo "Push failed (attempt $attempt), pulling and retrying..."
              git pull --rebase origin main || true
              sleep $((2 ** attempt))
            fi
          done
          echo "❌ Push failed after 4 attempts"
          exit 1

      - name: "VP.6 Upload validation result"
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: validate-result
          path: .claude/skills/story-execution/ci-validate-result.json
          retention-days: 1
          if-no-files-found: ignore

  # ════════════════════════════════════════════════════════════════════════════
  # VERIFY-IMPLEMENTATION: Check if plan was actually implemented in codebase
  # ════════════════════════════════════════════════════════════════════════════
  verify-implementation:
    needs: [setup-and-plan, validate-plan]
    if: |
      always() &&
      needs.setup-and-plan.outputs.needs_verification == 'true' &&
      needs.validate-plan.outputs.plan_blocked != 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 15
    outputs:
      verification_passed: ${{ steps.verify-output.outputs.verification_passed }}
      should_proceed_to_execute: ${{ steps.verify-output.outputs.should_proceed_to_execute }}
      verification_incomplete: ${{ steps.verify-output.outputs.verification_incomplete }}

    steps:
      - name: "V.1 Checkout repository"
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: "V.1.1 Clean up Claude installation locks"
        run: |
          rm -rf /tmp/claude-* 2>/dev/null || true
          rm -rf ~/.claude-install* 2>/dev/null || true
          rm -rf ~/.npm/_locks/* 2>/dev/null || true
          pkill -f "claude" 2>/dev/null || true
          echo "✓ Cleaned up potential installation locks"

      - name: "V.2 Verify implementation exists"
        id: verify
        uses: anthropics/claude-code-action@v1
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          show_full_output: true
          prompt: |
            You are verifying whether a plan has actually been implemented in the codebase.

            Plan: ${{ needs.setup-and-plan.outputs.plan_path }}
            Story ID: ${{ needs.setup-and-plan.outputs.story_id }}
            Current Stage: ${{ needs.setup-and-plan.outputs.current_stage }}

            ## CONTEXT

            The database indicates this story is at stage "${{ needs.setup-and-plan.outputs.current_stage }}"
            (reviewing/verifying/implemented), but the plan document still exists in the plans folder.
            This could mean:
            1. The implementation was completed but the plan wasn't archived (verification should PASS)
            2. The database was updated prematurely and implementation doesn't exist (verification should FAIL)

            ## YOUR TASK

            1. Read the plan document completely
            2. Identify the TOP 3-5 KEY deliverables (focus on new files and critical functions)
            3. Use parallel Glob/Grep calls to quickly verify if they exist
            4. Check only the MOST IMPORTANT deliverables - don't exhaustively check everything
            5. Write the result file IMMEDIATELY once you have enough evidence

            ## EFFICIENCY GUIDELINES

            - Use Glob to check for file existence in parallel (multiple calls at once)
            - Use Grep to quickly verify key functions/classes exist
            - Stop searching once you have clear evidence (3-5 checks is usually enough)
            - Prioritize: new files > new functions > config changes > minor modifications
            - If core files exist with key functions, that's sufficient for PASS

            ## VERIFICATION CRITERIA

            - **PASS**: Core deliverables exist (main files + key functions)
            - **PARTIAL**: Some core files exist but key parts are missing
            - **FAIL**: Core deliverables are completely missing

            ## CRITICAL: WRITE OUTPUT EARLY

            Write the JSON file to `.claude/skills/story-execution/ci-verify-result.json` AS SOON AS you have enough evidence.
            Don't wait until you've checked everything - prioritize writing the result:

            ```json
            {
              "verification_passed": true|false,
              "status": "pass|partial|fail",
              "deliverables_checked": [
                {"item": "description", "found": true|false, "location": "path or null"}
              ],
              "summary": "Brief explanation of findings",
              "recommendation": "archive|execute|manual_review"
            }
            ```

            Where recommendation is:
            - "archive": Implementation exists, safe to archive the plan
            - "execute": Implementation missing, plan should be executed
            - "manual_review": Partial implementation, needs human review

          claude_args: |
            --allowedTools "Read,Glob,Grep,Bash(python:*),Bash(python3:*),Write"
            --model claude-sonnet-4-5-20250929
            --max-turns 30

      - name: "V.3 Read verification output"
        id: verify-output
        if: always()
        run: |
          RESULT_FILE=".claude/skills/story-execution/ci-verify-result.json"

          if [ -f "$RESULT_FILE" ]; then
            PASSED=$(python3 -c "import json; d=json.load(open('$RESULT_FILE')); print(str(d.get('verification_passed', False)).lower())")
            STATUS=$(python3 -c "import json; d=json.load(open('$RESULT_FILE')); print(d.get('status', 'unknown'))")
            RECOMMENDATION=$(python3 -c "import json; d=json.load(open('$RESULT_FILE')); print(d.get('recommendation', 'manual_review'))")

            echo "verification_passed=$PASSED" >> $GITHUB_OUTPUT

            # Determine if we should proceed to execute
            if [ "$RECOMMENDATION" = "execute" ]; then
              echo "should_proceed_to_execute=true" >> $GITHUB_OUTPUT
            else
              echo "should_proceed_to_execute=false" >> $GITHUB_OUTPUT
            fi

            echo "## Implementation Verification" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| Field | Value |" >> $GITHUB_STEP_SUMMARY
            echo "|-------|-------|" >> $GITHUB_STEP_SUMMARY
            echo "| Status | $STATUS |" >> $GITHUB_STEP_SUMMARY
            echo "| Passed | $PASSED |" >> $GITHUB_STEP_SUMMARY
            echo "| Recommendation | $RECOMMENDATION |" >> $GITHUB_STEP_SUMMARY
          else
            # Result file not found - likely hit max-turns limit
            # Default to manual_review to avoid re-executing already-implemented plans
            echo "verification_passed=false" >> $GITHUB_OUTPUT
            echo "should_proceed_to_execute=false" >> $GITHUB_OUTPUT
            echo "verification_incomplete=true" >> $GITHUB_OUTPUT
            echo "⚠️ Verification result file not found (likely max-turns exceeded)"
            echo "## ⚠️ Verification Incomplete" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "The verification agent did not complete within the turn limit." >> $GITHUB_STEP_SUMMARY
            echo "Manual review required to determine if implementation exists." >> $GITHUB_STEP_SUMMARY
          fi

      - name: "V.4 Archive plan if verification passed"
        if: steps.verify-output.outputs.verification_passed == 'true'
        run: |
          PLAN_PATH="${{ needs.setup-and-plan.outputs.plan_path }}"
          FILENAME="${{ needs.setup-and-plan.outputs.plan_filename }}"
          ARCHIVE_DIR=".claude/data/plans/executed"

          # Pull latest changes before making any modifications
          git fetch origin main
          git rebase origin/main || git rebase --abort

          mkdir -p "$ARCHIVE_DIR"
          mv "$PLAN_PATH" "$ARCHIVE_DIR/"
          echo "✓ Verified implementation exists - archived plan: $FILENAME → $ARCHIVE_DIR/"

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add -A
          git commit -m "ci: archive verified plan $FILENAME

          Story: ${{ needs.setup-and-plan.outputs.story_id }}
          Verification: Implementation confirmed in codebase"

          # Retry push with exponential backoff
          for attempt in 1 2 3 4; do
            if git push origin main; then
              echo "✓ Push successful"
              exit 0
            else
              echo "Push failed (attempt $attempt), pulling and retrying..."
              git pull --rebase origin main || true
              sleep $((2 ** attempt))
            fi
          done
          echo "❌ Push failed after 4 attempts"
          exit 1

      - name: "V.5 Reset story stage if verification failed"
        if: steps.verify-output.outputs.should_proceed_to_execute == 'true'
        run: |
          STORY_ID="${{ needs.setup-and-plan.outputs.story_id }}"
          DB_PATH=".claude/data/story-tree.db"

          if [ ! -f "$DB_PATH" ] || [ "$STORY_ID" = "none" ]; then
            echo "No database or story ID, skipping stage reset"
            exit 0
          fi

          # Pull latest changes before making any modifications
          git fetch origin main
          git rebase origin/main || git rebase --abort

          echo "⚠️ Implementation not found - resetting story stage for re-execution"

          python3 << PYEOF
          import sqlite3
          conn = sqlite3.connect("$DB_PATH")
          conn.execute('''
              UPDATE story_nodes
              SET stage = 'planned',
                  notes = COALESCE(notes || char(10), '') || 'CI verification failed - implementation not found, reset for re-execution: ' || datetime('now'),
                  updated_at = datetime('now')
              WHERE id = ?
          ''', ("$STORY_ID",))
          conn.commit()
          print(f"✓ Reset story $STORY_ID to 'planned' stage")
          conn.close()
          PYEOF

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add -A

          if ! git diff --cached --quiet; then
            git commit -m "ci: reset story $STORY_ID for re-execution

          Verification found implementation missing despite stage being '${{ needs.setup-and-plan.outputs.current_stage }}'"

            # Retry push with exponential backoff
            for attempt in 1 2 3 4; do
              if git push origin main; then
                echo "✓ Push successful"
                exit 0
              else
                echo "Push failed (attempt $attempt), pulling and retrying..."
                git pull --rebase origin main || true
                sleep $((2 ** attempt))
              fi
            done
            echo "❌ Push failed after 4 attempts"
            exit 1
          fi

      - name: "V.6 Upload verification result"
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: verify-result
          path: .claude/skills/story-execution/ci-verify-result.json
          retention-days: 1
          if-no-files-found: ignore

  # ════════════════════════════════════════════════════════════════════════════
  # REVIEW-PLAN: Critical review - validate plan is actionable
  # ════════════════════════════════════════════════════════════════════════════
  review-plan:
    needs: [setup-and-plan, validate-plan, verify-implementation]
    if: |
      always() &&
      needs.validate-plan.outputs.plan_blocked != 'true' &&
      (needs.setup-and-plan.outputs.should_execute == 'true' ||
       needs.verify-implementation.outputs.should_proceed_to_execute == 'true')
    runs-on: ubuntu-latest
    timeout-minutes: 15
    outputs:
      outcome: ${{ steps.review-output.outputs.outcome }}
      review_completed: ${{ steps.review-output.outputs.review_completed }}

    steps:
      - name: "1.0 Checkout repository"
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: "1.0.1 Pull latest changes"
        run: |
          git pull origin main --rebase || true

      - name: "1.0.2 Clean up Claude installation locks"
        run: |
          # Remove any stale installation lock files that may cause conflicts
          rm -rf /tmp/claude-* 2>/dev/null || true
          rm -rf ~/.claude-install* 2>/dev/null || true
          rm -rf ~/.npm/_locks/* 2>/dev/null || true
          # Kill any orphaned Claude processes
          pkill -f "claude" 2>/dev/null || true
          echo "✓ Cleaned up potential installation locks"

      - name: "1.1 Review plan critically"
        id: review
        uses: anthropics/claude-code-action@v1
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          show_full_output: true
          prompt: |
            You are reviewing a plan document for CI execution.

            Plan: ${{ needs.setup-and-plan.outputs.plan_path }}
            Story ID: ${{ needs.validate-plan.outputs.story_id || needs.setup-and-plan.outputs.story_id }}

            ## YOUR TASK

            1. Read the plan file completely
            2. Quick check: Does the plan's KEY deliverable already exist? (1-2 targeted searches max)
            3. Make a decision and WRITE THE OUTPUT FILE IMMEDIATELY
            4. Only do deeper analysis if initial check is inconclusive

            ## EFFICIENCY RULES (CRITICAL)

            - Use Glob/Grep in PARALLEL for speed
            - Stop searching once you have enough evidence (2-3 files is usually enough)
            - WRITE THE OUTPUT FILE AS SOON AS you have a decision
            - Don't exhaustively verify every detail - focus on KEY deliverables

            ## OUTCOME CLASSIFICATION

            ### Already Implemented → outcome: "verified"
            - Core files/functions from the plan already exist
            - Test files already exist with passing tests

            ### Blocking Issues → outcome: "pause"
            - Security implications, breaking changes, missing critical info
            - Dependencies not implemented

            ### Minor Issues → outcome: "proceed_with_review"
            - Style issues, minor gaps (document and proceed)

            ### Ready to Execute → outcome: "proceed"
            - Plan is clear, work has NOT been done yet

            ## OUTPUT (WRITE THIS EARLY!)

            Write to `.claude/skills/story-execution/ci-review-result.json`:

            ```json
            {
              "outcome": "proceed|pause|proceed_with_review|verified",
              "blocking_issues": [],
              "deferrable_issues": [],
              "notes": "Brief summary"
            }
            ```

          claude_args: |
            --allowedTools "Read,Write,Edit,Glob,Grep,Bash(python:*),Bash(python3:*),Bash(mkdir:*)"
            --model claude-sonnet-4-5-20250929
            --max-turns 25

      - name: "1.2 Read review output"
        id: review-output
        if: always()
        run: |
          RESULT_FILE=".claude/skills/story-execution/ci-review-result.json"
          if [ -f "$RESULT_FILE" ]; then
            OUTCOME=$(python3 -c "import json; d=json.load(open('$RESULT_FILE')); print(d.get('outcome','unknown'))")
            if [ "$OUTCOME" = "proceed" ] || [ "$OUTCOME" = "proceed_with_review" ] || [ "$OUTCOME" = "pause" ] || [ "$OUTCOME" = "verified" ]; then
              echo "outcome=$OUTCOME" >> $GITHUB_OUTPUT
              echo "review_completed=true" >> $GITHUB_OUTPUT
              echo "Review outcome: $OUTCOME"
            else
              echo "outcome=failed" >> $GITHUB_OUTPUT
              echo "review_completed=false" >> $GITHUB_OUTPUT
              echo "Review not completed - outcome: $OUTCOME"
            fi
          else
            echo "outcome=failed" >> $GITHUB_OUTPUT
            echo "review_completed=false" >> $GITHUB_OUTPUT
            echo "Result file not found"
          fi

      - name: "1.3 Upload review result"
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: review-result
          path: .claude/skills/story-execution/ci-review-result.json
          retention-days: 1
          if-no-files-found: ignore

  # ════════════════════════════════════════════════════════════════════════════
  # DECOMPOSE: Assess complexity, split into sub-plans if needed (Opus)
  # ════════════════════════════════════════════════════════════════════════════
  decompose:
    needs: [setup-and-plan, validate-plan, verify-implementation, review-plan]
    if: |
      always() &&
      needs.review-plan.outputs.review_completed == 'true' &&
      (needs.review-plan.outputs.outcome == 'proceed' || needs.review-plan.outputs.outcome == 'proceed_with_review')
    runs-on: ubuntu-latest
    timeout-minutes: 20
    outputs:
      complexity: ${{ steps.decompose-output.outputs.complexity }}
      execute_plan: ${{ steps.decompose-output.outputs.execute_plan }}
      sub_plans_created: ${{ steps.decompose-output.outputs.sub_plans_created }}

    steps:
      - name: "2.0 Checkout repository"
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: "2.0.1 Clean up Claude installation locks"
        run: |
          rm -rf /tmp/claude-* 2>/dev/null || true
          rm -rf ~/.claude-install* 2>/dev/null || true
          rm -rf ~/.npm/_locks/* 2>/dev/null || true
          pkill -f "claude" 2>/dev/null || true
          echo "✓ Cleaned up potential installation locks"

      - name: "2.1 Assess plan complexity"
        id: decompose
        uses: anthropics/claude-code-action@v1
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          show_full_output: true
          prompt: |
            You are assessing plan complexity and potentially decomposing it into sub-plans.

            Plan: ${{ needs.setup-and-plan.outputs.plan_path }}
            Story ID: ${{ needs.validate-plan.outputs.story_id || needs.setup-and-plan.outputs.story_id }}
            Plan filename: ${{ needs.setup-and-plan.outputs.plan_filename }}

            ## YOUR TASK

            1. Read the plan file completely
            2. Count the number of TDD tasks
            3. Assess overall complexity based on:
               - Number of tasks (>6 is complex)
               - Cross-file dependencies
               - Integration complexity
               - Test complexity

            ## COMPLEXITY CLASSIFICATION
            - simple: 1-2 tasks → execute directly
            - complex: 3+ tasks → MUST decompose

            ## DECOMPOSITION RULES (MANDATORY)
            If task_count > 2:
            1. Split into sub-plans of 1-2 tasks each
            2. Each sub-plan must be independently executable
            3. Save sub-plans to `.claude/data/plans/`
            4. First sub-plan executes this run, others queued for future runs

            ## HIERARCHICAL NAMING (CRITICAL)
            Use hierarchical suffixes to maintain parent-child relationships:

            Level 0 (base):     022_feature.md
            Level 1 (letters):  022A_..., 022B_..., 022C_...
            Level 2 (numbers):  022A1_..., 022A2_..., 022A3_...
            Level 3 (lowercase): 022A1a_..., 022A1b_..., 022A1c_...

            To determine the correct suffix:
            1. Parse the current plan's prefix (e.g., "024A" from "024A_timeline.md")
            2. If prefix is just digits (024): add uppercase letter → 024A, 024B, 024C
            3. If prefix ends with letter (024A): add number → 024A1, 024A2, 024A3
            4. If prefix ends with number (024A1): add lowercase letter → 024A1a, 024A1b
            5. If prefix ends with lowercase (024A1a): add number → 024A1a1, 024A1a2

            ## FILENAME COLLISION PREVENTION (CRITICAL)
            BEFORE creating any sub-plans:
            1. Run: `ls -1 .claude/data/plans/*.md` to see existing plans
            2. Run: `ls -1 .claude/data/plans/executed/*.md` to see executed plans
            3. Run: `ls -1 .claude/data/plans/decomposed/*.md` to see decomposed parent plans
            4. Parse the current plan's prefix to determine the hierarchy level
            5. Find ALL existing plans with the same parent prefix (in ALL folders)
            6. Use the NEXT available suffix at the correct hierarchy level

            Examples:
            - Decomposing 024_timeline.md: If 024A, 024B exist → create 024C, 024D
            - Decomposing 024A_timeline.md: If 024A1 exists → create 024A2, 024A3
            - Decomposing 024A1_timeline.md: If 024A1a exists → create 024A1b, 024A1c

            ## AUTOMATIC COMPLEXITY ESCALATION
            Always flag as complex (even if ≤2 tasks) when plan involves:
            - GUI/UI testing (tkinter, Qt, browser)
            - Image processing (PIL, OpenCV)
            - System package dependencies

            ## OUTPUT REQUIRED

            Write a JSON file to `.claude/skills/story-execution/ci-decompose-result.json`:

            ```json
            {
              "complexity": "simple|medium|complex",
              "task_count": 5,
              "execute_plan": ".claude/data/plans/016_configurable-idle-threshold.md",
              "sub_plans_created": [],
              "notes": "Brief explanation"
            }
            ```

            If decomposed (from base plan 016_...):
            ```json
            {
              "complexity": "complex",
              "task_count": 12,
              "execute_plan": ".claude/data/plans/016A_idle-threshold-validation.md",
              "sub_plans_created": [
                ".claude/data/plans/016B_idle-threshold-integration.md",
                ".claude/data/plans/016C_idle-threshold-ui.md"
              ],
              "parent_moved": true,
              "notes": "Split into 3 sub-plans: A (validation), B (integration), C (UI). Parent moved to decomposed/"
            }
            ```

            If decomposed (from sub-plan 016A_... that's still too complex):
            ```json
            {
              "complexity": "complex",
              "task_count": 4,
              "execute_plan": ".claude/data/plans/016A1_validation-schema.md",
              "sub_plans_created": [
                ".claude/data/plans/016A2_validation-rules.md"
              ],
              "parent_moved": true,
              "notes": "Split 016A into 2 sub-plans: A1 (schema), A2 (rules). Parent moved to decomposed/"
            }
            ```

            ## CRITICAL VALIDATION BEFORE OUTPUT
            BEFORE writing the JSON output:
            1. Verify EVERY file path you reference actually exists using `ls -la <path>`
            2. The execute_plan MUST be a file that exists in .claude/data/plans/
            3. If you created sub-plans, verify they were written successfully
            4. NEVER output a path that doesn't exist - this will cause the workflow to fail

            IMPORTANT: If you create sub-plans, you must:
            1. Move the PARENT plan to `.claude/data/plans/decomposed/` folder (NOT executed!)
               This prevents the parent from being selected again in an infinite loop.
               Create the folder if it doesn't exist: `mkdir -p .claude/data/plans/decomposed`
            2. Create the new sub-plan files with proper content
            3. The execute_plan should be the FIRST sub-plan at the correct hierarchy level
               (e.g., 024A for base plan, 024A1 for sub-plan A, 024A1a for sub-plan A1)
            4. VERIFY the file exists before putting it in execute_plan
            5. Add "parent_moved": true to the JSON output if you moved the parent

          claude_args: |
            --allowedTools "Read,Write,Edit,Glob,Grep,Bash(python:*),Bash(python3:*),Bash(mkdir:*),Bash(mv:*),Bash(cp:*)"
            --model claude-opus-4-5-20251101
            --max-turns 25

      - name: "2.2 Read decompose output"
        id: decompose-output
        if: always()
        run: |
          RESULT_FILE=".claude/skills/story-execution/ci-decompose-result.json"
          PLAN_PATH="${{ needs.setup-and-plan.outputs.plan_path }}"

          if [ -f "$RESULT_FILE" ]; then
            COMPLEXITY=$(python3 -c "import json; d=json.load(open('$RESULT_FILE')); print(d.get('complexity','unknown'))")
            EXECUTE_PLAN=$(python3 -c "import json; d=json.load(open('$RESULT_FILE')); print(d.get('execute_plan',''))")
            SUB_PLANS=$(python3 -c "import json; d=json.load(open('$RESULT_FILE')); print(','.join(d.get('sub_plans_created',[])))")

            echo "Complexity: $COMPLEXITY"

            # CRITICAL: Validate that the execute_plan file actually exists
            FINAL_PLAN="${EXECUTE_PLAN:-$PLAN_PATH}"
            if [ -n "$EXECUTE_PLAN" ] && [ ! -f "$EXECUTE_PLAN" ]; then
              echo "⚠️ WARNING: Decompose generated non-existent plan path: $EXECUTE_PLAN"
              echo ""
              echo "Available plans in .claude/data/plans/:"
              ls -1 .claude/data/plans/*.md 2>/dev/null || echo "(none)"
              echo ""

              # Try to find a matching plan by searching for similar names
              # Handles hierarchical naming: 024, 024A, 024A1, 024A1a, etc.
              PLAN_BASENAME=$(basename "$EXECUTE_PLAN" .md)
              # Match: digits + optional (letter + optional (digit + optional lowercase))
              PLAN_SEQ=$(echo "$PLAN_BASENAME" | grep -oP '^\d{3}([A-Z](\d+[a-z]?)?)?' || echo "")

              if [ -n "$PLAN_SEQ" ]; then
                echo "Looking for plans with sequence: $PLAN_SEQ"
                MATCHING_PLAN=$(ls -1 .claude/data/plans/${PLAN_SEQ}*.md 2>/dev/null | head -1)
                if [ -n "$MATCHING_PLAN" ] && [ -f "$MATCHING_PLAN" ]; then
                  echo "✓ Found matching plan: $MATCHING_PLAN"
                  FINAL_PLAN="$MATCHING_PLAN"
                fi
              fi

              # If still no match, fall back to original plan
              if [ ! -f "$FINAL_PLAN" ]; then
                if [ -f "$PLAN_PATH" ]; then
                  echo "Falling back to original plan: $PLAN_PATH"
                  FINAL_PLAN="$PLAN_PATH"
                else
                  echo "❌ ERROR: No valid plan found!"
                  echo "Generated: $EXECUTE_PLAN"
                  echo "Original: $PLAN_PATH"
                  # Re-select earliest available plan
                  EARLIEST=$(ls -1 .claude/data/plans/*.md 2>/dev/null | head -1)
                  if [ -n "$EARLIEST" ]; then
                    echo "✓ Re-selecting earliest plan: $EARLIEST"
                    FINAL_PLAN="$EARLIEST"
                  else
                    echo "decompose_failed=true" >> $GITHUB_OUTPUT
                    exit 1
                  fi
                fi
              fi
            fi

            echo "complexity=$COMPLEXITY" >> $GITHUB_OUTPUT
            echo "execute_plan=$FINAL_PLAN" >> $GITHUB_OUTPUT
            echo "sub_plans_created=$SUB_PLANS" >> $GITHUB_OUTPUT
            echo "decompose_failed=false" >> $GITHUB_OUTPUT

            echo "Execute plan: $FINAL_PLAN"
            if [ -n "$SUB_PLANS" ]; then
              echo "Sub-plans created: $SUB_PLANS"
            fi
          else
            # Default to original plan if no result
            echo "complexity=unknown" >> $GITHUB_OUTPUT
            echo "execute_plan=$PLAN_PATH" >> $GITHUB_OUTPUT
            echo "sub_plans_created=" >> $GITHUB_OUTPUT
            echo "decompose_failed=false" >> $GITHUB_OUTPUT
            echo "No decompose result, using original plan: $PLAN_PATH"
          fi

      - name: "2.3 Commit sub-plans if created"
        if: steps.decompose-output.outputs.sub_plans_created != ''
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Pull latest before staging to avoid conflicts
          git fetch origin main
          git rebase origin/main || git rebase --abort

          git add -A

          if ! git diff --cached --quiet; then
            STORY_ID="${{ needs.setup-and-plan.outputs.story_id }}"
            git commit -m "ci: decompose plan into sub-plans

            Story: $STORY_ID
            Complexity: ${{ steps.decompose-output.outputs.complexity }}
            Sub-plans: ${{ steps.decompose-output.outputs.sub_plans_created }}"

            # Retry push with exponential backoff and pull before retry
            for attempt in 1 2 3 4; do
              if git push origin main; then
                echo "✓ Committed and pushed sub-plans"
                exit 0
              else
                echo "Push failed (attempt $attempt), pulling and retrying..."
                git pull --rebase origin main || true
                sleep $((2 ** attempt))
              fi
            done
            echo "❌ Push failed after 4 attempts"
            exit 1
          else
            echo "No changes to commit"
          fi

      - name: "2.4 Upload decompose result"
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: decompose-result
          path: .claude/skills/story-execution/ci-decompose-result.json
          retention-days: 1
          if-no-files-found: ignore

  # ════════════════════════════════════════════════════════════════════════════
  # EXECUTE: Follow plan's TDD steps directly (Sonnet)
  # ════════════════════════════════════════════════════════════════════════════
  execute:
    needs: [setup-and-plan, validate-plan, verify-implementation, review-plan, decompose]
    if: |
      always() &&
      needs.decompose.outputs.execute_plan != ''
    runs-on: ubuntu-latest
    timeout-minutes: 45
    outputs:
      status: ${{ steps.execute-output.outputs.status }}
      commits_made: ${{ steps.execute-output.outputs.commits_made }}
      complexity_ok: ${{ steps.verify-complexity.outputs.complexity_ok }}
      task_count: ${{ steps.verify-complexity.outputs.task_count }}

    steps:
      - name: "3.0 Checkout repository"
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: "3.1 Pull latest changes"
        run: |
          git pull origin main --rebase || true

      - name: "3.1.1 Clean up Claude installation locks"
        run: |
          rm -rf /tmp/claude-* 2>/dev/null || true
          rm -rf ~/.claude-install* 2>/dev/null || true
          rm -rf ~/.npm/_locks/* 2>/dev/null || true
          pkill -f "claude" 2>/dev/null || true
          echo "✓ Cleaned up potential installation locks"

      - name: "3.1.2 Verify plan file exists"
        id: verify-plan
        run: |
          PLAN_PATH="${{ needs.decompose.outputs.execute_plan }}"
          echo "Checking plan file: $PLAN_PATH"

          if [ -z "$PLAN_PATH" ]; then
            echo "❌ No plan path provided by decompose job"
            echo "plan_exists=false" >> $GITHUB_OUTPUT
            exit 1
          fi

          if [ ! -f "$PLAN_PATH" ]; then
            echo "❌ Plan file does not exist: $PLAN_PATH"
            echo ""
            echo "Available plans in .claude/data/plans/:"
            ls -la .claude/data/plans/*.md 2>/dev/null || echo "(none)"
            echo ""
            echo "Recently executed plans:"
            ls -la .claude/data/plans/executed/*.md 2>/dev/null | head -5 || echo "(none)"
            echo "plan_exists=false" >> $GITHUB_OUTPUT
            exit 1
          fi

          echo "✓ Plan file verified: $PLAN_PATH"
          echo "plan_exists=true" >> $GITHUB_OUTPUT

      - name: "3.1.3 Verify plan complexity is simple"
        id: verify-complexity
        run: |
          PLAN_PATH="${{ needs.decompose.outputs.execute_plan }}"

          # Count TDD tasks in the plan
          # Look for patterns like "### Task 1:", "### Task 2:", etc.
          TASK_COUNT=$(grep -cE '^###\s+Task\s+[0-9]+' "$PLAN_PATH" 2>/dev/null || echo "0")

          echo "Plan: $PLAN_PATH"
          echo "Task count: $TASK_COUNT"

          if [ "$TASK_COUNT" -gt 2 ]; then
            echo ""
            echo "⚠️ WARNING: Plan has $TASK_COUNT tasks (max 2 for execution)"
            echo "This plan should have been decomposed further."
            echo ""
            echo "Tasks found:"
            grep -E '^###\s+Task\s+[0-9]+' "$PLAN_PATH" || true
            echo ""
            echo "## ⚠️ Plan Too Complex" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Plan \`$(basename $PLAN_PATH)\` has **$TASK_COUNT tasks** but max is 2." >> $GITHUB_STEP_SUMMARY
            echo "The decompose step should have split this further." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Action needed:** Re-run the workflow or manually decompose this plan." >> $GITHUB_STEP_SUMMARY

            echo "complexity_ok=false" >> $GITHUB_OUTPUT
            echo "task_count=$TASK_COUNT" >> $GITHUB_OUTPUT

            # Don't fail - let execution attempt it, but flag the issue
            # The execution may still succeed for borderline cases
            echo "Proceeding with execution despite complexity warning..."
          else
            echo "✓ Plan complexity OK: $TASK_COUNT tasks"
            echo "complexity_ok=true" >> $GITHUB_OUTPUT
            echo "task_count=$TASK_COUNT" >> $GITHUB_OUTPUT
          fi

      - name: "3.1.5 Setup Python environment"
        run: |
          echo "Setting up Python environment..."
          python3 --version
          python3 -m pip install --upgrade pip
          python3 -m pip install pytest
          python3 -m pytest --version
          echo "✓ Python environment ready with pytest"

      - name: "3.2 Execute plan"
        id: execute
        uses: anthropics/claude-code-action@v1
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          show_full_output: true
          prompt: |
            You are executing a TDD implementation plan in CI mode.

            ## ENVIRONMENT
            - Runner: ubuntu-latest (Linux)
            - Python venv: Use `source venv/bin/activate` NOT `venv\Scripts\activate`
            - Use Linux paths with forward slashes

            Plan to execute: ${{ needs.decompose.outputs.execute_plan }}
            Story ID: ${{ needs.validate-plan.outputs.story_id || needs.setup-and-plan.outputs.story_id }}
            Review outcome: ${{ needs.review-plan.outputs.outcome }}

            ## YOUR TASK

            1. Read the plan document completely
            2. Follow EACH task's TDD steps EXACTLY as written in the plan:
               - RED: Write the failing test as specified
               - Verify RED: Run the test, confirm it fails for the right reason
               - GREEN: Implement the code as specified
               - Verify GREEN: Run the test, confirm it passes
               - COMMIT: Stage and commit with the message format shown
            3. Continue through ALL tasks in the plan
            4. After each task, immediately commit your changes

            ## TDD DISCIPLINE

            - Follow the plan's test code EXACTLY - do not modify tests
            - Follow the plan's implementation code as a guide
            - If a test already passes (RED fails to be RED), note it and move on
            - If you get stuck on a task, document what happened and continue

            ## COMMIT FORMAT

            Use the format specified in the plan, typically:
            ```
            feat: [task description]

            Story: ${{ needs.setup-and-plan.outputs.story_id }}
            Task: N of M
            ```

            ## OUTPUT REQUIRED

            After completing all tasks, write to `.claude/skills/story-execution/ci-execute-result.json`:

            ```json
            {
              "status": "completed|partial|failed",
              "tasks_completed": 5,
              "tasks_total": 5,
              "commits": ["abc1234", "def5678"],
              "files_modified": ["src/file1.py", "tests/test_file1.py"],
              "notes": "Brief summary of what was accomplished",
              "error": "If failed/partial, describe the error or blocker"
            }
            ```

            IMPORTANT for result file:
            - Include ALL commit SHAs you created (full 40-char or short 7-char)
            - List the key files you modified (not every file, just the main ones)
            - If status is "failed" or "partial", explain WHY in the error field

            ## IMPORTANT

            - Read the plan document directly - it contains all instructions
            - The plan has explicit test code and implementation code to follow
            - Do NOT skip the verification steps (run pytest after each RED and GREEN)
            - Commit your changes after each task (push is handled automatically by the workflow)

          claude_args: |
            --allowedTools "Read,Write,Edit,Glob,Grep,Bash(git:*),Bash(python:*),Bash(python3:*),Bash(pytest:*),Bash(pip:*),Bash(pip3:*),Bash(mkdir:*),Bash(source:*),Bash(cat:*),Bash(ls:*),Bash(rm:*),Bash(chmod:*),BashOutput,TodoWrite"
            --model claude-sonnet-4-5-20250929
            --max-turns 50

      - name: "3.3 Push implementation commits"
        if: always()
        run: |
          # Check if there are commits to push
          git fetch origin main
          COMMITS_AHEAD=$(git rev-list origin/main..HEAD --count 2>/dev/null || echo "0")

          if [ "$COMMITS_AHEAD" -gt 0 ]; then
            echo "Found $COMMITS_AHEAD commits to push"

            # Retry push with exponential backoff
            for attempt in 1 2 3 4; do
              if git push origin main; then
                echo "✓ Pushed $COMMITS_AHEAD implementation commits"
                exit 0
              else
                echo "Push failed (attempt $attempt), pulling and retrying..."
                git pull --rebase origin main || true
                sleep $((2 ** attempt))
              fi
            done
            echo "❌ Push failed after 4 attempts"
            exit 1
          else
            echo "No commits to push"
          fi

      - name: "3.4 Read execute output"
        id: execute-output
        if: always()
        run: |
          RESULT_FILE=".claude/skills/story-execution/ci-execute-result.json"

          if [ -f "$RESULT_FILE" ]; then
            STATUS=$(python3 -c "import json; d=json.load(open('$RESULT_FILE')); print(d.get('status','unknown'))")
            COMMITS=$(python3 -c "import json; d=json.load(open('$RESULT_FILE')); print(','.join(d.get('commits',[])))")
            COMPLETED=$(python3 -c "import json; d=json.load(open('$RESULT_FILE')); print(d.get('tasks_completed',0))")
            TOTAL=$(python3 -c "import json; d=json.load(open('$RESULT_FILE')); print(d.get('tasks_total',0))")

            echo "status=$STATUS" >> $GITHUB_OUTPUT
            echo "commits_made=$COMMITS" >> $GITHUB_OUTPUT

            echo "Status: $STATUS"
            echo "Tasks: $COMPLETED/$TOTAL"
            echo "Commits: $COMMITS"
          else
            # Check if there are uncommitted changes or new commits
            UNCOMMITTED=$(git status --porcelain | wc -l)
            NEW_COMMITS=$(git log origin/main..HEAD --oneline 2>/dev/null | wc -l)

            if [ "$NEW_COMMITS" -gt 0 ] || [ "$UNCOMMITTED" -gt 0 ]; then
              echo "status=partial" >> $GITHUB_OUTPUT
              echo "commits_made=" >> $GITHUB_OUTPUT
              echo "No result file, but found $NEW_COMMITS new commits and $UNCOMMITTED uncommitted changes"
            else
              echo "status=failed" >> $GITHUB_OUTPUT
              echo "commits_made=" >> $GITHUB_OUTPUT
              echo "No result file and no changes detected"
            fi
          fi

      - name: "3.5 Upload execute result"
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: execute-result
          path: .claude/skills/story-execution/ci-execute-result.json
          retention-days: 1
          if-no-files-found: ignore

  # ════════════════════════════════════════════════════════════════════════════
  # FINALIZE: Archive, commit, push, report
  # ════════════════════════════════════════════════════════════════════════════
  finalize:
    needs: [setup-and-plan, validate-plan, verify-implementation, review-plan, decompose, execute]
    if: always()
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: "4.0 Checkout repository"
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: "4.0.1 Pull latest changes"
        run: |
          git pull origin main --rebase || true

      - name: "4.1 Determine final outcome"
        id: outcome
        run: |
          SHOULD_EXECUTE="${{ needs.setup-and-plan.outputs.should_execute }}"
          SKIP_REASON="${{ needs.setup-and-plan.outputs.skip_reason }}"
          NEEDS_VERIFICATION="${{ needs.setup-and-plan.outputs.needs_verification }}"
          VERIFICATION_PASSED="${{ needs.verify-implementation.outputs.verification_passed }}"
          SHOULD_PROCEED_TO_EXECUTE="${{ needs.verify-implementation.outputs.should_proceed_to_execute }}"
          PLAN_BLOCKED="${{ needs.validate-plan.outputs.plan_blocked }}"

          # Handle validate-plan blocking the plan (no Story ID found)
          if [ "$PLAN_BLOCKED" = "true" ]; then
            echo "outcome=blocked" >> $GITHUB_OUTPUT
            echo "reason=no_story_id" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Handle verification flow
          if [ "$NEEDS_VERIFICATION" = "true" ]; then
            if [ "$VERIFICATION_PASSED" = "true" ]; then
              # Implementation was verified, plan was archived by verify-implementation job
              echo "outcome=verified" >> $GITHUB_OUTPUT
              echo "reason=implementation_confirmed" >> $GITHUB_OUTPUT
              exit 0
            fi

            VERIFICATION_INCOMPLETE="${{ needs.verify-implementation.outputs.verification_incomplete }}"
            if [ "$VERIFICATION_INCOMPLETE" = "true" ]; then
              # Verification hit max-turns limit, needs manual review
              echo "outcome=needs_manual_review" >> $GITHUB_OUTPUT
              echo "reason=verification_incomplete" >> $GITHUB_OUTPUT
              exit 0
            elif [ "$SHOULD_PROCEED_TO_EXECUTE" != "true" ]; then
              # Verification completed but needs manual review (partial implementation)
              echo "outcome=needs_manual_review" >> $GITHUB_OUTPUT
              echo "reason=partial_implementation" >> $GITHUB_OUTPUT
              exit 0
            fi
            # If should_proceed_to_execute=true, continue to check execution results
          fi

          # If setup determined we shouldn't execute (and not verification flow)
          if [ "$SHOULD_EXECUTE" != "true" ] && [ "$SHOULD_PROCEED_TO_EXECUTE" != "true" ]; then
            echo "outcome=skipped" >> $GITHUB_OUTPUT
            echo "reason=$SKIP_REASON" >> $GITHUB_OUTPUT
            exit 0
          fi

          REVIEW_COMPLETED="${{ needs.review-plan.outputs.review_completed }}"
          if [ "$REVIEW_COMPLETED" != "true" ]; then
            echo "outcome=failure" >> $GITHUB_OUTPUT
            echo "reason=review_failed" >> $GITHUB_OUTPUT
            exit 0
          fi

          REVIEW_OUTCOME="${{ needs.review-plan.outputs.outcome }}"

          # Handle review returning "verified" (already implemented)
          if [ "$REVIEW_OUTCOME" = "verified" ]; then
            echo "outcome=verified" >> $GITHUB_OUTPUT
            echo "reason=already_implemented" >> $GITHUB_OUTPUT
            exit 0
          fi

          if [ "$REVIEW_OUTCOME" = "pause" ]; then
            echo "outcome=paused" >> $GITHUB_OUTPUT
            echo "reason=blocking_issues" >> $GITHUB_OUTPUT
            exit 0
          fi

          EXECUTE_STATUS="${{ needs.execute.outputs.status }}"
          case "$EXECUTE_STATUS" in
            completed)
              if [ "$REVIEW_OUTCOME" = "proceed_with_review" ]; then
                echo "outcome=success" >> $GITHUB_OUTPUT
                echo "needs_review=true" >> $GITHUB_OUTPUT
              else
                echo "outcome=success" >> $GITHUB_OUTPUT
                echo "needs_review=false" >> $GITHUB_OUTPUT
              fi
              ;;
            partial)
              echo "outcome=partial" >> $GITHUB_OUTPUT
              echo "needs_review=true" >> $GITHUB_OUTPUT
              ;;
            failed|"")
              echo "outcome=failure" >> $GITHUB_OUTPUT
              echo "reason=execution_failed" >> $GITHUB_OUTPUT
              ;;
            *)
              echo "outcome=unknown" >> $GITHUB_OUTPUT
              echo "reason=unknown_status" >> $GITHUB_OUTPUT
              ;;
          esac

      - name: "4.2 Archive executed plan"
        if: steps.outcome.outputs.outcome == 'success' || steps.outcome.outputs.outcome == 'verified'
        run: |
          # Use decompose output if available, otherwise use original plan path
          EXECUTE_PLAN="${{ needs.decompose.outputs.execute_plan }}"
          if [ -z "$EXECUTE_PLAN" ]; then
            EXECUTE_PLAN="${{ needs.setup-and-plan.outputs.plan_path }}"
          fi
          ARCHIVE_DIR=".claude/data/plans/executed"

          if [ -f "$EXECUTE_PLAN" ]; then
            mkdir -p "$ARCHIVE_DIR"
            mv "$EXECUTE_PLAN" "$ARCHIVE_DIR/"
            echo "✓ Archived: $EXECUTE_PLAN → $ARCHIVE_DIR/"
          else
            echo "Plan already archived or moved"
          fi

      - name: "4.3 Update story status in database"
        if: |
          (steps.outcome.outputs.outcome == 'success' ||
           steps.outcome.outputs.outcome == 'partial' ||
           steps.outcome.outputs.outcome == 'verified') &&
          (needs.validate-plan.outputs.story_id != 'none' || needs.setup-and-plan.outputs.story_id != 'none')
        run: |
          # Use story_id from validate-plan if available, otherwise from setup-and-plan
          STORY_ID="${{ needs.validate-plan.outputs.story_id }}"
          if [ -z "$STORY_ID" ] || [ "$STORY_ID" = "none" ]; then
            STORY_ID="${{ needs.setup-and-plan.outputs.story_id }}"
          fi

          if [ -z "$STORY_ID" ] || [ "$STORY_ID" = "none" ]; then
            echo "No Story ID available, skipping database update"
            exit 0
          fi

          DB_PATH=".claude/data/story-tree.db"
          NEEDS_REVIEW="${{ steps.outcome.outputs.needs_review }}"
          OUTCOME="${{ steps.outcome.outputs.outcome }}"

          if [ ! -f "$DB_PATH" ]; then
            echo "Database not found, skipping status update"
            exit 0
          fi

          if [ "$OUTCOME" = "verified" ]; then
            STAGE="implemented"
            NOTE="CI verified: implementation already exists"
            REVIEW_FLAG=0
          elif [ "$NEEDS_REVIEW" = "true" ]; then
            STAGE="reviewing"
            NOTE="CI execution $OUTCOME (review required)"
            REVIEW_FLAG=1
          else
            STAGE="verifying"
            NOTE="CI execution complete"
            REVIEW_FLAG=0
          fi

          python3 << PYEOF
          import sqlite3
          conn = sqlite3.connect("$DB_PATH")
          conn.execute('''
              UPDATE story_nodes
              SET stage = '$STAGE',
                  human_review = $REVIEW_FLAG,
                  notes = COALESCE(notes || char(10), '') || '$NOTE: ' || datetime('now'),
                  updated_at = datetime('now')
              WHERE id = ?
          ''', ("$STORY_ID",))
          conn.commit()
          print(f"✓ Updated story $STORY_ID → $STAGE")
          conn.close()
          PYEOF

      - name: "4.4 Stage all changes"
        if: steps.outcome.outputs.outcome == 'success' || steps.outcome.outputs.outcome == 'partial' || steps.outcome.outputs.outcome == 'verified'
        id: stage
        run: |
          git add -A
          if git diff --cached --quiet; then
            echo "has_changes=false" >> $GITHUB_OUTPUT
            echo "No changes to commit"
          else
            echo "has_changes=true" >> $GITHUB_OUTPUT
            echo "Changes staged for commit:"
            git diff --cached --stat
          fi

      - name: "4.5 Commit changes"
        if: steps.stage.outputs.has_changes == 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          EXECUTE_PLAN="${{ needs.decompose.outputs.execute_plan }}"
          STORY_ID="${{ needs.setup-and-plan.outputs.story_id }}"
          PLAN_FILENAME=$(basename "$EXECUTE_PLAN")

          git commit -m "ci: execute plan $PLAN_FILENAME

          Story: $STORY_ID"

          echo "✓ Committed changes"

      - name: "4.6 Push to remote"
        if: steps.stage.outputs.has_changes == 'true'
        run: |
          for attempt in 1 2 3 4; do
            if git push origin main; then
              echo "✓ Push successful"
              exit 0
            else
              echo "Push failed (attempt $attempt), pulling and retrying..."
              git pull --rebase origin main || true
              sleep $((2 ** attempt))
            fi
          done
          echo "❌ Push failed after 4 attempts"
          exit 1

      # ── REPORTING ──
      - name: "4.7 Generate execution summary"
        if: always()
        run: |
          echo "## Execution Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          PLAN_SELECTED="${{ needs.setup-and-plan.outputs.plan_selected }}"
          if [ "$PLAN_SELECTED" = "true" ]; then
            echo "| Field | Value |" >> $GITHUB_STEP_SUMMARY
            echo "|-------|-------|" >> $GITHUB_STEP_SUMMARY
            echo "| Plan | \`${{ needs.setup-and-plan.outputs.plan_filename }}\` |" >> $GITHUB_STEP_SUMMARY
            echo "| Sequence | ${{ needs.setup-and-plan.outputs.plan_sequence }} |" >> $GITHUB_STEP_SUMMARY
            echo "| Story ID | ${{ needs.setup-and-plan.outputs.story_id }} |" >> $GITHUB_STEP_SUMMARY
            echo "| Complexity | ${{ needs.decompose.outputs.complexity }} |" >> $GITHUB_STEP_SUMMARY

            OUTCOME="${{ steps.outcome.outputs.outcome }}"
            case "$OUTCOME" in
              success)
                if [ "${{ steps.outcome.outputs.needs_review }}" = "true" ]; then
                  echo "| Outcome | ✅ Success (review required) |" >> $GITHUB_STEP_SUMMARY
                else
                  echo "| Outcome | ✅ Success |" >> $GITHUB_STEP_SUMMARY
                fi
                ;;
              verified)
                REASON="${{ steps.outcome.outputs.reason }}"
                if [ "$REASON" = "already_implemented" ]; then
                  echo "| Outcome | ✅ Verified (already implemented) |" >> $GITHUB_STEP_SUMMARY
                else
                  echo "| Outcome | ✅ Verified (implementation confirmed) |" >> $GITHUB_STEP_SUMMARY
                fi
                ;;
              blocked)
                echo "| Outcome | 🚫 Blocked (no Story ID found) |" >> $GITHUB_STEP_SUMMARY
                ;;
              needs_manual_review)
                REASON="${{ steps.outcome.outputs.reason }}"
                if [ "$REASON" = "verification_incomplete" ]; then
                  echo "| Outcome | 🔍 Needs Manual Review (verification timed out) |" >> $GITHUB_STEP_SUMMARY
                else
                  echo "| Outcome | 🔍 Needs Manual Review (partial implementation) |" >> $GITHUB_STEP_SUMMARY
                fi
                ;;
              partial)
                echo "| Outcome | ⚠️ Partial (review required) |" >> $GITHUB_STEP_SUMMARY
                ;;
              paused)
                echo "| Outcome | ⏸️ Paused (blocking issues) |" >> $GITHUB_STEP_SUMMARY
                ;;
              failure)
                echo "| Outcome | ❌ Failed |" >> $GITHUB_STEP_SUMMARY
                echo "| Reason | ${{ steps.outcome.outputs.reason }} |" >> $GITHUB_STEP_SUMMARY
                ;;
              skipped)
                SKIP_REASON="${{ needs.setup-and-plan.outputs.skip_reason }}"
                case "$SKIP_REASON" in
                  already_executed)
                    echo "| Outcome | ⏭️ Skipped (already executed) |" >> $GITHUB_STEP_SUMMARY
                    ;;
                  deps_unmet)
                    echo "| Outcome | 🚧 Blocked (unmet deps) |" >> $GITHUB_STEP_SUMMARY
                    ;;
                  *)
                    echo "| Outcome | ⏭️ Skipped ($SKIP_REASON) |" >> $GITHUB_STEP_SUMMARY
                    ;;
                esac
                ;;
              *)
                echo "| Outcome | ⚠️ Unknown |" >> $GITHUB_STEP_SUMMARY
                ;;
            esac
          else
            echo "No plan files available for execution." >> $GITHUB_STEP_SUMMARY
          fi

      - name: "4.8 Report pipeline status"
        if: always() && needs.setup-and-plan.outputs.plan_selected == 'true'
        run: |
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Pipeline Stages" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Stage | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| setup-and-plan | ✅ |" >> $GITHUB_STEP_SUMMARY

          # Report validate-plan stage if it ran (when story_id was 'none')
          STORY_ID="${{ needs.setup-and-plan.outputs.story_id }}"
          if [ "$STORY_ID" = "none" ]; then
            PLAN_BLOCKED="${{ needs.validate-plan.outputs.plan_blocked }}"
            VALIDATED_STORY_ID="${{ needs.validate-plan.outputs.story_id }}"
            if [ "$PLAN_BLOCKED" = "true" ]; then
              echo "| validate-plan | 🚫 blocked (no match) |" >> $GITHUB_STEP_SUMMARY
            elif [ -n "$VALIDATED_STORY_ID" ] && [ "$VALIDATED_STORY_ID" != "none" ]; then
              echo "| validate-plan | ✅ matched ($VALIDATED_STORY_ID) |" >> $GITHUB_STEP_SUMMARY
            else
              echo "| validate-plan | ⏭️ skipped |" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "| validate-plan | ⏭️ skipped (has ID) |" >> $GITHUB_STEP_SUMMARY
          fi

          # Report verification stage if it ran
          NEEDS_VERIFICATION="${{ needs.setup-and-plan.outputs.needs_verification }}"
          if [ "$NEEDS_VERIFICATION" = "true" ]; then
            VERIFICATION_PASSED="${{ needs.verify-implementation.outputs.verification_passed }}"
            VERIFICATION_INCOMPLETE="${{ needs.verify-implementation.outputs.verification_incomplete }}"
            if [ "$VERIFICATION_PASSED" = "true" ]; then
              echo "| verify-implementation | ✅ passed |" >> $GITHUB_STEP_SUMMARY
            elif [ "$VERIFICATION_INCOMPLETE" = "true" ]; then
              echo "| verify-implementation | ⏱️ timed out → manual review |" >> $GITHUB_STEP_SUMMARY
            else
              SHOULD_EXECUTE="${{ needs.verify-implementation.outputs.should_proceed_to_execute }}"
              if [ "$SHOULD_EXECUTE" = "true" ]; then
                echo "| verify-implementation | ⚠️ failed → re-execute |" >> $GITHUB_STEP_SUMMARY
              else
                echo "| verify-implementation | 🔍 partial → manual review |" >> $GITHUB_STEP_SUMMARY
              fi
            fi
          fi

          REVIEW="${{ needs.review-plan.outputs.outcome }}"
          if [ -n "$REVIEW" ]; then
            echo "| review-plan | $REVIEW |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| review-plan | ⏭️ skipped |" >> $GITHUB_STEP_SUMMARY
          fi

          COMPLEXITY="${{ needs.decompose.outputs.complexity }}"
          if [ -n "$COMPLEXITY" ]; then
            echo "| decompose | $COMPLEXITY |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| decompose | ⏭️ skipped |" >> $GITHUB_STEP_SUMMARY
          fi

          EXECUTE="${{ needs.execute.outputs.status }}"
          if [ -n "$EXECUTE" ]; then
            echo "| execute | $EXECUTE |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| execute | ⏭️ skipped |" >> $GITHUB_STEP_SUMMARY
          fi

          echo "| finalize | ${{ steps.outcome.outputs.outcome }} |" >> $GITHUB_STEP_SUMMARY

      - name: "4.8.1 Download result artifacts"
        if: always()
        uses: actions/download-artifact@v4
        with:
          path: /tmp/artifacts
          merge-multiple: true
        continue-on-error: true

      - name: "4.8.2 Parse result files for issue message"
        id: parse-results
        if: always()
        run: |
          # Initialize default values
          echo "tasks_completed=0" >> $GITHUB_OUTPUT
          echo "tasks_total=0" >> $GITHUB_OUTPUT
          echo "commits_list=" >> $GITHUB_OUTPUT
          echo "blocking_issues=" >> $GITHUB_OUTPUT
          echo "review_notes=" >> $GITHUB_OUTPUT
          echo "files_changed=" >> $GITHUB_OUTPUT
          echo "error_summary=" >> $GITHUB_OUTPUT

          # Parse execute-result.json if exists
          EXEC_RESULT="/tmp/artifacts/ci-execute-result.json"
          if [ -f "$EXEC_RESULT" ]; then
            echo "Found execute result file"
            python3 << 'PYEOF'
          import json, os

          with open("/tmp/artifacts/ci-execute-result.json") as f:
              data = json.load(f)

          with open(os.environ['GITHUB_OUTPUT'], 'a') as out:
              out.write(f"tasks_completed={data.get('tasks_completed', 0)}\n")
              out.write(f"tasks_total={data.get('tasks_total', 0)}\n")

              commits = data.get('commits', [])
              if commits:
                  # Format as short SHAs
                  short_commits = [c[:7] if len(c) > 7 else c for c in commits]
                  out.write(f"commits_list={','.join(short_commits)}\n")

              files = data.get('files_modified', []) or data.get('files_changed', [])
              if files:
                  # Limit to first 5 files
                  display_files = files[:5]
                  if len(files) > 5:
                      display_files.append(f"... and {len(files) - 5} more")
                  out.write(f"files_changed={' | '.join(display_files)}\n")

              # Check for error info
              error = data.get('error') or data.get('failure_reason') or data.get('notes', '')
              if error and data.get('status') != 'completed':
                  # Truncate to 200 chars
                  error_short = str(error)[:200]
                  out.write(f"error_summary={error_short}\n")
          PYEOF
          fi

          # Parse review-result.json if exists
          REVIEW_RESULT="/tmp/artifacts/ci-review-result.json"
          if [ -f "$REVIEW_RESULT" ]; then
            echo "Found review result file"
            python3 << 'PYEOF'
          import json, os

          with open("/tmp/artifacts/ci-review-result.json") as f:
              data = json.load(f)

          with open(os.environ['GITHUB_OUTPUT'], 'a') as out:
              blocking = data.get('blocking_issues', [])
              if blocking:
                  # Format blocking issues as bullet points
                  issues_text = ' • '.join(str(i) for i in blocking[:3])
                  out.write(f"blocking_issues={issues_text}\n")

              notes = data.get('notes', '')
              if notes:
                  out.write(f"review_notes={notes[:150]}\n")
          PYEOF
          fi

          echo "Result parsing complete"

      - name: "4.9 Post results to story issue"
        if: |
          always() &&
          needs.setup-and-plan.outputs.plan_selected == 'true' &&
          (needs.setup-and-plan.outputs.story_id != 'none' && needs.setup-and-plan.outputs.story_id != '' ||
           needs.validate-plan.outputs.story_id != 'none' && needs.validate-plan.outputs.story_id != '')
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Use story_id from validate-plan if available, otherwise from setup-and-plan
          STORY_ID="${{ needs.validate-plan.outputs.story_id }}"
          if [ -z "$STORY_ID" ] || [ "$STORY_ID" = "none" ]; then
            STORY_ID="${{ needs.setup-and-plan.outputs.story_id }}"
          fi

          if [ -z "$STORY_ID" ] || [ "$STORY_ID" = "none" ]; then
            echo "No Story ID available, skipping issue posting"
            exit 0
          fi
          # Use decompose output if available, otherwise fall back to setup-and-plan
          EXECUTE_PLAN="${{ needs.decompose.outputs.execute_plan }}"
          if [ -z "$EXECUTE_PLAN" ]; then
            EXECUTE_PLAN="${{ needs.setup-and-plan.outputs.plan_path }}"
          fi
          PLAN_FILENAME="${{ needs.setup-and-plan.outputs.plan_filename }}"
          if [ -z "$PLAN_FILENAME" ]; then
            PLAN_FILENAME=$(basename "$EXECUTE_PLAN" 2>/dev/null || echo "unknown")
          fi
          COMPLEXITY="${{ needs.decompose.outputs.complexity }}"
          if [ -z "$COMPLEXITY" ]; then
            COMPLEXITY="(verified - skipped)"
          fi
          DB_PATH=".claude/data/story-tree.db"

          # Query story details from database
          TITLE=""
          DESCRIPTION=""
          USER_STORY=""
          SUCCESS_CRITERIA=""
          if [ -f "$DB_PATH" ]; then
            # Query all relevant fields from story_nodes (pipe-delimited output)
            IFS='|' read -r TITLE DESCRIPTION USER_STORY SUCCESS_CRITERIA <<< "$(python3 << PYEOF
          import sqlite3

          conn = sqlite3.connect("$DB_PATH")
          r = conn.execute('''
              SELECT title, description, story, success_criteria
              FROM story_nodes WHERE id = ?
          ''', ("$STORY_ID",)).fetchone()
          conn.close()

          if r:
              # Use | as delimiter, escape any existing |
              title = (r[0] or '').replace('|', '/')
              desc = (r[1] or '').replace('|', '/').replace('\n', ' ')[:500]
              story = (r[2] or '').replace('|', '/').replace('\n', ' ')
              criteria = (r[3] or '').replace('|', '/')
              print(f"{title}|{desc}|{story}|{criteria}")
          else:
              print("|||")
          PYEOF
            )"
          fi
          TITLE="${TITLE:-Story $STORY_ID}"

          # Derive parent story ID (e.g., "8.1.1" -> "8.1", "8.1" -> "8")
          PARENT_ID=""
          if [[ "$STORY_ID" =~ \. ]]; then
            PARENT_ID="${STORY_ID%.*}"
          fi

          # Look up parent story's tracking issue if parent exists
          PARENT_ISSUE_REF=""
          if [ -n "$PARENT_ID" ]; then
            PARENT_TITLE=""
            if [ -f "$DB_PATH" ]; then
              PARENT_TITLE=$(python3 -c "import sqlite3; c=sqlite3.connect('$DB_PATH'); r=c.execute('SELECT title FROM story_nodes WHERE id=?',('$PARENT_ID',)).fetchone(); print(r[0] if r else '')" 2>/dev/null)
            fi
            if [ -n "$PARENT_TITLE" ]; then
              PARENT_ISSUE_TITLE="$PARENT_ID - $PARENT_TITLE"
              PARENT_ISSUE_NUM=$(gh issue list --state all --search "\"$PARENT_ISSUE_TITLE\" in:title" --json number,title --jq ".[] | select(.title == \"$PARENT_ISSUE_TITLE\") | .number" | head -1)
              if [ -n "$PARENT_ISSUE_NUM" ]; then
                PARENT_ISSUE_REF="#$PARENT_ISSUE_NUM"
              else
                PARENT_ISSUE_REF="$PARENT_ID - $PARENT_TITLE"
              fi
            fi
          fi

          ISSUE_TITLE="$STORY_ID - $TITLE"

          ISSUE_NUM=$(gh issue list --state all --search "\"$ISSUE_TITLE\" in:title" --json number,title --jq ".[] | select(.title == \"$ISSUE_TITLE\") | .number" | head -1)

          if [ -z "$ISSUE_NUM" ]; then
            # Build rich initial issue body
            RUN_URL="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"

            INITIAL_BODY="# $TITLE

          **Story ID:** $STORY_ID"

            if [ -n "$PARENT_ISSUE_REF" ]; then
              INITIAL_BODY="$INITIAL_BODY
          **Parent Story:** $PARENT_ISSUE_REF"
            fi

            INITIAL_BODY="$INITIAL_BODY
          **Plan:** \`$PLAN_FILENAME\`

          ---

          ## Description
          ${DESCRIPTION:-_No description available_}"

            if [ -n "$USER_STORY" ]; then
              INITIAL_BODY="$INITIAL_BODY

          ## User Story
          > $USER_STORY"
            fi

            if [ -n "$SUCCESS_CRITERIA" ]; then
              # Convert \n back to actual newlines for display
              FORMATTED_CRITERIA=$(echo "$SUCCESS_CRITERIA" | sed 's/\\n/\n/g')
              INITIAL_BODY="$INITIAL_BODY

          ## Success Criteria
          $FORMATTED_CRITERIA"
            fi

            INITIAL_BODY="$INITIAL_BODY

          ---
          *Created by [execute-stories workflow]($RUN_URL)*"

            ISSUE_NUM=$(gh issue create --title "$ISSUE_TITLE" --body "$INITIAL_BODY" --label "story-tracking" 2>/dev/null | grep -oP 'issues/\K[0-9]+' || \
                        gh issue create --title "$ISSUE_TITLE" --body "$INITIAL_BODY" | grep -oP 'issues/\K[0-9]+' || echo "")
            echo "Created new issue #$ISSUE_NUM with rich context"
          fi

          if [ -z "$ISSUE_NUM" ]; then
            echo "Could not find/create issue"
            exit 0
          fi

          OUTCOME="${{ steps.outcome.outputs.outcome }}"
          REASON="${{ steps.outcome.outputs.reason }}"
          case "$OUTCOME" in
            success)
              if [ "${{ steps.outcome.outputs.needs_review }}" = "true" ]; then
                STATUS="✅ Success (review required)"
              else
                STATUS="✅ Success"
              fi
              ;;
            verified)
              if [ "$REASON" = "already_implemented" ]; then
                STATUS="✅ Verified (already implemented - plan archived)"
              else
                STATUS="✅ Verified (implementation confirmed in codebase)"
              fi
              ;;
            blocked)
              STATUS="🚫 Blocked (no matching Story ID found)"
              ;;
            needs_manual_review)
              if [ "$REASON" = "verification_incomplete" ]; then
                STATUS="🔍 Needs Manual Review (verification timed out - please check if implementation exists)"
              else
                STATUS="🔍 Needs Manual Review (partial implementation detected)"
              fi
              ;;
            partial)
              STATUS="⚠️ Partial (review required)"
              ;;
            paused)
              STATUS="⏸️ Paused (blocking issues)"
              ;;
            failure)
              STATUS="❌ Failed"
              ;;
            skipped)
              SKIP_REASON="${{ needs.setup-and-plan.outputs.skip_reason }}"
              case "$SKIP_REASON" in
                already_executed) STATUS="⏭️ Skipped (already executed)" ;;
                deps_unmet) STATUS="🚧 Blocked (unmet dependencies)" ;;
                *) STATUS="⏭️ Skipped ($SKIP_REASON)" ;;
              esac
              ;;
            *)
              STATUS="⚠️ $OUTCOME"
              ;;
          esac

          RUN_URL="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"

          # Get parsed result data
          TASKS_COMPLETED="${{ steps.parse-results.outputs.tasks_completed }}"
          TASKS_TOTAL="${{ steps.parse-results.outputs.tasks_total }}"
          COMMITS_LIST="${{ steps.parse-results.outputs.commits_list }}"
          FILES_CHANGED="${{ steps.parse-results.outputs.files_changed }}"
          BLOCKING_ISSUES="${{ steps.parse-results.outputs.blocking_issues }}"
          REVIEW_NOTES="${{ steps.parse-results.outputs.review_notes }}"
          ERROR_SUMMARY="${{ steps.parse-results.outputs.error_summary }}"

          # Get pipeline stage info
          REVIEW_OUTCOME="${{ needs.review-plan.outputs.outcome }}"
          EXECUTE_STATUS="${{ needs.execute.outputs.status }}"

          # Build enhanced message using heredoc for proper formatting
          BODY=$(cat <<EOF
          ## $STATUS

          **Plan:** \`$PLAN_FILENAME\`
          **Complexity:** $COMPLEXITY
          EOF
          )

          # Add execution details for success/partial outcomes
          if [ "$OUTCOME" = "success" ] || [ "$OUTCOME" = "partial" ]; then
            # Add tasks progress
            if [ "$TASKS_TOTAL" != "0" ] && [ -n "$TASKS_TOTAL" ]; then
              BODY="$BODY
          **Tasks:** $TASKS_COMPLETED/$TASKS_TOTAL completed"
            fi

            # Add commits
            if [ -n "$COMMITS_LIST" ]; then
              # Convert comma-separated to inline code format
              COMMITS_FORMATTED=$(echo "$COMMITS_LIST" | sed 's/,/`, `/g')
              BODY="$BODY
          **Commits:** \`$COMMITS_FORMATTED\`"
            fi

            # Add files changed
            if [ -n "$FILES_CHANGED" ]; then
              BODY="$BODY
          **Files:** $FILES_CHANGED"
            fi
          fi

          # Add failure details
          if [ "$OUTCOME" = "failure" ] || [ "$OUTCOME" = "partial" ]; then
            BODY="$BODY

          ### Failure Details"

            # Add which stage failed
            if [ "$REVIEW_OUTCOME" = "pause" ]; then
              BODY="$BODY
          **Failed at:** Review (blocking issues found)"
            elif [ -z "$EXECUTE_STATUS" ] || [ "$EXECUTE_STATUS" = "failed" ]; then
              BODY="$BODY
          **Failed at:** Execute"
            fi

            # Add error summary if available
            if [ -n "$ERROR_SUMMARY" ]; then
              BODY="$BODY
          **Error:** $ERROR_SUMMARY"
            fi

            # Add tasks progress for partial failures
            if [ "$TASKS_TOTAL" != "0" ] && [ -n "$TASKS_TOTAL" ]; then
              BODY="$BODY
          **Progress:** $TASKS_COMPLETED/$TASKS_TOTAL tasks completed before failure"
            fi
          fi

          # Add blocking issues for paused plans
          if [ "$OUTCOME" = "paused" ] && [ -n "$BLOCKING_ISSUES" ]; then
            BODY="$BODY

          ### Blocking Issues
          $BLOCKING_ISSUES"
          fi

          # Add review notes if available
          if [ -n "$REVIEW_NOTES" ] && [ "$OUTCOME" != "success" ]; then
            BODY="$BODY

          ### Review Notes
          $REVIEW_NOTES"
          fi

          # Add debug info section for non-success outcomes
          if [ "$OUTCOME" != "success" ] && [ "$OUTCOME" != "verified" ] && [ "$OUTCOME" != "skipped" ]; then
            BODY="$BODY

          ### Debug Info
          - **Artifacts:** \`execute-result\`, \`review-result\` (download from [workflow run]($RUN_URL))
          - **Result files:** \`.claude/skills/story-execution/ci-*.json\`"
          fi

          # Add footer
          BODY="$BODY

          ---
          **Time:** $(date -u +'%Y-%m-%d %H:%M:%S UTC')
          **Run:** [View Details]($RUN_URL)

          *Posted by [execute-stories workflow]($RUN_URL)*"

          echo "$BODY" | gh issue comment "$ISSUE_NUM" --body-file -
          echo "Posted to issue #$ISSUE_NUM"
