name: 4. Execute Story

on:
  schedule:
    - cron: '40 2 * * *'  # 2:40 AM UTC
    - cron: '40 3 * * *'  # 3:40 AM UTC
    - cron: '40 4 * * *'  # 4:40 AM UTC
  workflow_dispatch:

concurrency:
  group: daily-story-execution
  cancel-in-progress: false

permissions:
  contents: write
  issues: write
  pull-requests: write
  id-token: write

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PIPELINE VISUALIZATION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# This workflow uses 6 semantically meaningful stages:
#
#   setup-and-plan â†’ identify-plan â†’ review-plan â†’ decompose â†’ execute â†’ finalize
#
# Each stage has a clear purpose:
# - setup-and-plan: Find plan, validate deps, initialize state
# - identify-plan: Ensure plan has valid Story ID (match to database if missing)
# - review-plan: Critical review + verify implementation, decide proceed/pause/verified
# - decompose: Assess complexity, split if needed (Opus)
# - execute: Follow plan's TDD steps directly (Sonnet)
# - finalize: Archive, commit, report
#
# Note: verify-implementation was merged into review-plan via ci-review-plan command
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

jobs:
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # SETUP-AND-PLAN: Find plan, validate dependencies, initialize state
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  setup-and-plan:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      plan_selected: ${{ steps.select-plan.outputs.selected }}
      plan_path: ${{ steps.select-plan.outputs.path }}
      plan_filename: ${{ steps.select-plan.outputs.filename }}
      plan_sequence: ${{ steps.select-plan.outputs.sequence }}
      story_id: ${{ steps.extract-story.outputs.story_id }}
      should_execute: ${{ steps.determine.outputs.should_execute }}
      skip_reason: ${{ steps.determine.outputs.skip_reason }}
      current_stage: ${{ steps.check-executed.outputs.current_stage }}

    steps:
      # â”€â”€ PHASE 1: SETUP â”€â”€
      - name: "1.1 Checkout repository"
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      # â”€â”€ PHASE 2: PLAN SELECTION â”€â”€
      - name: "2.1 Find available plans"
        id: find-plans
        run: |
          echo "## Plan Discovery" >> $GITHUB_STEP_SUMMARY

          PLANS_DIR=".claude/data/plans"
          if [ ! -d "$PLANS_DIR" ]; then
            echo "plans_found=0" >> $GITHUB_OUTPUT
            echo "âŒ Plans directory not found: $PLANS_DIR" >> $GITHUB_STEP_SUMMARY
            exit 0
          fi

          PLAN_COUNT=$(find "$PLANS_DIR" -maxdepth 1 -name "*.md" -type f | wc -l)
          echo "plans_found=$PLAN_COUNT" >> $GITHUB_OUTPUT
          echo "Found **$PLAN_COUNT** plan files in $PLANS_DIR" >> $GITHUB_STEP_SUMMARY

          if [ "$PLAN_COUNT" -gt 0 ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| Plan File | Sequence |" >> $GITHUB_STEP_SUMMARY
            echo "|-----------|----------|" >> $GITHUB_STEP_SUMMARY
            for f in $(ls -1 "$PLANS_DIR"/*.md 2>/dev/null | head -10); do
              FNAME=$(basename "$f")
              SEQ=$(echo "$FNAME" | grep -oP '^\d{3}([A-Z](\d+([a-z](\d+)?)?)?)?' || echo "?")
              echo "| $FNAME | $SEQ |" >> $GITHUB_STEP_SUMMARY
            done
          fi

      - name: "2.2 Select earliest plan"
        id: select-plan
        if: steps.find-plans.outputs.plans_found != '0'
        run: |
          python3 << 'PYEOF'
          import os, re

          plans_dir = '.claude/data/plans'
          pattern = re.compile(r'^(\d{3})([A-Z])?(\d+)?([a-z])?(\d+)?_(.+)\.md$')

          def parse_hierarchy(filename):
              """Parse hierarchical prefix into sortable tuple."""
              m = pattern.match(filename)
              if not m:
                  return None
              seq = int(m.group(1))
              letter = m.group(2) or ''
              num1 = int(m.group(3)) if m.group(3) else 0
              lower = m.group(4) or ''
              num2 = int(m.group(5)) if m.group(5) else 0
              prefix = str(seq) + letter + (str(num1) if num1 else '') + lower + (str(num2) if num2 else '')
              return {
                  'sort_key': (seq, letter, num1, lower, num2),
                  'prefix': prefix
              }

          plans = []
          for f in os.listdir(plans_dir):
              path = os.path.join(plans_dir, f)
              if os.path.isfile(path) and f.endswith('.md'):
                  parsed = parse_hierarchy(f)
                  if parsed:
                      plans.append({
                          'filename': f,
                          'path': path,
                          'sort_key': parsed['sort_key'],
                          'prefix': parsed['prefix'],
                      })

          plans.sort(key=lambda x: (x['sort_key'], x['filename']))

          if plans:
              selected = plans[0]
              with open(os.environ['GITHUB_OUTPUT'], 'a') as out:
                  out.write(f"selected=true\n")
                  out.write(f"filename={selected['filename']}\n")
                  out.write(f"path={selected['path']}\n")
                  out.write(f"sequence={selected['prefix']}\n")
              print(f"Selected: {selected['filename']}")
          else:
              with open(os.environ['GITHUB_OUTPUT'], 'a') as out:
                  out.write("selected=false\n")
              print("No valid plan files found")
          PYEOF

      - name: "2.3 Extract Story ID from plan"
        id: extract-story
        if: steps.select-plan.outputs.selected == 'true'
        run: |
          PLAN_PATH="${{ steps.select-plan.outputs.path }}"

          STORY_ID=$(grep -oP 'Story ID[:\s]*\K\d+(\.\d+)*' "$PLAN_PATH" | head -1)

          if [ -z "$STORY_ID" ]; then
            STORY_ID=$(grep -oP '\*\*Story ID:\*\*\s*\K\d+(\.\d+)*' "$PLAN_PATH" | head -1)
          fi

          echo "story_id=${STORY_ID:-none}" >> $GITHUB_OUTPUT
          echo "Story ID: ${STORY_ID:-'(not found)'}"

      # â”€â”€ PHASE 3: VALIDATION â”€â”€
      - name: "3.1 Check if story already executed"
        id: check-executed
        if: steps.select-plan.outputs.selected == 'true' && steps.extract-story.outputs.story_id != 'none'
        run: |
          STORY_ID="${{ steps.extract-story.outputs.story_id }}"
          DB_PATH=".claude/data/story-tree.db"

          if [ ! -f "$DB_PATH" ]; then
            echo "already_executed=false" >> $GITHUB_OUTPUT
            echo "Database not found, assuming not executed"
            exit 0
          fi

          STAGE=$(python3 -c "
          import sqlite3
          conn = sqlite3.connect('$DB_PATH')
          r = conn.execute('SELECT stage FROM story_nodes WHERE id = ?', ('$STORY_ID',)).fetchone()
          print(r[0] if r else 'unknown')
          conn.close()
          ")

          echo "Current stage: $STAGE"

          case "$STAGE" in
            reviewing|verifying|implemented|ready|polish|released)
              echo "already_executed=true" >> $GITHUB_OUTPUT
              echo "current_stage=$STAGE" >> $GITHUB_OUTPUT
              echo "âš ï¸ Story $STORY_ID already at stage: $STAGE"
              ;;
            *)
              echo "already_executed=false" >> $GITHUB_OUTPUT
              echo "current_stage=$STAGE" >> $GITHUB_OUTPUT
              echo "âœ“ Story $STORY_ID ready for execution (stage: $STAGE)"
              ;;
          esac

      - name: "3.2 Check story dependencies"
        id: check-deps
        if: steps.select-plan.outputs.selected == 'true' && steps.check-executed.outputs.already_executed != 'true'
        run: |
          STORY_ID="${{ steps.extract-story.outputs.story_id }}"
          PLAN_PATH="${{ steps.select-plan.outputs.path }}"
          DB_PATH=".claude/data/story-tree.db"

          if [ "$STORY_ID" = "none" ] || [ ! -f "$DB_PATH" ]; then
            echo "deps_met=true" >> $GITHUB_OUTPUT
            echo "No Story ID or database, skipping dependency check"
            exit 0
          fi

          python3 << PYEOF
          import sqlite3, re, os

          story_id = "$STORY_ID"
          db_path = "$DB_PATH"
          plan_path = "$PLAN_PATH"

          conn = sqlite3.connect(db_path)

          result = conn.execute('SELECT description, notes FROM story_nodes WHERE id = ?', (story_id,)).fetchone()
          if not result:
              with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                  f.write("deps_met=true\n")
              print("Story not in database, proceeding")
              exit(0)

          text = (result[0] or '') + ' ' + (result[1] or '')

          with open(plan_path, 'r') as f:
              text += ' ' + f.read()

          dep_pattern = r'(?:depends on|requires|after|blocked by)\s+(\d+(?:\.\d+)*)'
          deps = set(re.findall(dep_pattern, text, re.IGNORECASE))
          deps.discard(story_id)

          if not deps:
              with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                  f.write("deps_met=true\n")
              print("No dependencies found")
              exit(0)

          IMPLEMENTED = ('implemented', 'ready', 'polish', 'released')
          unmet = []
          for dep_id in deps:
              r = conn.execute('SELECT stage FROM story_nodes WHERE id = ? AND disposition IS NULL', (dep_id,)).fetchone()
              if r and r[0] not in IMPLEMENTED:
                  unmet.append(f"{dep_id} ({r[0]})")

          conn.close()

          if unmet:
              with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                  f.write("deps_met=false\n")
                  f.write(f"unmet_deps={', '.join(unmet)}\n")
              print(f"âŒ Unmet dependencies: {', '.join(unmet)}")
          else:
              with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                  f.write("deps_met=true\n")
              print("âœ“ All dependencies met")
          PYEOF

      # â”€â”€ PHASE 4: HANDLE SKIP CONDITIONS â”€â”€
      - name: "4.1 Move blocked plan to blocked folder"
        if: steps.check-deps.outputs.deps_met == 'false'
        run: |
          PLAN_PATH="${{ steps.select-plan.outputs.path }}"
          FILENAME="${{ steps.select-plan.outputs.filename }}"
          BLOCKED_DIR=".claude/data/plans/blocked"
          UNMET="${{ steps.check-deps.outputs.unmet_deps }}"

          git fetch origin main
          git rebase origin/main || git rebase --abort

          mkdir -p "$BLOCKED_DIR"
          mv "$PLAN_PATH" "$BLOCKED_DIR/"
          echo "Moved blocked plan: $FILENAME â†’ $BLOCKED_DIR/"
          echo "Unmet dependencies: $UNMET"

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add -A
          git commit -m "ci: move blocked plan $FILENAME (deps: $UNMET)"

          for attempt in 1 2 3 4; do
            if git push origin main; then
              echo "âœ“ Push successful"
              exit 0
            else
              echo "Push failed (attempt $attempt), pulling and retrying..."
              git pull --rebase origin main || true
              sleep $((2 ** attempt))
            fi
          done
          echo "âŒ Push failed after 4 attempts"
          exit 1

      # â”€â”€ DETERMINE IF EXECUTION SHOULD PROCEED â”€â”€
      - name: "4.2 Determine execution eligibility"
        id: determine
        run: |
          SELECTED="${{ steps.select-plan.outputs.selected }}"
          ALREADY_EXECUTED="${{ steps.check-executed.outputs.already_executed }}"
          CURRENT_STAGE="${{ steps.check-executed.outputs.current_stage }}"
          DEPS_MET="${{ steps.check-deps.outputs.deps_met }}"

          if [ "$SELECTED" != "true" ]; then
            echo "should_execute=false" >> $GITHUB_OUTPUT
            echo "skip_reason=no_plans" >> $GITHUB_OUTPUT
          elif [ "$ALREADY_EXECUTED" = "true" ]; then
            # Story stage indicates execution but plan still exists - needs review
            echo "should_execute=true" >> $GITHUB_OUTPUT
            echo "skip_reason=" >> $GITHUB_OUTPUT
            echo "âš ï¸ Plan exists but story at stage '$CURRENT_STAGE' - review will verify"
          elif [ "$DEPS_MET" = "false" ]; then
            echo "should_execute=false" >> $GITHUB_OUTPUT
            echo "skip_reason=deps_unmet" >> $GITHUB_OUTPUT
          else
            echo "should_execute=true" >> $GITHUB_OUTPUT
            echo "skip_reason=" >> $GITHUB_OUTPUT
          fi

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # IDENTIFY-PLAN: Ensure plan has valid Story ID (match to database if missing)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  identify-plan:
    needs: setup-and-plan
    if: needs.setup-and-plan.outputs.plan_selected == 'true' && needs.setup-and-plan.outputs.story_id == 'none'
    runs-on: ubuntu-latest
    timeout-minutes: 15
    outputs:
      story_id: ${{ steps.identify-output.outputs.story_id }}
      validation_passed: ${{ steps.identify-output.outputs.validation_passed }}
      plan_blocked: ${{ steps.identify-output.outputs.plan_blocked }}

    steps:
      - name: "IP.1 Checkout repository"
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: "IP.2 Match plan to story in database"
        id: identify
        uses: anthropics/claude-code-action@v1
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          show_full_output: true
          prompt: /ci-identify-plan ${{ needs.setup-and-plan.outputs.plan_path }}
          claude_args: |
            --allowedTools "Read,Write,Edit,Glob,Grep,Bash(python:*),Bash(python3:*),Bash(sqlite3:*)"
            --model claude-sonnet-4-5-20250929
            --max-turns 20

      - name: "IP.3 Read identification output"
        id: identify-output
        if: always()
        run: |
          RESULT_FILE=".claude/skills/story-execution/ci-identify-result.json"

          # Fallback: Claude sometimes writes to wrong filename
          if [ ! -f "$RESULT_FILE" ] && [ -f ".claude/skills/story-execution/ci-validate-result.json" ]; then
            echo "âš ï¸ Claude wrote to wrong filename (ci-validate-result.json), using fallback"
            RESULT_FILE=".claude/skills/story-execution/ci-validate-result.json"
          fi

          if [ -f "$RESULT_FILE" ]; then
            PASSED=$(python3 -c "import json; d=json.load(open('$RESULT_FILE')); print(str(d.get('validation_passed', False)).lower())")
            STORY_ID=$(python3 -c "import json; d=json.load(open('$RESULT_FILE')); print(d.get('story_id') or 'none')")
            PLAN_UPDATED=$(python3 -c "import json; d=json.load(open('$RESULT_FILE')); print(str(d.get('plan_updated', False)).lower())")

            echo "validation_passed=$PASSED" >> $GITHUB_OUTPUT
            echo "story_id=$STORY_ID" >> $GITHUB_OUTPUT

            if [ "$PASSED" = "true" ]; then
              echo "plan_blocked=false" >> $GITHUB_OUTPUT
              echo "âœ“ Identification passed - Story ID: $STORY_ID"
            else
              echo "plan_blocked=true" >> $GITHUB_OUTPUT
              echo "âš ï¸ Identification failed - plan will be blocked"
            fi

            echo "## Plan Identification" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| Field | Value |" >> $GITHUB_STEP_SUMMARY
            echo "|-------|-------|" >> $GITHUB_STEP_SUMMARY
            echo "| Passed | $PASSED |" >> $GITHUB_STEP_SUMMARY
            echo "| Story ID | $STORY_ID |" >> $GITHUB_STEP_SUMMARY
            echo "| Plan Updated | $PLAN_UPDATED |" >> $GITHUB_STEP_SUMMARY
          else
            echo "validation_passed=false" >> $GITHUB_OUTPUT
            echo "story_id=none" >> $GITHUB_OUTPUT
            echo "plan_blocked=true" >> $GITHUB_OUTPUT
            echo "âš ï¸ Identification result file not found"
          fi

      - name: "IP.4 Commit plan update if Story ID was added"
        if: steps.identify-output.outputs.validation_passed == 'true'
        run: |
          git fetch origin main
          git rebase origin/main || git rebase --abort

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add -A

          if ! git diff --cached --quiet; then
            PLAN_FILENAME="${{ needs.setup-and-plan.outputs.plan_filename }}"
            STORY_ID="${{ steps.identify-output.outputs.story_id }}"

            git commit -m "ci: add Story ID $STORY_ID to plan $PLAN_FILENAME

            Matched plan to story via content analysis"

            for attempt in 1 2 3 4; do
              if git push origin main; then
                echo "âœ“ Pushed plan update with Story ID"
                exit 0
              else
                echo "Push failed (attempt $attempt), pulling and retrying..."
                git pull --rebase origin main || true
                sleep $((2 ** attempt))
              fi
            done
            echo "âŒ Push failed after 4 attempts"
            exit 1
          else
            echo "No changes to commit (Story ID may have already been present)"
          fi

      - name: "IP.5 Move blocked plan if no Story ID found"
        if: steps.identify-output.outputs.plan_blocked == 'true'
        run: |
          PLAN_PATH="${{ needs.setup-and-plan.outputs.plan_path }}"
          FILENAME="${{ needs.setup-and-plan.outputs.plan_filename }}"
          BLOCKED_DIR=".claude/data/plans/blocked"

          git fetch origin main
          git rebase origin/main || git rebase --abort

          mkdir -p "$BLOCKED_DIR"
          mv "$PLAN_PATH" "$BLOCKED_DIR/"
          echo "Moved plan without Story ID: $FILENAME â†’ $BLOCKED_DIR/"

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add -A
          git commit -m "ci: block plan $FILENAME (no matching Story ID found)

          Plan moved to blocked folder - requires manual Story ID assignment"

          for attempt in 1 2 3 4; do
            if git push origin main; then
              echo "âœ“ Push successful"
              exit 0
            else
              echo "Push failed (attempt $attempt), pulling and retrying..."
              git pull --rebase origin main || true
              sleep $((2 ** attempt))
            fi
          done
          echo "âŒ Push failed after 4 attempts"
          exit 1

      - name: "IP.6 Upload identification result"
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: identify-result
          path: .claude/skills/story-execution/ci-identify-result.json
          retention-days: 1
          if-no-files-found: ignore

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # REVIEW-PLAN: Critical review + verify implementation, decide outcome
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  review-plan:
    needs: [setup-and-plan, identify-plan]
    if: |
      always() &&
      needs.identify-plan.outputs.plan_blocked != 'true' &&
      needs.setup-and-plan.outputs.should_execute == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 15
    outputs:
      outcome: ${{ steps.review-output.outputs.outcome }}
      review_completed: ${{ steps.review-output.outputs.review_completed }}

    steps:
      - name: "RP.1 Checkout repository"
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: "RP.2 Pull latest changes"
        run: |
          git pull origin main --rebase || true

      - name: "RP.3 Clean up Claude installation locks"
        run: |
          rm -rf /tmp/claude-* 2>/dev/null || true
          rm -rf ~/.claude-install* 2>/dev/null || true
          rm -rf ~/.npm/_locks/* 2>/dev/null || true
          pkill -f "claude" 2>/dev/null || true
          echo "âœ“ Cleaned up potential installation locks"

      - name: "RP.4 Review plan critically"
        id: review
        uses: anthropics/claude-code-action@v1
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          show_full_output: true
          prompt: /ci-review-plan ${{ needs.setup-and-plan.outputs.plan_path }}
          claude_args: |
            --allowedTools "Read,Write,Edit,Glob,Grep,Bash(python:*),Bash(python3:*),Bash(mkdir:*)"
            --model claude-sonnet-4-5-20250929
            --max-turns 25

      - name: "RP.5 Read review output"
        id: review-output
        if: always()
        run: |
          RESULT_FILE=".claude/skills/story-execution/ci-review-result.json"
          if [ -f "$RESULT_FILE" ]; then
            OUTCOME=$(python3 -c "import json; d=json.load(open('$RESULT_FILE')); print(d.get('outcome','unknown'))")
            if [ "$OUTCOME" = "proceed" ] || [ "$OUTCOME" = "proceed_with_review" ] || [ "$OUTCOME" = "pause" ] || [ "$OUTCOME" = "verified" ]; then
              echo "outcome=$OUTCOME" >> $GITHUB_OUTPUT
              echo "review_completed=true" >> $GITHUB_OUTPUT
              echo "Review outcome: $OUTCOME"
            else
              echo "outcome=failed" >> $GITHUB_OUTPUT
              echo "review_completed=false" >> $GITHUB_OUTPUT
              echo "Review not completed - outcome: $OUTCOME"
            fi
          else
            echo "outcome=failed" >> $GITHUB_OUTPUT
            echo "review_completed=false" >> $GITHUB_OUTPUT
            echo "Result file not found"
          fi

      - name: "RP.6 Archive plan if already implemented"
        if: steps.review-output.outputs.outcome == 'verified'
        run: |
          PLAN_PATH="${{ needs.setup-and-plan.outputs.plan_path }}"
          FILENAME="${{ needs.setup-and-plan.outputs.plan_filename }}"
          ARCHIVE_DIR=".claude/data/plans/executed"

          git fetch origin main
          git rebase origin/main || git rebase --abort

          mkdir -p "$ARCHIVE_DIR"
          mv "$PLAN_PATH" "$ARCHIVE_DIR/"
          echo "âœ“ Implementation verified - archived plan: $FILENAME â†’ $ARCHIVE_DIR/"

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add -A
          git commit -m "ci: archive verified plan $FILENAME

          Story: ${{ needs.identify-plan.outputs.story_id || needs.setup-and-plan.outputs.story_id }}
          Verification: Implementation confirmed in codebase"

          for attempt in 1 2 3 4; do
            if git push origin main; then
              echo "âœ“ Push successful"
              exit 0
            else
              echo "Push failed (attempt $attempt), pulling and retrying..."
              git pull --rebase origin main || true
              sleep $((2 ** attempt))
            fi
          done
          echo "âŒ Push failed after 4 attempts"
          exit 1

      - name: "RP.7 Upload review result"
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: review-result
          path: .claude/skills/story-execution/ci-review-result.json
          retention-days: 1
          if-no-files-found: ignore

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # DECOMPOSE: Assess complexity, split into sub-plans if needed (Opus)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  decompose:
    needs: [setup-and-plan, identify-plan, review-plan]
    if: |
      always() &&
      needs.review-plan.outputs.review_completed == 'true' &&
      (needs.review-plan.outputs.outcome == 'proceed' || needs.review-plan.outputs.outcome == 'proceed_with_review')
    runs-on: ubuntu-latest
    timeout-minutes: 20
    outputs:
      complexity: ${{ steps.decompose-output.outputs.complexity }}
      execute_plan: ${{ steps.decompose-output.outputs.execute_plan }}
      sub_plans_created: ${{ steps.decompose-output.outputs.sub_plans_created }}

    steps:
      - name: "DC.1 Checkout repository"
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: "DC.2 Clean up Claude installation locks"
        run: |
          rm -rf /tmp/claude-* 2>/dev/null || true
          rm -rf ~/.claude-install* 2>/dev/null || true
          rm -rf ~/.npm/_locks/* 2>/dev/null || true
          pkill -f "claude" 2>/dev/null || true
          echo "âœ“ Cleaned up potential installation locks"

      - name: "DC.3 Assess plan complexity"
        id: decompose
        uses: anthropics/claude-code-action@v1
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          show_full_output: true
          prompt: /ci-decompose-plan ${{ needs.setup-and-plan.outputs.plan_path }}
          claude_args: |
            --allowedTools "Read,Write,Edit,Glob,Grep,Bash(python:*),Bash(python3:*),Bash(mkdir:*),Bash(mv:*),Bash(cp:*),Bash(ls:*)"
            --model claude-opus-4-5-20251101
            --max-turns 25

      - name: "DC.4 Read decompose output"
        id: decompose-output
        if: always()
        run: |
          RESULT_FILE=".claude/skills/story-execution/ci-decompose-result.json"
          PLAN_PATH="${{ needs.setup-and-plan.outputs.plan_path }}"

          if [ -f "$RESULT_FILE" ]; then
            COMPLEXITY=$(python3 -c "import json; d=json.load(open('$RESULT_FILE')); print(d.get('complexity','unknown'))")
            EXECUTE_PLAN=$(python3 -c "import json; d=json.load(open('$RESULT_FILE')); print(d.get('execute_plan',''))")
            SUB_PLANS=$(python3 -c "import json; d=json.load(open('$RESULT_FILE')); print(','.join(d.get('sub_plans_created',[])))")

            echo "Complexity: $COMPLEXITY"

            # Validate that the execute_plan file actually exists
            FINAL_PLAN="${EXECUTE_PLAN:-$PLAN_PATH}"
            if [ -n "$EXECUTE_PLAN" ] && [ ! -f "$EXECUTE_PLAN" ]; then
              echo "âš ï¸ WARNING: Decompose generated non-existent plan path: $EXECUTE_PLAN"
              echo ""
              echo "Available plans in .claude/data/plans/:"
              ls -1 .claude/data/plans/*.md 2>/dev/null || echo "(none)"
              echo ""

              PLAN_BASENAME=$(basename "$EXECUTE_PLAN" .md)
              PLAN_SEQ=$(echo "$PLAN_BASENAME" | grep -oP '^\d{3}([A-Z](\d+[a-z]?)?)?' || echo "")

              if [ -n "$PLAN_SEQ" ]; then
                echo "Looking for plans with sequence: $PLAN_SEQ"
                MATCHING_PLAN=$(ls -1 .claude/data/plans/${PLAN_SEQ}*.md 2>/dev/null | head -1)
                if [ -n "$MATCHING_PLAN" ] && [ -f "$MATCHING_PLAN" ]; then
                  echo "âœ“ Found matching plan: $MATCHING_PLAN"
                  FINAL_PLAN="$MATCHING_PLAN"
                fi
              fi

              if [ ! -f "$FINAL_PLAN" ]; then
                if [ -f "$PLAN_PATH" ]; then
                  echo "Falling back to original plan: $PLAN_PATH"
                  FINAL_PLAN="$PLAN_PATH"
                else
                  echo "âŒ ERROR: No valid plan found!"
                  EARLIEST=$(ls -1 .claude/data/plans/*.md 2>/dev/null | head -1)
                  if [ -n "$EARLIEST" ]; then
                    echo "âœ“ Re-selecting earliest plan: $EARLIEST"
                    FINAL_PLAN="$EARLIEST"
                  else
                    echo "decompose_failed=true" >> $GITHUB_OUTPUT
                    exit 1
                  fi
                fi
              fi
            fi

            echo "complexity=$COMPLEXITY" >> $GITHUB_OUTPUT
            echo "execute_plan=$FINAL_PLAN" >> $GITHUB_OUTPUT
            echo "sub_plans_created=$SUB_PLANS" >> $GITHUB_OUTPUT
            echo "decompose_failed=false" >> $GITHUB_OUTPUT

            echo "Execute plan: $FINAL_PLAN"
            if [ -n "$SUB_PLANS" ]; then
              echo "Sub-plans created: $SUB_PLANS"
            fi
          else
            echo "complexity=unknown" >> $GITHUB_OUTPUT
            echo "execute_plan=$PLAN_PATH" >> $GITHUB_OUTPUT
            echo "sub_plans_created=" >> $GITHUB_OUTPUT
            echo "decompose_failed=false" >> $GITHUB_OUTPUT
            echo "No decompose result, using original plan: $PLAN_PATH"
          fi

      - name: "DC.5 Commit sub-plans if created"
        if: steps.decompose-output.outputs.sub_plans_created != ''
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git add -A
          git pull --rebase --autostash origin main || true
          git add -A

          if ! git diff --cached --quiet; then
            STORY_ID="${{ needs.setup-and-plan.outputs.story_id }}"
            git commit -m "ci: decompose plan into sub-plans

            Story: $STORY_ID
            Complexity: ${{ steps.decompose-output.outputs.complexity }}
            Sub-plans: ${{ steps.decompose-output.outputs.sub_plans_created }}"

            for attempt in 1 2 3 4; do
              if git push origin main; then
                echo "âœ“ Committed and pushed sub-plans"
                exit 0
              else
                echo "Push failed (attempt $attempt), pulling and retrying..."
                git pull --rebase origin main || true
                sleep $((2 ** attempt))
              fi
            done
            echo "âŒ Push failed after 4 attempts"
            exit 1
          else
            echo "No changes to commit"
          fi

      - name: "DC.6 Upload decompose result"
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: decompose-result
          path: .claude/skills/story-execution/ci-decompose-result.json
          retention-days: 1
          if-no-files-found: ignore

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # EXECUTE: Follow plan's TDD steps directly (Sonnet)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  execute:
    needs: [setup-and-plan, identify-plan, review-plan, decompose]
    if: |
      always() &&
      needs.decompose.outputs.execute_plan != ''
    runs-on: ubuntu-latest
    timeout-minutes: 45
    outputs:
      status: ${{ steps.execute-output.outputs.status }}
      commits_made: ${{ steps.execute-output.outputs.commits_made }}
      complexity_ok: ${{ steps.verify-complexity.outputs.complexity_ok }}
      task_count: ${{ steps.verify-complexity.outputs.task_count }}

    steps:
      - name: "EX.1 Checkout repository"
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: "EX.2 Pull latest changes"
        run: |
          git pull origin main --rebase || true

      - name: "EX.3 Clean up Claude installation locks"
        run: |
          rm -rf /tmp/claude-* 2>/dev/null || true
          rm -rf ~/.claude-install* 2>/dev/null || true
          rm -rf ~/.npm/_locks/* 2>/dev/null || true
          pkill -f "claude" 2>/dev/null || true
          echo "âœ“ Cleaned up potential installation locks"

      - name: "EX.4 Verify plan file exists"
        id: verify-plan
        run: |
          PLAN_PATH="${{ needs.decompose.outputs.execute_plan }}"
          echo "Checking plan file: $PLAN_PATH"

          if [ -z "$PLAN_PATH" ]; then
            echo "âŒ No plan path provided by decompose job"
            echo "plan_exists=false" >> $GITHUB_OUTPUT
            exit 1
          fi

          if [ ! -f "$PLAN_PATH" ]; then
            echo "âŒ Plan file does not exist: $PLAN_PATH"
            echo ""
            echo "Available plans in .claude/data/plans/:"
            ls -la .claude/data/plans/*.md 2>/dev/null || echo "(none)"
            echo ""
            echo "plan_exists=false" >> $GITHUB_OUTPUT
            exit 1
          fi

          echo "âœ“ Plan file verified: $PLAN_PATH"
          echo "plan_exists=true" >> $GITHUB_OUTPUT

      - name: "EX.5 Verify plan complexity is simple"
        id: verify-complexity
        run: |
          PLAN_PATH="${{ needs.decompose.outputs.execute_plan }}"

          TASK_COUNT=$(grep -cE '^###\s+(Task|TDD Task|Step)\s+[0-9]+|^###\s+[0-9]+\.' "$PLAN_PATH" 2>/dev/null || true)
          TASK_COUNT=${TASK_COUNT:-0}

          echo "Plan: $PLAN_PATH"
          echo "Task count: $TASK_COUNT"

          if [ "$TASK_COUNT" -gt 2 ]; then
            echo ""
            echo "âš ï¸ WARNING: Plan has $TASK_COUNT tasks (max 2 for execution)"
            echo "This plan should have been decomposed further."
            echo ""
            echo "## âš ï¸ Plan Too Complex" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Plan \`$(basename $PLAN_PATH)\` has **$TASK_COUNT tasks** but max is 2." >> $GITHUB_STEP_SUMMARY

            echo "complexity_ok=false" >> $GITHUB_OUTPUT
            echo "task_count=$TASK_COUNT" >> $GITHUB_OUTPUT
            echo "Proceeding with execution despite complexity warning..."
          else
            echo "âœ“ Plan complexity OK: $TASK_COUNT tasks"
            echo "complexity_ok=true" >> $GITHUB_OUTPUT
            echo "task_count=$TASK_COUNT" >> $GITHUB_OUTPUT
          fi

      - name: "EX.6 Setup Python environment"
        run: |
          echo "Setting up Python environment..."
          python3 --version
          python3 -m pip install --upgrade pip
          python3 -m pip install pytest
          python3 -m pytest --version
          echo "âœ“ Python environment ready with pytest"

      - name: "EX.7 Execute plan"
        id: execute
        uses: anthropics/claude-code-action@v1
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          show_full_output: true
          prompt: /ci-execute-plan ${{ needs.decompose.outputs.execute_plan }}
          claude_args: |
            --allowedTools "Read,Write,Edit,Glob,Grep,Bash(git:*),Bash(python:*),Bash(python3:*),Bash(pytest:*),Bash(pip:*),Bash(pip3:*),Bash(mkdir:*),Bash(source:*),Bash(cat:*),Bash(ls:*),Bash(rm:*),Bash(chmod:*),BashOutput,TodoWrite"
            --model claude-sonnet-4-5-20250929
            --max-turns 50

      - name: "EX.8 Push implementation commits"
        if: always()
        run: |
          git fetch origin main
          COMMITS_AHEAD=$(git rev-list origin/main..HEAD --count 2>/dev/null || echo "0")

          if [ "$COMMITS_AHEAD" -gt 0 ]; then
            echo "Found $COMMITS_AHEAD commits to push"

            for attempt in 1 2 3 4; do
              if git push origin main; then
                echo "âœ“ Pushed $COMMITS_AHEAD implementation commits"
                exit 0
              else
                echo "Push failed (attempt $attempt), pulling and retrying..."
                git pull --rebase origin main || true
                sleep $((2 ** attempt))
              fi
            done
            echo "âŒ Push failed after 4 attempts"
            exit 1
          else
            echo "No commits to push"
          fi

      - name: "EX.9 Read execute output"
        id: execute-output
        if: always()
        run: |
          RESULT_FILE=".claude/skills/story-execution/ci-execute-result.json"

          if [ -f "$RESULT_FILE" ]; then
            STATUS=$(python3 -c "import json; d=json.load(open('$RESULT_FILE')); print(d.get('status','unknown'))")
            COMMITS=$(python3 -c "import json; d=json.load(open('$RESULT_FILE')); print(','.join(d.get('commits',[])))")
            COMPLETED=$(python3 -c "import json; d=json.load(open('$RESULT_FILE')); print(d.get('tasks_completed',0))")
            TOTAL=$(python3 -c "import json; d=json.load(open('$RESULT_FILE')); print(d.get('tasks_total',0))")

            echo "status=$STATUS" >> $GITHUB_OUTPUT
            echo "commits_made=$COMMITS" >> $GITHUB_OUTPUT

            echo "Status: $STATUS"
            echo "Tasks: $COMPLETED/$TOTAL"
            echo "Commits: $COMMITS"
          else
            UNCOMMITTED=$(git status --porcelain | wc -l)
            NEW_COMMITS=$(git log origin/main..HEAD --oneline 2>/dev/null | wc -l)

            if [ "$NEW_COMMITS" -gt 0 ] || [ "$UNCOMMITTED" -gt 0 ]; then
              echo "status=partial" >> $GITHUB_OUTPUT
              echo "commits_made=" >> $GITHUB_OUTPUT
              echo "No result file, but found $NEW_COMMITS new commits and $UNCOMMITTED uncommitted changes"
            else
              echo "status=failed" >> $GITHUB_OUTPUT
              echo "commits_made=" >> $GITHUB_OUTPUT
              echo "No result file and no changes detected"
            fi
          fi

      - name: "EX.10 Upload execute result"
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: execute-result
          path: .claude/skills/story-execution/ci-execute-result.json
          retention-days: 1
          if-no-files-found: ignore

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # FINALIZE: Archive, commit, push, report
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  finalize:
    needs: [setup-and-plan, identify-plan, review-plan, decompose, execute]
    if: always()
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: "FN.1 Checkout repository"
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: "FN.2 Pull latest changes"
        run: |
          git pull origin main --rebase || true

      - name: "FN.3 Determine final outcome"
        id: outcome
        run: |
          SHOULD_EXECUTE="${{ needs.setup-and-plan.outputs.should_execute }}"
          SKIP_REASON="${{ needs.setup-and-plan.outputs.skip_reason }}"
          PLAN_BLOCKED="${{ needs.identify-plan.outputs.plan_blocked }}"

          # Handle identify-plan blocking the plan (no Story ID found)
          if [ "$PLAN_BLOCKED" = "true" ]; then
            echo "outcome=blocked" >> $GITHUB_OUTPUT
            echo "reason=no_story_id" >> $GITHUB_OUTPUT
            exit 0
          fi

          # If setup determined we shouldn't execute
          if [ "$SHOULD_EXECUTE" != "true" ]; then
            echo "outcome=skipped" >> $GITHUB_OUTPUT
            echo "reason=$SKIP_REASON" >> $GITHUB_OUTPUT
            exit 0
          fi

          REVIEW_COMPLETED="${{ needs.review-plan.outputs.review_completed }}"
          if [ "$REVIEW_COMPLETED" != "true" ]; then
            echo "outcome=failure" >> $GITHUB_OUTPUT
            echo "reason=review_failed" >> $GITHUB_OUTPUT
            exit 0
          fi

          REVIEW_OUTCOME="${{ needs.review-plan.outputs.outcome }}"

          # Handle review returning "verified" (already implemented)
          if [ "$REVIEW_OUTCOME" = "verified" ]; then
            echo "outcome=verified" >> $GITHUB_OUTPUT
            echo "reason=already_implemented" >> $GITHUB_OUTPUT
            exit 0
          fi

          if [ "$REVIEW_OUTCOME" = "pause" ]; then
            echo "outcome=paused" >> $GITHUB_OUTPUT
            echo "reason=blocking_issues" >> $GITHUB_OUTPUT
            exit 0
          fi

          EXECUTE_STATUS="${{ needs.execute.outputs.status }}"
          case "$EXECUTE_STATUS" in
            completed)
              if [ "$REVIEW_OUTCOME" = "proceed_with_review" ]; then
                echo "outcome=success" >> $GITHUB_OUTPUT
                echo "needs_review=true" >> $GITHUB_OUTPUT
              else
                echo "outcome=success" >> $GITHUB_OUTPUT
                echo "needs_review=false" >> $GITHUB_OUTPUT
              fi
              ;;
            partial)
              echo "outcome=partial" >> $GITHUB_OUTPUT
              echo "needs_review=true" >> $GITHUB_OUTPUT
              ;;
            failed|"")
              echo "outcome=failure" >> $GITHUB_OUTPUT
              echo "reason=execution_failed" >> $GITHUB_OUTPUT
              ;;
            *)
              echo "outcome=unknown" >> $GITHUB_OUTPUT
              echo "reason=unknown_status" >> $GITHUB_OUTPUT
              ;;
          esac

      - name: "FN.4 Archive executed plan"
        if: steps.outcome.outputs.outcome == 'success'
        run: |
          EXECUTE_PLAN="${{ needs.decompose.outputs.execute_plan }}"
          if [ -z "$EXECUTE_PLAN" ]; then
            EXECUTE_PLAN="${{ needs.setup-and-plan.outputs.plan_path }}"
          fi
          ARCHIVE_DIR=".claude/data/plans/executed"

          if [ -f "$EXECUTE_PLAN" ]; then
            mkdir -p "$ARCHIVE_DIR"
            mv "$EXECUTE_PLAN" "$ARCHIVE_DIR/"
            echo "âœ“ Archived: $EXECUTE_PLAN â†’ $ARCHIVE_DIR/"
          else
            echo "Plan already archived or moved"
          fi

      - name: "FN.5 Update story status in database"
        if: |
          (steps.outcome.outputs.outcome == 'success' ||
           steps.outcome.outputs.outcome == 'partial' ||
           steps.outcome.outputs.outcome == 'verified') &&
          (needs.identify-plan.outputs.story_id != 'none' || needs.setup-and-plan.outputs.story_id != 'none')
        run: |
          STORY_ID="${{ needs.identify-plan.outputs.story_id }}"
          if [ -z "$STORY_ID" ] || [ "$STORY_ID" = "none" ]; then
            STORY_ID="${{ needs.setup-and-plan.outputs.story_id }}"
          fi

          if [ -z "$STORY_ID" ] || [ "$STORY_ID" = "none" ]; then
            echo "No Story ID available, skipping database update"
            exit 0
          fi

          DB_PATH=".claude/data/story-tree.db"
          NEEDS_REVIEW="${{ steps.outcome.outputs.needs_review }}"
          OUTCOME="${{ steps.outcome.outputs.outcome }}"

          if [ ! -f "$DB_PATH" ]; then
            echo "Database not found, skipping status update"
            exit 0
          fi

          if [ "$OUTCOME" = "verified" ]; then
            STAGE="implemented"
            NOTE="CI verified: implementation already exists"
            REVIEW_FLAG=0
          elif [ "$NEEDS_REVIEW" = "true" ]; then
            STAGE="reviewing"
            NOTE="CI execution $OUTCOME (review required)"
            REVIEW_FLAG=1
          else
            STAGE="verifying"
            NOTE="CI execution complete"
            REVIEW_FLAG=0
          fi

          python3 << PYEOF
          import sqlite3
          conn = sqlite3.connect("$DB_PATH")
          conn.execute('''
              UPDATE story_nodes
              SET stage = '$STAGE',
                  human_review = $REVIEW_FLAG,
                  notes = COALESCE(notes || char(10), '') || '$NOTE: ' || datetime('now'),
                  updated_at = datetime('now')
              WHERE id = ?
          ''', ("$STORY_ID",))
          conn.commit()
          print(f"âœ“ Updated story $STORY_ID â†’ $STAGE")
          conn.close()
          PYEOF

      - name: "FN.6 Stage all changes"
        if: steps.outcome.outputs.outcome == 'success' || steps.outcome.outputs.outcome == 'partial' || steps.outcome.outputs.outcome == 'verified'
        id: stage
        run: |
          git add -A
          if git diff --cached --quiet; then
            echo "has_changes=false" >> $GITHUB_OUTPUT
            echo "No changes to commit"
          else
            echo "has_changes=true" >> $GITHUB_OUTPUT
            echo "Changes staged for commit:"
            git diff --cached --stat
          fi

      - name: "FN.7 Commit changes"
        if: steps.stage.outputs.has_changes == 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          EXECUTE_PLAN="${{ needs.decompose.outputs.execute_plan }}"
          STORY_ID="${{ needs.setup-and-plan.outputs.story_id }}"
          PLAN_FILENAME=$(basename "$EXECUTE_PLAN")

          git commit -m "ci: execute plan $PLAN_FILENAME

          Story: $STORY_ID"

          echo "âœ“ Committed changes"

      - name: "FN.8 Push to remote"
        if: steps.stage.outputs.has_changes == 'true'
        run: |
          for attempt in 1 2 3 4; do
            if git push origin main; then
              echo "âœ“ Push successful"
              exit 0
            else
              echo "Push failed (attempt $attempt), pulling and retrying..."
              git pull --rebase origin main || true
              sleep $((2 ** attempt))
            fi
          done
          echo "âŒ Push failed after 4 attempts"
          exit 1

      # â”€â”€ REPORTING â”€â”€
      - name: "FN.9 Generate execution summary"
        if: always()
        run: |
          echo "## Execution Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          PLAN_SELECTED="${{ needs.setup-and-plan.outputs.plan_selected }}"
          if [ "$PLAN_SELECTED" = "true" ]; then
            echo "| Field | Value |" >> $GITHUB_STEP_SUMMARY
            echo "|-------|-------|" >> $GITHUB_STEP_SUMMARY
            echo "| Plan | \`${{ needs.setup-and-plan.outputs.plan_filename }}\` |" >> $GITHUB_STEP_SUMMARY
            echo "| Sequence | ${{ needs.setup-and-plan.outputs.plan_sequence }} |" >> $GITHUB_STEP_SUMMARY
            echo "| Story ID | ${{ needs.setup-and-plan.outputs.story_id }} |" >> $GITHUB_STEP_SUMMARY
            echo "| Complexity | ${{ needs.decompose.outputs.complexity }} |" >> $GITHUB_STEP_SUMMARY

            OUTCOME="${{ steps.outcome.outputs.outcome }}"
            case "$OUTCOME" in
              success)
                if [ "${{ steps.outcome.outputs.needs_review }}" = "true" ]; then
                  echo "| Outcome | âœ… Success (review required) |" >> $GITHUB_STEP_SUMMARY
                else
                  echo "| Outcome | âœ… Success |" >> $GITHUB_STEP_SUMMARY
                fi
                ;;
              verified)
                echo "| Outcome | âœ… Verified (already implemented) |" >> $GITHUB_STEP_SUMMARY
                ;;
              blocked)
                echo "| Outcome | ðŸš« Blocked (no Story ID found) |" >> $GITHUB_STEP_SUMMARY
                ;;
              partial)
                echo "| Outcome | âš ï¸ Partial (review required) |" >> $GITHUB_STEP_SUMMARY
                ;;
              paused)
                echo "| Outcome | â¸ï¸ Paused (blocking issues) |" >> $GITHUB_STEP_SUMMARY
                ;;
              failure)
                echo "| Outcome | âŒ Failed |" >> $GITHUB_STEP_SUMMARY
                echo "| Reason | ${{ steps.outcome.outputs.reason }} |" >> $GITHUB_STEP_SUMMARY
                ;;
              skipped)
                SKIP_REASON="${{ needs.setup-and-plan.outputs.skip_reason }}"
                case "$SKIP_REASON" in
                  deps_unmet)
                    echo "| Outcome | ðŸš§ Blocked (unmet deps) |" >> $GITHUB_STEP_SUMMARY
                    ;;
                  *)
                    echo "| Outcome | â­ï¸ Skipped ($SKIP_REASON) |" >> $GITHUB_STEP_SUMMARY
                    ;;
                esac
                ;;
              *)
                echo "| Outcome | âš ï¸ Unknown |" >> $GITHUB_STEP_SUMMARY
                ;;
            esac
          else
            echo "No plan files available for execution." >> $GITHUB_STEP_SUMMARY
          fi

      - name: "FN.10 Report pipeline status"
        if: always() && needs.setup-and-plan.outputs.plan_selected == 'true'
        run: |
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Pipeline Stages" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Stage | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| setup-and-plan | âœ… |" >> $GITHUB_STEP_SUMMARY

          STORY_ID="${{ needs.setup-and-plan.outputs.story_id }}"
          if [ "$STORY_ID" = "none" ]; then
            PLAN_BLOCKED="${{ needs.identify-plan.outputs.plan_blocked }}"
            IDENTIFIED_STORY_ID="${{ needs.identify-plan.outputs.story_id }}"
            if [ "$PLAN_BLOCKED" = "true" ]; then
              echo "| identify-plan | ðŸš« blocked (no match) |" >> $GITHUB_STEP_SUMMARY
            elif [ -n "$IDENTIFIED_STORY_ID" ] && [ "$IDENTIFIED_STORY_ID" != "none" ]; then
              echo "| identify-plan | âœ… matched ($IDENTIFIED_STORY_ID) |" >> $GITHUB_STEP_SUMMARY
            else
              echo "| identify-plan | â­ï¸ skipped |" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "| identify-plan | â­ï¸ skipped (has ID) |" >> $GITHUB_STEP_SUMMARY
          fi

          REVIEW="${{ needs.review-plan.outputs.outcome }}"
          if [ -n "$REVIEW" ]; then
            echo "| review-plan | $REVIEW |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| review-plan | â­ï¸ skipped |" >> $GITHUB_STEP_SUMMARY
          fi

          COMPLEXITY="${{ needs.decompose.outputs.complexity }}"
          if [ -n "$COMPLEXITY" ]; then
            echo "| decompose | $COMPLEXITY |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| decompose | â­ï¸ skipped |" >> $GITHUB_STEP_SUMMARY
          fi

          EXECUTE="${{ needs.execute.outputs.status }}"
          if [ -n "$EXECUTE" ]; then
            echo "| execute | $EXECUTE |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| execute | â­ï¸ skipped |" >> $GITHUB_STEP_SUMMARY
          fi

          echo "| finalize | ${{ steps.outcome.outputs.outcome }} |" >> $GITHUB_STEP_SUMMARY

      - name: "FN.11 Download result artifacts"
        if: always()
        uses: actions/download-artifact@v4
        with:
          path: /tmp/artifacts
          merge-multiple: true
        continue-on-error: true

      - name: "FN.12 Parse result files for issue message"
        id: parse-results
        if: always()
        run: |
          echo "tasks_completed=0" >> $GITHUB_OUTPUT
          echo "tasks_total=0" >> $GITHUB_OUTPUT
          echo "commits_list=" >> $GITHUB_OUTPUT
          echo "blocking_issues=" >> $GITHUB_OUTPUT
          echo "review_notes=" >> $GITHUB_OUTPUT
          echo "files_changed=" >> $GITHUB_OUTPUT
          echo "error_summary=" >> $GITHUB_OUTPUT

          EXEC_RESULT="/tmp/artifacts/ci-execute-result.json"
          if [ -f "$EXEC_RESULT" ]; then
            echo "Found execute result file"
            python3 << 'PYEOF'
          import json, os

          with open("/tmp/artifacts/ci-execute-result.json") as f:
              data = json.load(f)

          with open(os.environ['GITHUB_OUTPUT'], 'a') as out:
              out.write(f"tasks_completed={data.get('tasks_completed', 0)}\n")
              out.write(f"tasks_total={data.get('tasks_total', 0)}\n")

              commits = data.get('commits', [])
              if commits:
                  short_commits = [c[:7] if len(c) > 7 else c for c in commits]
                  out.write(f"commits_list={','.join(short_commits)}\n")

              files = data.get('files_modified', []) or data.get('files_changed', [])
              if files:
                  display_files = files[:5]
                  if len(files) > 5:
                      display_files.append(f"... and {len(files) - 5} more")
                  out.write(f"files_changed={' | '.join(display_files)}\n")

              error = data.get('error') or data.get('failure_reason') or data.get('notes', '')
              if error and data.get('status') != 'completed':
                  error_short = str(error)[:200]
                  out.write(f"error_summary={error_short}\n")
          PYEOF
          fi

          REVIEW_RESULT="/tmp/artifacts/ci-review-result.json"
          if [ -f "$REVIEW_RESULT" ]; then
            echo "Found review result file"
            python3 << 'PYEOF'
          import json, os

          with open("/tmp/artifacts/ci-review-result.json") as f:
              data = json.load(f)

          with open(os.environ['GITHUB_OUTPUT'], 'a') as out:
              blocking = data.get('blocking_issues', [])
              if blocking:
                  issues_text = ' â€¢ '.join(str(i) for i in blocking[:3])
                  out.write(f"blocking_issues={issues_text}\n")

              notes = data.get('notes', '')
              if notes:
                  out.write(f"review_notes={notes[:150]}\n")
          PYEOF
          fi

          echo "Result parsing complete"

      - name: "FN.13 Post results to story issue"
        if: |
          always() &&
          needs.setup-and-plan.outputs.plan_selected == 'true' &&
          (needs.setup-and-plan.outputs.story_id != 'none' && needs.setup-and-plan.outputs.story_id != '' ||
           needs.identify-plan.outputs.story_id != 'none' && needs.identify-plan.outputs.story_id != '')
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          STORY_ID="${{ needs.identify-plan.outputs.story_id }}"
          if [ -z "$STORY_ID" ] || [ "$STORY_ID" = "none" ]; then
            STORY_ID="${{ needs.setup-and-plan.outputs.story_id }}"
          fi

          if [ -z "$STORY_ID" ] || [ "$STORY_ID" = "none" ]; then
            echo "No Story ID available, skipping issue posting"
            exit 0
          fi

          EXECUTE_PLAN="${{ needs.decompose.outputs.execute_plan }}"
          if [ -z "$EXECUTE_PLAN" ]; then
            EXECUTE_PLAN="${{ needs.setup-and-plan.outputs.plan_path }}"
          fi
          PLAN_FILENAME="${{ needs.setup-and-plan.outputs.plan_filename }}"
          if [ -z "$PLAN_FILENAME" ]; then
            PLAN_FILENAME=$(basename "$EXECUTE_PLAN" 2>/dev/null || echo "unknown")
          fi
          COMPLEXITY="${{ needs.decompose.outputs.complexity }}"
          if [ -z "$COMPLEXITY" ]; then
            COMPLEXITY="(verified - skipped)"
          fi
          DB_PATH=".claude/data/story-tree.db"

          TITLE=""
          DESCRIPTION=""
          USER_STORY=""
          SUCCESS_CRITERIA=""
          if [ -f "$DB_PATH" ]; then
            IFS='|' read -r TITLE DESCRIPTION USER_STORY SUCCESS_CRITERIA <<< "$(python3 << PYEOF
          import sqlite3

          conn = sqlite3.connect("$DB_PATH")
          r = conn.execute('''
              SELECT title, description, story, success_criteria
              FROM story_nodes WHERE id = ?
          ''', ("$STORY_ID",)).fetchone()
          conn.close()

          if r:
              title = (r[0] or '').replace('|', '/')
              desc = (r[1] or '').replace('|', '/').replace('\n', ' ')[:500]
              story = (r[2] or '').replace('|', '/').replace('\n', ' ')
              criteria = (r[3] or '').replace('|', '/')
              print(f"{title}|{desc}|{story}|{criteria}")
          else:
              print("|||")
          PYEOF
            )"
          fi
          TITLE="${TITLE:-Story $STORY_ID}"

          PARENT_ID=""
          if [[ "$STORY_ID" =~ \. ]]; then
            PARENT_ID="${STORY_ID%.*}"
          fi

          PARENT_ISSUE_REF=""
          if [ -n "$PARENT_ID" ]; then
            PARENT_TITLE=""
            if [ -f "$DB_PATH" ]; then
              PARENT_TITLE=$(python3 -c "import sqlite3; c=sqlite3.connect('$DB_PATH'); r=c.execute('SELECT title FROM story_nodes WHERE id=?',('$PARENT_ID',)).fetchone(); print(r[0] if r else '')" 2>/dev/null)
            fi
            if [ -n "$PARENT_TITLE" ]; then
              PARENT_ISSUE_TITLE="$PARENT_ID - $PARENT_TITLE"
              PARENT_ISSUE_NUM=$(gh issue list --state all --search "\"$PARENT_ISSUE_TITLE\" in:title" --json number,title --jq ".[] | select(.title == \"$PARENT_ISSUE_TITLE\") | .number" | head -1)
              if [ -n "$PARENT_ISSUE_NUM" ]; then
                PARENT_ISSUE_REF="#$PARENT_ISSUE_NUM"
              else
                PARENT_ISSUE_REF="$PARENT_ID - $PARENT_TITLE"
              fi
            fi
          fi

          ISSUE_TITLE="$STORY_ID - $TITLE"

          ISSUE_NUM=$(gh issue list --state all --search "\"$ISSUE_TITLE\" in:title" --json number,title --jq ".[] | select(.title == \"$ISSUE_TITLE\") | .number" | head -1)

          if [ -z "$ISSUE_NUM" ]; then
            RUN_URL="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"

            INITIAL_BODY="# $TITLE

          **Story ID:** $STORY_ID"

            if [ -n "$PARENT_ISSUE_REF" ]; then
              INITIAL_BODY="$INITIAL_BODY
          **Parent Story:** $PARENT_ISSUE_REF"
            fi

            INITIAL_BODY="$INITIAL_BODY
          **Plan:** \`$PLAN_FILENAME\`

          ---

          ## Description
          ${DESCRIPTION:-_No description available_}"

            if [ -n "$USER_STORY" ]; then
              INITIAL_BODY="$INITIAL_BODY

          ## User Story
          > $USER_STORY"
            fi

            if [ -n "$SUCCESS_CRITERIA" ]; then
              FORMATTED_CRITERIA=$(echo "$SUCCESS_CRITERIA" | sed 's/\\n/\n/g')
              INITIAL_BODY="$INITIAL_BODY

          ## Success Criteria
          $FORMATTED_CRITERIA"
            fi

            INITIAL_BODY="$INITIAL_BODY

          ---
          *Created by [execute-stories workflow]($RUN_URL)*"

            ISSUE_NUM=$(gh issue create --title "$ISSUE_TITLE" --body "$INITIAL_BODY" --label "story-tracking" 2>/dev/null | grep -oP 'issues/\K[0-9]+' || \
                        gh issue create --title "$ISSUE_TITLE" --body "$INITIAL_BODY" | grep -oP 'issues/\K[0-9]+' || echo "")
            echo "Created new issue #$ISSUE_NUM with rich context"
          fi

          if [ -z "$ISSUE_NUM" ]; then
            echo "Could not find/create issue"
            exit 0
          fi

          OUTCOME="${{ steps.outcome.outputs.outcome }}"
          REASON="${{ steps.outcome.outputs.reason }}"
          case "$OUTCOME" in
            success)
              if [ "${{ steps.outcome.outputs.needs_review }}" = "true" ]; then
                STATUS="âœ… Success (review required)"
              else
                STATUS="âœ… Success"
              fi
              ;;
            verified)
              STATUS="âœ… Verified (already implemented - plan archived)"
              ;;
            blocked)
              STATUS="ðŸš« Blocked (no matching Story ID found)"
              ;;
            partial)
              STATUS="âš ï¸ Partial (review required)"
              ;;
            paused)
              STATUS="â¸ï¸ Paused (blocking issues)"
              ;;
            failure)
              STATUS="âŒ Failed"
              ;;
            skipped)
              SKIP_REASON="${{ needs.setup-and-plan.outputs.skip_reason }}"
              case "$SKIP_REASON" in
                deps_unmet) STATUS="ðŸš§ Blocked (unmet dependencies)" ;;
                *) STATUS="â­ï¸ Skipped ($SKIP_REASON)" ;;
              esac
              ;;
            *)
              STATUS="âš ï¸ $OUTCOME"
              ;;
          esac

          RUN_URL="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"

          TASKS_COMPLETED="${{ steps.parse-results.outputs.tasks_completed }}"
          TASKS_TOTAL="${{ steps.parse-results.outputs.tasks_total }}"
          COMMITS_LIST="${{ steps.parse-results.outputs.commits_list }}"
          FILES_CHANGED="${{ steps.parse-results.outputs.files_changed }}"
          BLOCKING_ISSUES="${{ steps.parse-results.outputs.blocking_issues }}"
          REVIEW_NOTES="${{ steps.parse-results.outputs.review_notes }}"
          ERROR_SUMMARY="${{ steps.parse-results.outputs.error_summary }}"

          REVIEW_OUTCOME="${{ needs.review-plan.outputs.outcome }}"
          EXECUTE_STATUS="${{ needs.execute.outputs.status }}"

          BODY="## $STATUS

          **Plan:** \`$PLAN_FILENAME\`
          **Complexity:** $COMPLEXITY"

          if [ "$OUTCOME" = "success" ] || [ "$OUTCOME" = "partial" ]; then
            if [ "$TASKS_TOTAL" != "0" ] && [ -n "$TASKS_TOTAL" ]; then
              BODY="$BODY
          **Tasks:** $TASKS_COMPLETED/$TASKS_TOTAL completed"
            fi

            if [ -n "$COMMITS_LIST" ]; then
              COMMITS_FORMATTED=$(echo "$COMMITS_LIST" | sed 's/,/`, `/g')
              BODY="$BODY
          **Commits:** \`$COMMITS_FORMATTED\`"
            fi

            if [ -n "$FILES_CHANGED" ]; then
              BODY="$BODY
          **Files:** $FILES_CHANGED"
            fi
          fi

          if [ "$OUTCOME" = "failure" ] || [ "$OUTCOME" = "partial" ]; then
            BODY="$BODY

          ### Failure Details"

            if [ "$REVIEW_OUTCOME" = "pause" ]; then
              BODY="$BODY
          **Failed at:** Review (blocking issues found)"
            elif [ -z "$EXECUTE_STATUS" ] || [ "$EXECUTE_STATUS" = "failed" ]; then
              BODY="$BODY
          **Failed at:** Execute"
            fi

            if [ -n "$ERROR_SUMMARY" ]; then
              BODY="$BODY
          **Error:** $ERROR_SUMMARY"
            fi

            if [ "$TASKS_TOTAL" != "0" ] && [ -n "$TASKS_TOTAL" ]; then
              BODY="$BODY
          **Progress:** $TASKS_COMPLETED/$TASKS_TOTAL tasks completed before failure"
            fi
          fi

          if [ "$OUTCOME" = "paused" ] && [ -n "$BLOCKING_ISSUES" ]; then
            BODY="$BODY

          ### Blocking Issues
          $BLOCKING_ISSUES"
          fi

          if [ -n "$REVIEW_NOTES" ] && [ "$OUTCOME" != "success" ]; then
            BODY="$BODY

          ### Review Notes
          $REVIEW_NOTES"
          fi

          if [ "$OUTCOME" != "success" ] && [ "$OUTCOME" != "verified" ] && [ "$OUTCOME" != "skipped" ]; then
            BODY="$BODY

          ### Debug Info
          - **Artifacts:** \`execute-result\`, \`review-result\` (download from [workflow run]($RUN_URL))
          - **Result files:** \`.claude/skills/story-execution/ci-*.json\`"
          fi

          BODY="$BODY

          ---
          **Time:** $(date -u +'%Y-%m-%d %H:%M:%S UTC')
          **Run:** [View Details]($RUN_URL)

          *Posted by [execute-stories workflow]($RUN_URL)*"

          echo "$BODY" | gh issue comment "$ISSUE_NUM" --body-file -
          echo "Posted to issue #$ISSUE_NUM"
