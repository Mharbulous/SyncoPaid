name: 4. Execute Story

# Temporary 4-hour schedule: runs every 10 min for hours 17-20 UTC on Dec 21, 2025
on:
  schedule:
    - cron: '0,10,20,30,40,50 17-20 21 12 *'
  workflow_dispatch:

concurrency:
  group: daily-story-execution
  cancel-in-progress: false

permissions:
  contents: write
  issues: write
  pull-requests: write
  id-token: write

# ══════════════════════════════════════════════════════════════════════════════
# PIPELINE VISUALIZATION
# ══════════════════════════════════════════════════════════════════════════════
# This workflow uses 7 semantically meaningful stages:
#
#   setup-and-plan → validate-plan → verify-implementation → review-plan → decompose → execute → finalize
#
# Each stage has a clear purpose:
# - setup-and-plan: Find plan, validate deps, initialize state
# - validate-plan: Ensure plan has valid Story ID (match to database if missing)
# - verify-implementation: Check if plan already implemented (for reviewing/verifying stages)
# - review-plan: Critical review, decide proceed/pause/verified
# - decompose: Assess complexity, split if needed (Opus)
# - execute: Follow plan's TDD steps directly (Sonnet)
# - finalize: Archive, commit, report
#
# State is passed between jobs via:
# - Job outputs: simple strings (outcome, status, paths)
# - The plan document itself is the source of truth
# ══════════════════════════════════════════════════════════════════════════════

jobs:
  # ════════════════════════════════════════════════════════════════════════════
  # SETUP-AND-PLAN: Find plan, validate dependencies, initialize state
  # ════════════════════════════════════════════════════════════════════════════
  setup-and-plan:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      plan_selected: ${{ steps.select-plan.outputs.selected }}
      plan_path: ${{ steps.select-plan.outputs.path }}
      plan_filename: ${{ steps.select-plan.outputs.filename }}
      plan_sequence: ${{ steps.select-plan.outputs.sequence }}
      story_id: ${{ steps.extract-story.outputs.story_id }}
      should_execute: ${{ steps.determine.outputs.should_execute }}
      skip_reason: ${{ steps.determine.outputs.skip_reason }}
      needs_verification: ${{ steps.determine.outputs.needs_verification }}
      current_stage: ${{ steps.check-executed.outputs.current_stage }}

    steps:
      # ── PHASE 1: SETUP ──
      - name: "1.1 Checkout repository"
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      # ── PHASE 2: PLAN SELECTION ──
      - name: "2.1 Find available plans"
        id: find-plans
        run: |
          echo "## Plan Discovery" >> $GITHUB_STEP_SUMMARY

          PLANS_DIR=".claude/data/plans"
          if [ ! -d "$PLANS_DIR" ]; then
            echo "plans_found=0" >> $GITHUB_OUTPUT
            echo "❌ Plans directory not found: $PLANS_DIR" >> $GITHUB_STEP_SUMMARY
            exit 0
          fi

          PLAN_COUNT=$(find "$PLANS_DIR" -maxdepth 1 -name "*.md" -type f | wc -l)
          echo "plans_found=$PLAN_COUNT" >> $GITHUB_OUTPUT
          echo "Found **$PLAN_COUNT** plan files in $PLANS_DIR" >> $GITHUB_STEP_SUMMARY

          if [ "$PLAN_COUNT" -gt 0 ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| Plan File | Sequence |" >> $GITHUB_STEP_SUMMARY
            echo "|-----------|----------|" >> $GITHUB_STEP_SUMMARY
            for f in $(ls -1 "$PLANS_DIR"/*.md 2>/dev/null | head -10); do
              FNAME=$(basename "$f")
              SEQ=$(echo "$FNAME" | grep -oP '^\d{3}[A-Z]?' || echo "?")
              echo "| $FNAME | $SEQ |" >> $GITHUB_STEP_SUMMARY
            done
          fi

      - name: "2.2 Select earliest plan"
        id: select-plan
        if: steps.find-plans.outputs.plans_found != '0'
        run: |
          python3 << 'PYEOF'
          import os, re, json

          plans_dir = '.claude/data/plans'
          pattern = re.compile(r'^(\d{3})([A-Z])?_(.+)\.md$')

          plans = []
          for f in os.listdir(plans_dir):
              path = os.path.join(plans_dir, f)
              if os.path.isfile(path) and f.endswith('.md'):
                  m = pattern.match(f)
                  if m:
                      plans.append({
                          'filename': f,
                          'path': path,
                          'sequence': int(m.group(1)),
                          'letter': m.group(2) or '',
                      })

          plans.sort(key=lambda x: (x['sequence'], x['letter']))

          if plans:
              selected = plans[0]
              with open(os.environ['GITHUB_OUTPUT'], 'a') as out:
                  out.write(f"selected=true\n")
                  out.write(f"filename={selected['filename']}\n")
                  out.write(f"path={selected['path']}\n")
                  out.write(f"sequence={selected['sequence']}{selected['letter']}\n")
              print(f"Selected: {selected['filename']}")
          else:
              with open(os.environ['GITHUB_OUTPUT'], 'a') as out:
                  out.write("selected=false\n")
              print("No valid plan files found")
          PYEOF

      - name: "2.3 Extract Story ID from plan"
        id: extract-story
        if: steps.select-plan.outputs.selected == 'true'
        run: |
          PLAN_PATH="${{ steps.select-plan.outputs.path }}"

          STORY_ID=$(grep -oP 'Story ID[:\s]*\K\d+(\.\d+)*' "$PLAN_PATH" | head -1)

          if [ -z "$STORY_ID" ]; then
            STORY_ID=$(grep -oP '\*\*Story ID:\*\*\s*\K\d+(\.\d+)*' "$PLAN_PATH" | head -1)
          fi

          echo "story_id=${STORY_ID:-none}" >> $GITHUB_OUTPUT
          echo "Story ID: ${STORY_ID:-'(not found)'}"

      # ── PHASE 3: VALIDATION ──
      - name: "3.1 Check if story already executed"
        id: check-executed
        if: steps.select-plan.outputs.selected == 'true' && steps.extract-story.outputs.story_id != 'none'
        run: |
          STORY_ID="${{ steps.extract-story.outputs.story_id }}"
          DB_PATH=".claude/data/story-tree.db"

          if [ ! -f "$DB_PATH" ]; then
            echo "already_executed=false" >> $GITHUB_OUTPUT
            echo "Database not found, assuming not executed"
            exit 0
          fi

          STAGE=$(python3 -c "
          import sqlite3
          conn = sqlite3.connect('$DB_PATH')
          r = conn.execute('SELECT stage FROM story_nodes WHERE id = ?', ('$STORY_ID',)).fetchone()
          print(r[0] if r else 'unknown')
          conn.close()
          ")

          echo "Current stage: $STAGE"

          case "$STAGE" in
            reviewing|verifying|implemented|ready|polish|released)
              echo "already_executed=true" >> $GITHUB_OUTPUT
              echo "current_stage=$STAGE" >> $GITHUB_OUTPUT
              echo "⚠️ Story $STORY_ID already at stage: $STAGE"
              ;;
            *)
              echo "already_executed=false" >> $GITHUB_OUTPUT
              echo "current_stage=$STAGE" >> $GITHUB_OUTPUT
              echo "✓ Story $STORY_ID ready for execution (stage: $STAGE)"
              ;;
          esac

      - name: "3.2 Check story dependencies"
        id: check-deps
        if: steps.select-plan.outputs.selected == 'true' && steps.check-executed.outputs.already_executed != 'true'
        run: |
          STORY_ID="${{ steps.extract-story.outputs.story_id }}"
          PLAN_PATH="${{ steps.select-plan.outputs.path }}"
          DB_PATH=".claude/data/story-tree.db"

          if [ "$STORY_ID" = "none" ] || [ ! -f "$DB_PATH" ]; then
            echo "deps_met=true" >> $GITHUB_OUTPUT
            echo "No Story ID or database, skipping dependency check"
            exit 0
          fi

          python3 << PYEOF
          import sqlite3, re, os

          story_id = "$STORY_ID"
          db_path = "$DB_PATH"
          plan_path = "$PLAN_PATH"

          conn = sqlite3.connect(db_path)

          result = conn.execute('SELECT description, notes FROM story_nodes WHERE id = ?', (story_id,)).fetchone()
          if not result:
              with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                  f.write("deps_met=true\n")
              print("Story not in database, proceeding")
              exit(0)

          text = (result[0] or '') + ' ' + (result[1] or '')

          with open(plan_path, 'r') as f:
              text += ' ' + f.read()

          dep_pattern = r'(?:depends on|requires|after|blocked by)\s+(\d+(?:\.\d+)*)'
          deps = set(re.findall(dep_pattern, text, re.IGNORECASE))
          deps.discard(story_id)

          if not deps:
              with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                  f.write("deps_met=true\n")
              print("No dependencies found")
              exit(0)

          IMPLEMENTED = ('implemented', 'ready', 'polish', 'released')
          unmet = []
          for dep_id in deps:
              r = conn.execute('SELECT stage FROM story_nodes WHERE id = ? AND disposition IS NULL', (dep_id,)).fetchone()
              if r and r[0] not in IMPLEMENTED:
                  unmet.append(f"{dep_id} ({r[0]})")

          conn.close()

          if unmet:
              with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                  f.write("deps_met=false\n")
                  f.write(f"unmet_deps={', '.join(unmet)}\n")
              print(f"❌ Unmet dependencies: {', '.join(unmet)}")
          else:
              with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                  f.write("deps_met=true\n")
              print("✓ All dependencies met")
          PYEOF

      # ── PHASE 4: HANDLE SKIP CONDITIONS ──
      - name: "4.1 Move blocked plan to blocked folder"
        if: steps.check-deps.outputs.deps_met == 'false'
        run: |
          PLAN_PATH="${{ steps.select-plan.outputs.path }}"
          FILENAME="${{ steps.select-plan.outputs.filename }}"
          BLOCKED_DIR=".claude/data/plans/blocked"
          UNMET="${{ steps.check-deps.outputs.unmet_deps }}"

          mkdir -p "$BLOCKED_DIR"
          mv "$PLAN_PATH" "$BLOCKED_DIR/"
          echo "Moved blocked plan: $FILENAME → $BLOCKED_DIR/"
          echo "Unmet dependencies: $UNMET"

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add -A
          git commit -m "ci: move blocked plan $FILENAME (deps: $UNMET)"

          # Retry push with exponential backoff and pull before retry
          for attempt in 1 2 3 4; do
            if git push origin main; then
              echo "✓ Push successful"
              exit 0
            else
              echo "Push failed (attempt $attempt), pulling and retrying..."
              git pull --rebase origin main || true
              sleep $((2 ** attempt))
            fi
          done
          echo "❌ Push failed after 4 attempts"
          exit 1

      # ── DETERMINE IF EXECUTION SHOULD PROCEED ──
      - name: "4.2 Determine execution eligibility"
        id: determine
        run: |
          SELECTED="${{ steps.select-plan.outputs.selected }}"
          ALREADY_EXECUTED="${{ steps.check-executed.outputs.already_executed }}"
          CURRENT_STAGE="${{ steps.check-executed.outputs.current_stage }}"
          DEPS_MET="${{ steps.check-deps.outputs.deps_met }}"

          if [ "$SELECTED" != "true" ]; then
            echo "should_execute=false" >> $GITHUB_OUTPUT
            echo "skip_reason=no_plans" >> $GITHUB_OUTPUT
            echo "needs_verification=false" >> $GITHUB_OUTPUT
          elif [ "$ALREADY_EXECUTED" = "true" ]; then
            # Story is in reviewing/verifying/implemented stage but plan file still exists
            # This needs verification to check if implementation actually exists
            echo "should_execute=false" >> $GITHUB_OUTPUT
            echo "skip_reason=needs_verification" >> $GITHUB_OUTPUT
            echo "needs_verification=true" >> $GITHUB_OUTPUT
            echo "⚠️ Plan exists but story at stage '$CURRENT_STAGE' - needs verification"
          elif [ "$DEPS_MET" = "false" ]; then
            echo "should_execute=false" >> $GITHUB_OUTPUT
            echo "skip_reason=deps_unmet" >> $GITHUB_OUTPUT
            echo "needs_verification=false" >> $GITHUB_OUTPUT
          else
            echo "should_execute=true" >> $GITHUB_OUTPUT
            echo "skip_reason=" >> $GITHUB_OUTPUT
            echo "needs_verification=false" >> $GITHUB_OUTPUT
          fi

  # ════════════════════════════════════════════════════════════════════════════
  # VALIDATE-PLAN: Ensure plan has valid Story ID (match to database if missing)
  # ════════════════════════════════════════════════════════════════════════════
  validate-plan:
    needs: setup-and-plan
    if: needs.setup-and-plan.outputs.plan_selected == 'true' && needs.setup-and-plan.outputs.story_id == 'none'
    runs-on: ubuntu-latest
    timeout-minutes: 15
    outputs:
      story_id: ${{ steps.validate-output.outputs.story_id }}
      validation_passed: ${{ steps.validate-output.outputs.validation_passed }}
      plan_blocked: ${{ steps.validate-output.outputs.plan_blocked }}

    steps:
      - name: "VP.1 Checkout repository"
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: "VP.1.5 Extract database schema"
        id: schema
        run: |
          DB_PATH=".claude/data/story-tree.db"
          if [ -f "$DB_PATH" ]; then
            # Extract schema and sample data for Claude
            SCHEMA=$(sqlite3 "$DB_PATH" ".schema story_nodes" 2>/dev/null | head -40)
            SAMPLE=$(sqlite3 "$DB_PATH" "SELECT id, title, substr(description, 1, 100) FROM story_nodes WHERE disposition IS NULL LIMIT 3" 2>/dev/null)

            # Write to temp file for Claude to read
            echo "$SCHEMA" > /tmp/db_schema.txt
            echo "" >> /tmp/db_schema.txt
            echo "Sample rows (id|title|description_excerpt):" >> /tmp/db_schema.txt
            echo "$SAMPLE" >> /tmp/db_schema.txt

            echo "schema_available=true" >> $GITHUB_OUTPUT
          else
            echo "schema_available=false" >> $GITHUB_OUTPUT
          fi

      - name: "VP.2 Match plan to story in database"
        id: validate
        uses: anthropics/claude-code-action@v1
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          show_full_output: true
          prompt: |
            You are validating a plan document to ensure it has a valid Story ID.

            Plan: ${{ needs.setup-and-plan.outputs.plan_path }}
            Plan filename: ${{ needs.setup-and-plan.outputs.plan_filename }}

            ## CONTEXT

            This plan document does not contain a Story ID. Your task is to find the matching
            story in the database by comparing the plan's content to story nodes.

            ## YOUR TASK

            1. Read the plan document completely
            2. Extract key information:
               - Title/description of what the plan implements
               - Key features or functionality
               - Any mentioned story references
            3. Query the database at `.claude/data/story-tree.db` to find matching stories:
               - Compare plan content to story descriptions
               - Compare to story field (user story text)
               - Compare to success_criteria field
               - Look for similar keywords and concepts
            4. If a confident match is found (>80% confidence), update the plan
            5. If no match found, the plan should be blocked

            ## DATABASE SCHEMA

            The story_nodes table has these columns:
            - id: TEXT PRIMARY KEY (e.g., "7.6", "8.1.2")
            - title: TEXT NOT NULL
            - description: TEXT NOT NULL
            - story: TEXT (user story text: "As a... I want... So that...")
            - success_criteria: TEXT (acceptance criteria)
            - stage: TEXT (concept, approved, planned, active, reviewing, verifying, implemented, ready, polish, released)
            - hold_reason: TEXT (NULL if not held)
            - disposition: TEXT (NULL if active in pipeline)

            ## SQL QUERY EXAMPLES

            Use Python sqlite3 module (preferred) or sqlite3 CLI with proper quoting:

            ```python
            # Find stories by keyword (Python - PREFERRED)
            import sqlite3
            conn = sqlite3.connect('.claude/data/story-tree.db')
            results = conn.execute('''
                SELECT id, title, description, story, success_criteria
                FROM story_nodes
                WHERE disposition IS NULL
                  AND (title LIKE ? OR description LIKE ? OR story LIKE ?)
            ''', ('%keyword%', '%keyword%', '%keyword%')).fetchall()
            ```

            ```bash
            # If using sqlite3 CLI, use <> instead of != and quote carefully
            sqlite3 .claude/data/story-tree.db "SELECT id, title FROM story_nodes WHERE stage <> 'concept' AND disposition IS NULL"
            ```

            ## HOW TO UPDATE THE PLAN

            If you find a matching story, add a Story ID line in the plan's header section.
            Look for a metadata section near the top (often after the title) and add:

            ```markdown
            **Story ID:** 7.6
            ```

            Or if there's already a metadata table, add a row for Story ID.

            ## OUTPUT REQUIRED

            Write a JSON file to `.claude/skills/story-execution/ci-validate-result.json`:

            ```json
            {
              "validation_passed": true|false,
              "story_id": "7.6" or null,
              "confidence": 0.85,
              "match_reason": "Brief explanation of why this story matches",
              "plan_updated": true|false,
              "block_reason": null or "No matching story found in database"
            }
            ```

            IMPORTANT:
            - Only update the plan file if you find a confident match (>80%)
            - If you update the plan, set plan_updated=true
            - If no match found, set validation_passed=false and provide block_reason

          claude_args: |
            --allowedTools "Read,Write,Edit,Glob,Grep,Bash(python:*),Bash(python3:*),Bash(sqlite3:*)"
            --model claude-sonnet-4-5-20250929
            --max-turns 20

      - name: "VP.3 Read validation output"
        id: validate-output
        if: always()
        run: |
          RESULT_FILE=".claude/skills/story-execution/ci-validate-result.json"

          if [ -f "$RESULT_FILE" ]; then
            PASSED=$(python3 -c "import json; d=json.load(open('$RESULT_FILE')); print(str(d.get('validation_passed', False)).lower())")
            STORY_ID=$(python3 -c "import json; d=json.load(open('$RESULT_FILE')); print(d.get('story_id') or 'none')")
            PLAN_UPDATED=$(python3 -c "import json; d=json.load(open('$RESULT_FILE')); print(str(d.get('plan_updated', False)).lower())")

            echo "validation_passed=$PASSED" >> $GITHUB_OUTPUT
            echo "story_id=$STORY_ID" >> $GITHUB_OUTPUT

            if [ "$PASSED" = "true" ]; then
              echo "plan_blocked=false" >> $GITHUB_OUTPUT
              echo "✓ Validation passed - Story ID: $STORY_ID"
            else
              echo "plan_blocked=true" >> $GITHUB_OUTPUT
              echo "⚠️ Validation failed - plan will be blocked"
            fi

            echo "## Plan Validation" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| Field | Value |" >> $GITHUB_STEP_SUMMARY
            echo "|-------|-------|" >> $GITHUB_STEP_SUMMARY
            echo "| Passed | $PASSED |" >> $GITHUB_STEP_SUMMARY
            echo "| Story ID | $STORY_ID |" >> $GITHUB_STEP_SUMMARY
            echo "| Plan Updated | $PLAN_UPDATED |" >> $GITHUB_STEP_SUMMARY
          else
            echo "validation_passed=false" >> $GITHUB_OUTPUT
            echo "story_id=none" >> $GITHUB_OUTPUT
            echo "plan_blocked=true" >> $GITHUB_OUTPUT
            echo "⚠️ Validation result file not found"
          fi

      - name: "VP.4 Commit plan update if Story ID was added"
        if: steps.validate-output.outputs.validation_passed == 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add -A

          if ! git diff --cached --quiet; then
            PLAN_FILENAME="${{ needs.setup-and-plan.outputs.plan_filename }}"
            STORY_ID="${{ steps.validate-output.outputs.story_id }}"

            git commit -m "ci: add Story ID $STORY_ID to plan $PLAN_FILENAME

            Matched plan to story via content analysis"

            # Retry push with exponential backoff
            for attempt in 1 2 3 4; do
              if git push origin main; then
                echo "✓ Pushed plan update with Story ID"
                exit 0
              else
                echo "Push failed (attempt $attempt), pulling and retrying..."
                git pull --rebase origin main || true
                sleep $((2 ** attempt))
              fi
            done
            echo "❌ Push failed after 4 attempts"
            exit 1
          else
            echo "No changes to commit (Story ID may have already been present)"
          fi

      - name: "VP.5 Move blocked plan if no Story ID found"
        if: steps.validate-output.outputs.plan_blocked == 'true'
        run: |
          PLAN_PATH="${{ needs.setup-and-plan.outputs.plan_path }}"
          FILENAME="${{ needs.setup-and-plan.outputs.plan_filename }}"
          BLOCKED_DIR=".claude/data/plans/blocked"

          mkdir -p "$BLOCKED_DIR"
          mv "$PLAN_PATH" "$BLOCKED_DIR/"
          echo "Moved plan without Story ID: $FILENAME → $BLOCKED_DIR/"

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add -A
          git commit -m "ci: block plan $FILENAME (no matching Story ID found)

          Plan moved to blocked folder - requires manual Story ID assignment"

          # Retry push with exponential backoff
          for attempt in 1 2 3 4; do
            if git push origin main; then
              echo "✓ Push successful"
              exit 0
            else
              echo "Push failed (attempt $attempt), pulling and retrying..."
              git pull --rebase origin main || true
              sleep $((2 ** attempt))
            fi
          done
          echo "❌ Push failed after 4 attempts"
          exit 1

      - name: "VP.6 Upload validation result"
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: validate-result
          path: .claude/skills/story-execution/ci-validate-result.json
          retention-days: 1
          if-no-files-found: ignore

  # ════════════════════════════════════════════════════════════════════════════
  # VERIFY-IMPLEMENTATION: Check if plan was actually implemented in codebase
  # ════════════════════════════════════════════════════════════════════════════
  verify-implementation:
    needs: [setup-and-plan, validate-plan]
    if: |
      always() &&
      needs.setup-and-plan.outputs.needs_verification == 'true' &&
      needs.validate-plan.outputs.plan_blocked != 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 15
    outputs:
      verification_passed: ${{ steps.verify-output.outputs.verification_passed }}
      should_proceed_to_execute: ${{ steps.verify-output.outputs.should_proceed_to_execute }}
      verification_incomplete: ${{ steps.verify-output.outputs.verification_incomplete }}

    steps:
      - name: "V.1 Checkout repository"
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: "V.1.1 Clean up Claude installation locks"
        run: |
          rm -rf /tmp/claude-* 2>/dev/null || true
          rm -rf ~/.claude-install* 2>/dev/null || true
          rm -rf ~/.npm/_locks/* 2>/dev/null || true
          pkill -f "claude" 2>/dev/null || true
          echo "✓ Cleaned up potential installation locks"

      - name: "V.2 Verify implementation exists"
        id: verify
        uses: anthropics/claude-code-action@v1
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          show_full_output: true
          prompt: |
            You are verifying whether a plan has actually been implemented in the codebase.

            Plan: ${{ needs.setup-and-plan.outputs.plan_path }}
            Story ID: ${{ needs.setup-and-plan.outputs.story_id }}
            Current Stage: ${{ needs.setup-and-plan.outputs.current_stage }}

            ## CONTEXT

            The database indicates this story is at stage "${{ needs.setup-and-plan.outputs.current_stage }}"
            (reviewing/verifying/implemented), but the plan document still exists in the plans folder.
            This could mean:
            1. The implementation was completed but the plan wasn't archived (verification should PASS)
            2. The database was updated prematurely and implementation doesn't exist (verification should FAIL)

            ## YOUR TASK

            1. Read the plan document completely
            2. Identify the TOP 3-5 KEY deliverables (focus on new files and critical functions)
            3. Use parallel Glob/Grep calls to quickly verify if they exist
            4. Check only the MOST IMPORTANT deliverables - don't exhaustively check everything
            5. Write the result file IMMEDIATELY once you have enough evidence

            ## EFFICIENCY GUIDELINES

            - Use Glob to check for file existence in parallel (multiple calls at once)
            - Use Grep to quickly verify key functions/classes exist
            - Stop searching once you have clear evidence (3-5 checks is usually enough)
            - Prioritize: new files > new functions > config changes > minor modifications
            - If core files exist with key functions, that's sufficient for PASS

            ## VERIFICATION CRITERIA

            - **PASS**: Core deliverables exist (main files + key functions)
            - **PARTIAL**: Some core files exist but key parts are missing
            - **FAIL**: Core deliverables are completely missing

            ## CRITICAL: WRITE OUTPUT EARLY

            Write the JSON file to `.claude/skills/story-execution/ci-verify-result.json` AS SOON AS you have enough evidence.
            Don't wait until you've checked everything - prioritize writing the result:

            ```json
            {
              "verification_passed": true|false,
              "status": "pass|partial|fail",
              "deliverables_checked": [
                {"item": "description", "found": true|false, "location": "path or null"}
              ],
              "summary": "Brief explanation of findings",
              "recommendation": "archive|execute|manual_review"
            }
            ```

            Where recommendation is:
            - "archive": Implementation exists, safe to archive the plan
            - "execute": Implementation missing, plan should be executed
            - "manual_review": Partial implementation, needs human review

          claude_args: |
            --allowedTools "Read,Glob,Grep,Bash(python:*),Bash(python3:*),Write"
            --model claude-sonnet-4-5-20250929
            --max-turns 30

      - name: "V.3 Read verification output"
        id: verify-output
        if: always()
        run: |
          RESULT_FILE=".claude/skills/story-execution/ci-verify-result.json"

          if [ -f "$RESULT_FILE" ]; then
            PASSED=$(python3 -c "import json; d=json.load(open('$RESULT_FILE')); print(str(d.get('verification_passed', False)).lower())")
            STATUS=$(python3 -c "import json; d=json.load(open('$RESULT_FILE')); print(d.get('status', 'unknown'))")
            RECOMMENDATION=$(python3 -c "import json; d=json.load(open('$RESULT_FILE')); print(d.get('recommendation', 'manual_review'))")

            echo "verification_passed=$PASSED" >> $GITHUB_OUTPUT

            # Determine if we should proceed to execute
            if [ "$RECOMMENDATION" = "execute" ]; then
              echo "should_proceed_to_execute=true" >> $GITHUB_OUTPUT
            else
              echo "should_proceed_to_execute=false" >> $GITHUB_OUTPUT
            fi

            echo "## Implementation Verification" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| Field | Value |" >> $GITHUB_STEP_SUMMARY
            echo "|-------|-------|" >> $GITHUB_STEP_SUMMARY
            echo "| Status | $STATUS |" >> $GITHUB_STEP_SUMMARY
            echo "| Passed | $PASSED |" >> $GITHUB_STEP_SUMMARY
            echo "| Recommendation | $RECOMMENDATION |" >> $GITHUB_STEP_SUMMARY
          else
            # Result file not found - likely hit max-turns limit
            # Default to manual_review to avoid re-executing already-implemented plans
            echo "verification_passed=false" >> $GITHUB_OUTPUT
            echo "should_proceed_to_execute=false" >> $GITHUB_OUTPUT
            echo "verification_incomplete=true" >> $GITHUB_OUTPUT
            echo "⚠️ Verification result file not found (likely max-turns exceeded)"
            echo "## ⚠️ Verification Incomplete" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "The verification agent did not complete within the turn limit." >> $GITHUB_STEP_SUMMARY
            echo "Manual review required to determine if implementation exists." >> $GITHUB_STEP_SUMMARY
          fi

      - name: "V.4 Archive plan if verification passed"
        if: steps.verify-output.outputs.verification_passed == 'true'
        run: |
          PLAN_PATH="${{ needs.setup-and-plan.outputs.plan_path }}"
          FILENAME="${{ needs.setup-and-plan.outputs.plan_filename }}"
          ARCHIVE_DIR=".claude/data/executed"

          mkdir -p "$ARCHIVE_DIR"
          mv "$PLAN_PATH" "$ARCHIVE_DIR/"
          echo "✓ Verified implementation exists - archived plan: $FILENAME → $ARCHIVE_DIR/"

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add -A
          git commit -m "ci: archive verified plan $FILENAME

          Story: ${{ needs.setup-and-plan.outputs.story_id }}
          Verification: Implementation confirmed in codebase"

          # Retry push with exponential backoff
          for attempt in 1 2 3 4; do
            if git push origin main; then
              echo "✓ Push successful"
              exit 0
            else
              echo "Push failed (attempt $attempt), pulling and retrying..."
              git pull --rebase origin main || true
              sleep $((2 ** attempt))
            fi
          done
          echo "❌ Push failed after 4 attempts"
          exit 1

      - name: "V.5 Reset story stage if verification failed"
        if: steps.verify-output.outputs.should_proceed_to_execute == 'true'
        run: |
          STORY_ID="${{ needs.setup-and-plan.outputs.story_id }}"
          DB_PATH=".claude/data/story-tree.db"

          if [ ! -f "$DB_PATH" ] || [ "$STORY_ID" = "none" ]; then
            echo "No database or story ID, skipping stage reset"
            exit 0
          fi

          echo "⚠️ Implementation not found - resetting story stage for re-execution"

          python3 << PYEOF
          import sqlite3
          conn = sqlite3.connect("$DB_PATH")
          conn.execute('''
              UPDATE story_nodes
              SET stage = 'planned',
                  notes = COALESCE(notes || char(10), '') || 'CI verification failed - implementation not found, reset for re-execution: ' || datetime('now'),
                  updated_at = datetime('now')
              WHERE id = ?
          ''', ("$STORY_ID",))
          conn.commit()
          print(f"✓ Reset story $STORY_ID to 'planned' stage")
          conn.close()
          PYEOF

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add -A

          if ! git diff --cached --quiet; then
            git commit -m "ci: reset story $STORY_ID for re-execution

          Verification found implementation missing despite stage being '${{ needs.setup-and-plan.outputs.current_stage }}'"

            # Retry push with exponential backoff
            for attempt in 1 2 3 4; do
              if git push origin main; then
                echo "✓ Push successful"
                exit 0
              else
                echo "Push failed (attempt $attempt), pulling and retrying..."
                git pull --rebase origin main || true
                sleep $((2 ** attempt))
              fi
            done
            echo "❌ Push failed after 4 attempts"
            exit 1
          fi

      - name: "V.6 Upload verification result"
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: verify-result
          path: .claude/skills/story-execution/ci-verify-result.json
          retention-days: 1
          if-no-files-found: ignore

  # ════════════════════════════════════════════════════════════════════════════
  # REVIEW-PLAN: Critical review - validate plan is actionable
  # ════════════════════════════════════════════════════════════════════════════
  review-plan:
    needs: [setup-and-plan, validate-plan, verify-implementation]
    if: |
      always() &&
      needs.validate-plan.outputs.plan_blocked != 'true' &&
      (needs.setup-and-plan.outputs.should_execute == 'true' ||
       needs.verify-implementation.outputs.should_proceed_to_execute == 'true')
    runs-on: ubuntu-latest
    timeout-minutes: 15
    outputs:
      outcome: ${{ steps.review-output.outputs.outcome }}
      review_completed: ${{ steps.review-output.outputs.review_completed }}

    steps:
      - name: "1.0 Checkout repository"
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: "1.0.1 Pull latest changes"
        run: |
          git pull origin main --rebase || true

      - name: "1.0.2 Clean up Claude installation locks"
        run: |
          # Remove any stale installation lock files that may cause conflicts
          rm -rf /tmp/claude-* 2>/dev/null || true
          rm -rf ~/.claude-install* 2>/dev/null || true
          rm -rf ~/.npm/_locks/* 2>/dev/null || true
          # Kill any orphaned Claude processes
          pkill -f "claude" 2>/dev/null || true
          echo "✓ Cleaned up potential installation locks"

      - name: "1.1 Review plan critically"
        id: review
        uses: anthropics/claude-code-action@v1
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          show_full_output: true
          prompt: |
            You are reviewing a plan document for CI execution.

            Plan: ${{ needs.setup-and-plan.outputs.plan_path }}
            Story ID: ${{ needs.validate-plan.outputs.story_id || needs.setup-and-plan.outputs.story_id }}

            ## YOUR TASK

            1. Read the plan file completely
            2. Quick check: Does the plan's KEY deliverable already exist? (1-2 targeted searches max)
            3. Make a decision and WRITE THE OUTPUT FILE IMMEDIATELY
            4. Only do deeper analysis if initial check is inconclusive

            ## EFFICIENCY RULES (CRITICAL)

            - Use Glob/Grep in PARALLEL for speed
            - Stop searching once you have enough evidence (2-3 files is usually enough)
            - WRITE THE OUTPUT FILE AS SOON AS you have a decision
            - Don't exhaustively verify every detail - focus on KEY deliverables

            ## OUTCOME CLASSIFICATION

            ### Already Implemented → outcome: "verified"
            - Core files/functions from the plan already exist
            - Test files already exist with passing tests

            ### Blocking Issues → outcome: "pause"
            - Security implications, breaking changes, missing critical info
            - Dependencies not implemented

            ### Minor Issues → outcome: "proceed_with_review"
            - Style issues, minor gaps (document and proceed)

            ### Ready to Execute → outcome: "proceed"
            - Plan is clear, work has NOT been done yet

            ## OUTPUT (WRITE THIS EARLY!)

            Write to `.claude/skills/story-execution/ci-review-result.json`:

            ```json
            {
              "outcome": "proceed|pause|proceed_with_review|verified",
              "blocking_issues": [],
              "deferrable_issues": [],
              "notes": "Brief summary"
            }
            ```

          claude_args: |
            --allowedTools "Read,Write,Edit,Glob,Grep,Bash(python:*),Bash(python3:*),Bash(mkdir:*)"
            --model claude-sonnet-4-5-20250929
            --max-turns 25

      - name: "1.2 Read review output"
        id: review-output
        if: always()
        run: |
          RESULT_FILE=".claude/skills/story-execution/ci-review-result.json"
          if [ -f "$RESULT_FILE" ]; then
            OUTCOME=$(python3 -c "import json; d=json.load(open('$RESULT_FILE')); print(d.get('outcome','unknown'))")
            if [ "$OUTCOME" = "proceed" ] || [ "$OUTCOME" = "proceed_with_review" ] || [ "$OUTCOME" = "pause" ] || [ "$OUTCOME" = "verified" ]; then
              echo "outcome=$OUTCOME" >> $GITHUB_OUTPUT
              echo "review_completed=true" >> $GITHUB_OUTPUT
              echo "Review outcome: $OUTCOME"
            else
              echo "outcome=failed" >> $GITHUB_OUTPUT
              echo "review_completed=false" >> $GITHUB_OUTPUT
              echo "Review not completed - outcome: $OUTCOME"
            fi
          else
            echo "outcome=failed" >> $GITHUB_OUTPUT
            echo "review_completed=false" >> $GITHUB_OUTPUT
            echo "Result file not found"
          fi

      - name: "1.3 Upload review result"
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: review-result
          path: .claude/skills/story-execution/ci-review-result.json
          retention-days: 1
          if-no-files-found: ignore

  # ════════════════════════════════════════════════════════════════════════════
  # DECOMPOSE: Assess complexity, split into sub-plans if needed (Opus)
  # ════════════════════════════════════════════════════════════════════════════
  decompose:
    needs: [setup-and-plan, validate-plan, verify-implementation, review-plan]
    if: |
      always() &&
      needs.review-plan.outputs.review_completed == 'true' &&
      (needs.review-plan.outputs.outcome == 'proceed' || needs.review-plan.outputs.outcome == 'proceed_with_review')
    runs-on: ubuntu-latest
    timeout-minutes: 20
    outputs:
      complexity: ${{ steps.decompose-output.outputs.complexity }}
      execute_plan: ${{ steps.decompose-output.outputs.execute_plan }}
      sub_plans_created: ${{ steps.decompose-output.outputs.sub_plans_created }}

    steps:
      - name: "2.0 Checkout repository"
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: "2.0.1 Clean up Claude installation locks"
        run: |
          rm -rf /tmp/claude-* 2>/dev/null || true
          rm -rf ~/.claude-install* 2>/dev/null || true
          rm -rf ~/.npm/_locks/* 2>/dev/null || true
          pkill -f "claude" 2>/dev/null || true
          echo "✓ Cleaned up potential installation locks"

      - name: "2.1 Assess plan complexity"
        id: decompose
        uses: anthropics/claude-code-action@v1
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          show_full_output: true
          prompt: |
            You are assessing plan complexity and potentially decomposing it into sub-plans.

            Plan: ${{ needs.setup-and-plan.outputs.plan_path }}
            Story ID: ${{ needs.validate-plan.outputs.story_id || needs.setup-and-plan.outputs.story_id }}
            Plan filename: ${{ needs.setup-and-plan.outputs.plan_filename }}

            ## YOUR TASK

            1. Read the plan file completely
            2. Count the number of TDD tasks
            3. Assess overall complexity based on:
               - Number of tasks (>6 is complex)
               - Cross-file dependencies
               - Integration complexity
               - Test complexity

            ## COMPLEXITY LEVELS

            - **simple**: 1-3 tasks, straightforward changes
            - **medium**: 4-6 tasks, moderate complexity
            - **complex**: 7+ tasks OR high integration complexity

            ## DECOMPOSITION RULES

            If complexity is "complex":
            1. Split into logical sub-plans of 3-5 tasks each
            2. Name sub-plans with letter suffixes: 016A_..., 016B_..., 016C_...
            3. First sub-plan (A) executes now, others saved for future runs
            4. Each sub-plan must be independently executable
            5. Save sub-plans to `.claude/data/plans/`

            ## OUTPUT REQUIRED

            Write a JSON file to `.claude/skills/story-execution/ci-decompose-result.json`:

            ```json
            {
              "complexity": "simple|medium|complex",
              "task_count": 5,
              "execute_plan": ".claude/data/plans/016_configurable-idle-threshold.md",
              "sub_plans_created": [],
              "notes": "Brief explanation"
            }
            ```

            If decomposed:
            ```json
            {
              "complexity": "complex",
              "task_count": 12,
              "execute_plan": ".claude/data/plans/016A_configurable-idle-threshold.md",
              "sub_plans_created": [
                ".claude/data/plans/016B_idle-threshold-integration.md",
                ".claude/data/plans/016C_idle-threshold-ui.md"
              ],
              "notes": "Split into 3 sub-plans: A (validation), B (integration), C (UI)"
            }
            ```

            IMPORTANT: If you create sub-plans, you must:
            1. Move the original plan to executed folder OR keep it if you're just extracting sub-plans
            2. Create the new sub-plan files with proper content
            3. The execute_plan should be the FIRST sub-plan to execute (A suffix)

          claude_args: |
            --allowedTools "Read,Write,Edit,Glob,Grep,Bash(python:*),Bash(python3:*),Bash(mkdir:*),Bash(mv:*),Bash(cp:*)"
            --model claude-opus-4-5-20251101
            --max-turns 25

      - name: "2.2 Read decompose output"
        id: decompose-output
        if: always()
        run: |
          RESULT_FILE=".claude/skills/story-execution/ci-decompose-result.json"
          PLAN_PATH="${{ needs.setup-and-plan.outputs.plan_path }}"

          if [ -f "$RESULT_FILE" ]; then
            COMPLEXITY=$(python3 -c "import json; d=json.load(open('$RESULT_FILE')); print(d.get('complexity','unknown'))")
            EXECUTE_PLAN=$(python3 -c "import json; d=json.load(open('$RESULT_FILE')); print(d.get('execute_plan',''))")
            SUB_PLANS=$(python3 -c "import json; d=json.load(open('$RESULT_FILE')); print(','.join(d.get('sub_plans_created',[])))")

            echo "Complexity: $COMPLEXITY"

            # CRITICAL: Validate that the execute_plan file actually exists
            FINAL_PLAN="${EXECUTE_PLAN:-$PLAN_PATH}"
            if [ -n "$EXECUTE_PLAN" ] && [ ! -f "$EXECUTE_PLAN" ]; then
              echo "⚠️ WARNING: Decompose generated non-existent plan path: $EXECUTE_PLAN"
              echo ""
              echo "Available plans:"
              ls -la .claude/data/plans/*.md 2>/dev/null || echo "(none)"
              echo ""

              # Fall back to original plan if it exists
              if [ -f "$PLAN_PATH" ]; then
                echo "Falling back to original plan: $PLAN_PATH"
                FINAL_PLAN="$PLAN_PATH"
              else
                echo "❌ ERROR: Neither generated plan nor original plan exists!"
                echo "Generated: $EXECUTE_PLAN"
                echo "Original: $PLAN_PATH"
                # Still output something so the execute job can fail gracefully
                FINAL_PLAN="$EXECUTE_PLAN"
              fi
            fi

            echo "complexity=$COMPLEXITY" >> $GITHUB_OUTPUT
            echo "execute_plan=$FINAL_PLAN" >> $GITHUB_OUTPUT
            echo "sub_plans_created=$SUB_PLANS" >> $GITHUB_OUTPUT

            echo "Execute plan: $FINAL_PLAN"
            if [ -n "$SUB_PLANS" ]; then
              echo "Sub-plans created: $SUB_PLANS"
            fi
          else
            # Default to original plan if no result
            echo "complexity=unknown" >> $GITHUB_OUTPUT
            echo "execute_plan=$PLAN_PATH" >> $GITHUB_OUTPUT
            echo "sub_plans_created=" >> $GITHUB_OUTPUT
            echo "No decompose result, using original plan: $PLAN_PATH"
          fi

      - name: "2.3 Commit sub-plans if created"
        if: steps.decompose-output.outputs.sub_plans_created != ''
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Pull latest before staging to avoid conflicts
          git fetch origin main
          git rebase origin/main || git rebase --abort

          git add -A

          if ! git diff --cached --quiet; then
            STORY_ID="${{ needs.setup-and-plan.outputs.story_id }}"
            git commit -m "ci: decompose plan into sub-plans

            Story: $STORY_ID
            Complexity: ${{ steps.decompose-output.outputs.complexity }}
            Sub-plans: ${{ steps.decompose-output.outputs.sub_plans_created }}"

            # Retry push with exponential backoff and pull before retry
            for attempt in 1 2 3 4; do
              if git push origin main; then
                echo "✓ Committed and pushed sub-plans"
                exit 0
              else
                echo "Push failed (attempt $attempt), pulling and retrying..."
                git pull --rebase origin main || true
                sleep $((2 ** attempt))
              fi
            done
            echo "❌ Push failed after 4 attempts"
            exit 1
          else
            echo "No changes to commit"
          fi

      - name: "2.4 Upload decompose result"
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: decompose-result
          path: .claude/skills/story-execution/ci-decompose-result.json
          retention-days: 1
          if-no-files-found: ignore

  # ════════════════════════════════════════════════════════════════════════════
  # EXECUTE: Follow plan's TDD steps directly (Sonnet)
  # ════════════════════════════════════════════════════════════════════════════
  execute:
    needs: [setup-and-plan, validate-plan, verify-implementation, review-plan, decompose]
    if: |
      always() &&
      needs.decompose.outputs.execute_plan != ''
    runs-on: ubuntu-latest
    timeout-minutes: 45
    outputs:
      status: ${{ steps.execute-output.outputs.status }}
      commits_made: ${{ steps.execute-output.outputs.commits_made }}

    steps:
      - name: "3.0 Checkout repository"
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: "3.1 Pull latest changes"
        run: |
          git pull origin main --rebase || true

      - name: "3.1.1 Clean up Claude installation locks"
        run: |
          rm -rf /tmp/claude-* 2>/dev/null || true
          rm -rf ~/.claude-install* 2>/dev/null || true
          rm -rf ~/.npm/_locks/* 2>/dev/null || true
          pkill -f "claude" 2>/dev/null || true
          echo "✓ Cleaned up potential installation locks"

      - name: "3.1.2 Verify plan file exists"
        id: verify-plan
        run: |
          PLAN_PATH="${{ needs.decompose.outputs.execute_plan }}"
          echo "Checking plan file: $PLAN_PATH"

          if [ -z "$PLAN_PATH" ]; then
            echo "❌ No plan path provided by decompose job"
            echo "plan_exists=false" >> $GITHUB_OUTPUT
            exit 1
          fi

          if [ ! -f "$PLAN_PATH" ]; then
            echo "❌ Plan file does not exist: $PLAN_PATH"
            echo ""
            echo "Available plans in .claude/data/plans/:"
            ls -la .claude/data/plans/*.md 2>/dev/null || echo "(none)"
            echo ""
            echo "Recently executed plans:"
            ls -la .claude/data/executed/*.md 2>/dev/null | head -5 || echo "(none)"
            echo "plan_exists=false" >> $GITHUB_OUTPUT
            exit 1
          fi

          echo "✓ Plan file verified: $PLAN_PATH"
          echo "plan_exists=true" >> $GITHUB_OUTPUT

      - name: "3.1.3 Setup Python environment"
        run: |
          echo "Setting up Python environment..."
          python3 --version
          python3 -m pip install --upgrade pip
          python3 -m pip install pytest
          python3 -m pytest --version
          echo "✓ Python environment ready with pytest"

      - name: "3.2 Execute plan"
        id: execute
        uses: anthropics/claude-code-action@v1
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          show_full_output: true
          prompt: |
            You are executing a TDD implementation plan in CI mode.

            Plan to execute: ${{ needs.decompose.outputs.execute_plan }}
            Story ID: ${{ needs.validate-plan.outputs.story_id || needs.setup-and-plan.outputs.story_id }}
            Review outcome: ${{ needs.review-plan.outputs.outcome }}

            ## YOUR TASK

            1. Read the plan document completely
            2. Follow EACH task's TDD steps EXACTLY as written in the plan:
               - RED: Write the failing test as specified
               - Verify RED: Run the test, confirm it fails for the right reason
               - GREEN: Implement the code as specified
               - Verify GREEN: Run the test, confirm it passes
               - COMMIT: Stage and commit with the message format shown
            3. Continue through ALL tasks in the plan
            4. After each task, immediately commit your changes

            ## TDD DISCIPLINE

            - Follow the plan's test code EXACTLY - do not modify tests
            - Follow the plan's implementation code as a guide
            - If a test already passes (RED fails to be RED), note it and move on
            - If you get stuck on a task, document what happened and continue

            ## COMMIT FORMAT

            Use the format specified in the plan, typically:
            ```
            feat: [task description]

            Story: ${{ needs.setup-and-plan.outputs.story_id }}
            Task: N of M
            ```

            ## OUTPUT REQUIRED

            After completing all tasks, write to `.claude/skills/story-execution/ci-execute-result.json`:

            ```json
            {
              "status": "completed|partial|failed",
              "tasks_completed": 5,
              "tasks_total": 5,
              "commits": ["abc1234", "def5678", ...],
              "notes": "Brief summary of execution"
            }
            ```

            ## IMPORTANT

            - Read the plan document directly - it contains all instructions
            - The plan has explicit test code and implementation code to follow
            - Do NOT skip the verification steps (run pytest after each RED and GREEN)
            - Commit your changes after each task (push is handled automatically by the workflow)

          claude_args: |
            --allowedTools "Read,Write,Edit,Glob,Grep,Bash(git:*),Bash(python:*),Bash(python3:*),Bash(pytest:*),Bash(pip:*),Bash(pip3:*),Bash(mkdir:*),BashOutput,TodoWrite"
            --model claude-sonnet-4-5-20250929
            --max-turns 50

      - name: "3.3 Push implementation commits"
        if: always()
        run: |
          # Check if there are commits to push
          git fetch origin main
          COMMITS_AHEAD=$(git rev-list origin/main..HEAD --count 2>/dev/null || echo "0")

          if [ "$COMMITS_AHEAD" -gt 0 ]; then
            echo "Found $COMMITS_AHEAD commits to push"

            # Retry push with exponential backoff
            for attempt in 1 2 3 4; do
              if git push origin main; then
                echo "✓ Pushed $COMMITS_AHEAD implementation commits"
                exit 0
              else
                echo "Push failed (attempt $attempt), pulling and retrying..."
                git pull --rebase origin main || true
                sleep $((2 ** attempt))
              fi
            done
            echo "❌ Push failed after 4 attempts"
            exit 1
          else
            echo "No commits to push"
          fi

      - name: "3.4 Read execute output"
        id: execute-output
        if: always()
        run: |
          RESULT_FILE=".claude/skills/story-execution/ci-execute-result.json"

          if [ -f "$RESULT_FILE" ]; then
            STATUS=$(python3 -c "import json; d=json.load(open('$RESULT_FILE')); print(d.get('status','unknown'))")
            COMMITS=$(python3 -c "import json; d=json.load(open('$RESULT_FILE')); print(','.join(d.get('commits',[])))")
            COMPLETED=$(python3 -c "import json; d=json.load(open('$RESULT_FILE')); print(d.get('tasks_completed',0))")
            TOTAL=$(python3 -c "import json; d=json.load(open('$RESULT_FILE')); print(d.get('tasks_total',0))")

            echo "status=$STATUS" >> $GITHUB_OUTPUT
            echo "commits_made=$COMMITS" >> $GITHUB_OUTPUT

            echo "Status: $STATUS"
            echo "Tasks: $COMPLETED/$TOTAL"
            echo "Commits: $COMMITS"
          else
            # Check if there are uncommitted changes or new commits
            UNCOMMITTED=$(git status --porcelain | wc -l)
            NEW_COMMITS=$(git log origin/main..HEAD --oneline 2>/dev/null | wc -l)

            if [ "$NEW_COMMITS" -gt 0 ] || [ "$UNCOMMITTED" -gt 0 ]; then
              echo "status=partial" >> $GITHUB_OUTPUT
              echo "commits_made=" >> $GITHUB_OUTPUT
              echo "No result file, but found $NEW_COMMITS new commits and $UNCOMMITTED uncommitted changes"
            else
              echo "status=failed" >> $GITHUB_OUTPUT
              echo "commits_made=" >> $GITHUB_OUTPUT
              echo "No result file and no changes detected"
            fi
          fi

      - name: "3.5 Upload execute result"
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: execute-result
          path: .claude/skills/story-execution/ci-execute-result.json
          retention-days: 1
          if-no-files-found: ignore

  # ════════════════════════════════════════════════════════════════════════════
  # FINALIZE: Archive, commit, push, report
  # ════════════════════════════════════════════════════════════════════════════
  finalize:
    needs: [setup-and-plan, validate-plan, verify-implementation, review-plan, decompose, execute]
    if: always()
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: "4.0 Checkout repository"
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: "4.0.1 Pull latest changes"
        run: |
          git pull origin main --rebase || true

      - name: "4.1 Determine final outcome"
        id: outcome
        run: |
          SHOULD_EXECUTE="${{ needs.setup-and-plan.outputs.should_execute }}"
          SKIP_REASON="${{ needs.setup-and-plan.outputs.skip_reason }}"
          NEEDS_VERIFICATION="${{ needs.setup-and-plan.outputs.needs_verification }}"
          VERIFICATION_PASSED="${{ needs.verify-implementation.outputs.verification_passed }}"
          SHOULD_PROCEED_TO_EXECUTE="${{ needs.verify-implementation.outputs.should_proceed_to_execute }}"
          PLAN_BLOCKED="${{ needs.validate-plan.outputs.plan_blocked }}"

          # Handle validate-plan blocking the plan (no Story ID found)
          if [ "$PLAN_BLOCKED" = "true" ]; then
            echo "outcome=blocked" >> $GITHUB_OUTPUT
            echo "reason=no_story_id" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Handle verification flow
          if [ "$NEEDS_VERIFICATION" = "true" ]; then
            if [ "$VERIFICATION_PASSED" = "true" ]; then
              # Implementation was verified, plan was archived by verify-implementation job
              echo "outcome=verified" >> $GITHUB_OUTPUT
              echo "reason=implementation_confirmed" >> $GITHUB_OUTPUT
              exit 0
            fi

            VERIFICATION_INCOMPLETE="${{ needs.verify-implementation.outputs.verification_incomplete }}"
            if [ "$VERIFICATION_INCOMPLETE" = "true" ]; then
              # Verification hit max-turns limit, needs manual review
              echo "outcome=needs_manual_review" >> $GITHUB_OUTPUT
              echo "reason=verification_incomplete" >> $GITHUB_OUTPUT
              exit 0
            elif [ "$SHOULD_PROCEED_TO_EXECUTE" != "true" ]; then
              # Verification completed but needs manual review (partial implementation)
              echo "outcome=needs_manual_review" >> $GITHUB_OUTPUT
              echo "reason=partial_implementation" >> $GITHUB_OUTPUT
              exit 0
            fi
            # If should_proceed_to_execute=true, continue to check execution results
          fi

          # If setup determined we shouldn't execute (and not verification flow)
          if [ "$SHOULD_EXECUTE" != "true" ] && [ "$SHOULD_PROCEED_TO_EXECUTE" != "true" ]; then
            echo "outcome=skipped" >> $GITHUB_OUTPUT
            echo "reason=$SKIP_REASON" >> $GITHUB_OUTPUT
            exit 0
          fi

          REVIEW_COMPLETED="${{ needs.review-plan.outputs.review_completed }}"
          if [ "$REVIEW_COMPLETED" != "true" ]; then
            echo "outcome=failure" >> $GITHUB_OUTPUT
            echo "reason=review_failed" >> $GITHUB_OUTPUT
            exit 0
          fi

          REVIEW_OUTCOME="${{ needs.review-plan.outputs.outcome }}"

          # Handle review returning "verified" (already implemented)
          if [ "$REVIEW_OUTCOME" = "verified" ]; then
            echo "outcome=verified" >> $GITHUB_OUTPUT
            echo "reason=already_implemented" >> $GITHUB_OUTPUT
            exit 0
          fi

          if [ "$REVIEW_OUTCOME" = "pause" ]; then
            echo "outcome=paused" >> $GITHUB_OUTPUT
            echo "reason=blocking_issues" >> $GITHUB_OUTPUT
            exit 0
          fi

          EXECUTE_STATUS="${{ needs.execute.outputs.status }}"
          case "$EXECUTE_STATUS" in
            completed)
              if [ "$REVIEW_OUTCOME" = "proceed_with_review" ]; then
                echo "outcome=success" >> $GITHUB_OUTPUT
                echo "needs_review=true" >> $GITHUB_OUTPUT
              else
                echo "outcome=success" >> $GITHUB_OUTPUT
                echo "needs_review=false" >> $GITHUB_OUTPUT
              fi
              ;;
            partial)
              echo "outcome=partial" >> $GITHUB_OUTPUT
              echo "needs_review=true" >> $GITHUB_OUTPUT
              ;;
            failed|"")
              echo "outcome=failure" >> $GITHUB_OUTPUT
              echo "reason=execution_failed" >> $GITHUB_OUTPUT
              ;;
            *)
              echo "outcome=unknown" >> $GITHUB_OUTPUT
              echo "reason=unknown_status" >> $GITHUB_OUTPUT
              ;;
          esac

      - name: "4.2 Archive executed plan"
        if: steps.outcome.outputs.outcome == 'success' || steps.outcome.outputs.outcome == 'verified'
        run: |
          # Use decompose output if available, otherwise use original plan path
          EXECUTE_PLAN="${{ needs.decompose.outputs.execute_plan }}"
          if [ -z "$EXECUTE_PLAN" ]; then
            EXECUTE_PLAN="${{ needs.setup-and-plan.outputs.plan_path }}"
          fi
          ARCHIVE_DIR=".claude/data/executed"

          if [ -f "$EXECUTE_PLAN" ]; then
            mkdir -p "$ARCHIVE_DIR"
            mv "$EXECUTE_PLAN" "$ARCHIVE_DIR/"
            echo "✓ Archived: $EXECUTE_PLAN → $ARCHIVE_DIR/"
          else
            echo "Plan already archived or moved"
          fi

      - name: "4.3 Update story status in database"
        if: |
          (steps.outcome.outputs.outcome == 'success' ||
           steps.outcome.outputs.outcome == 'partial' ||
           steps.outcome.outputs.outcome == 'verified') &&
          (needs.validate-plan.outputs.story_id != 'none' || needs.setup-and-plan.outputs.story_id != 'none')
        run: |
          # Use story_id from validate-plan if available, otherwise from setup-and-plan
          STORY_ID="${{ needs.validate-plan.outputs.story_id }}"
          if [ -z "$STORY_ID" ] || [ "$STORY_ID" = "none" ]; then
            STORY_ID="${{ needs.setup-and-plan.outputs.story_id }}"
          fi

          if [ -z "$STORY_ID" ] || [ "$STORY_ID" = "none" ]; then
            echo "No Story ID available, skipping database update"
            exit 0
          fi

          DB_PATH=".claude/data/story-tree.db"
          NEEDS_REVIEW="${{ steps.outcome.outputs.needs_review }}"
          OUTCOME="${{ steps.outcome.outputs.outcome }}"

          if [ ! -f "$DB_PATH" ]; then
            echo "Database not found, skipping status update"
            exit 0
          fi

          if [ "$OUTCOME" = "verified" ]; then
            STAGE="implemented"
            NOTE="CI verified: implementation already exists"
            REVIEW_FLAG=0
          elif [ "$NEEDS_REVIEW" = "true" ]; then
            STAGE="reviewing"
            NOTE="CI execution $OUTCOME (review required)"
            REVIEW_FLAG=1
          else
            STAGE="verifying"
            NOTE="CI execution complete"
            REVIEW_FLAG=0
          fi

          python3 << PYEOF
          import sqlite3
          conn = sqlite3.connect("$DB_PATH")
          conn.execute('''
              UPDATE story_nodes
              SET stage = '$STAGE',
                  human_review = $REVIEW_FLAG,
                  notes = COALESCE(notes || char(10), '') || '$NOTE: ' || datetime('now'),
                  updated_at = datetime('now')
              WHERE id = ?
          ''', ("$STORY_ID",))
          conn.commit()
          print(f"✓ Updated story $STORY_ID → $STAGE")
          conn.close()
          PYEOF

      - name: "4.4 Stage all changes"
        if: steps.outcome.outputs.outcome == 'success' || steps.outcome.outputs.outcome == 'partial' || steps.outcome.outputs.outcome == 'verified'
        id: stage
        run: |
          git add -A
          if git diff --cached --quiet; then
            echo "has_changes=false" >> $GITHUB_OUTPUT
            echo "No changes to commit"
          else
            echo "has_changes=true" >> $GITHUB_OUTPUT
            echo "Changes staged for commit:"
            git diff --cached --stat
          fi

      - name: "4.5 Commit changes"
        if: steps.stage.outputs.has_changes == 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          EXECUTE_PLAN="${{ needs.decompose.outputs.execute_plan }}"
          STORY_ID="${{ needs.setup-and-plan.outputs.story_id }}"
          PLAN_FILENAME=$(basename "$EXECUTE_PLAN")

          git commit -m "ci: execute plan $PLAN_FILENAME

          Story: $STORY_ID"

          echo "✓ Committed changes"

      - name: "4.6 Push to remote"
        if: steps.stage.outputs.has_changes == 'true'
        run: |
          for attempt in 1 2 3 4; do
            if git push origin main; then
              echo "✓ Push successful"
              exit 0
            else
              echo "Push failed (attempt $attempt), pulling and retrying..."
              git pull --rebase origin main || true
              sleep $((2 ** attempt))
            fi
          done
          echo "❌ Push failed after 4 attempts"
          exit 1

      # ── REPORTING ──
      - name: "4.7 Generate execution summary"
        if: always()
        run: |
          echo "## Execution Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          PLAN_SELECTED="${{ needs.setup-and-plan.outputs.plan_selected }}"
          if [ "$PLAN_SELECTED" = "true" ]; then
            echo "| Field | Value |" >> $GITHUB_STEP_SUMMARY
            echo "|-------|-------|" >> $GITHUB_STEP_SUMMARY
            echo "| Plan | \`${{ needs.setup-and-plan.outputs.plan_filename }}\` |" >> $GITHUB_STEP_SUMMARY
            echo "| Sequence | ${{ needs.setup-and-plan.outputs.plan_sequence }} |" >> $GITHUB_STEP_SUMMARY
            echo "| Story ID | ${{ needs.setup-and-plan.outputs.story_id }} |" >> $GITHUB_STEP_SUMMARY
            echo "| Complexity | ${{ needs.decompose.outputs.complexity }} |" >> $GITHUB_STEP_SUMMARY

            OUTCOME="${{ steps.outcome.outputs.outcome }}"
            case "$OUTCOME" in
              success)
                if [ "${{ steps.outcome.outputs.needs_review }}" = "true" ]; then
                  echo "| Outcome | ✅ Success (review required) |" >> $GITHUB_STEP_SUMMARY
                else
                  echo "| Outcome | ✅ Success |" >> $GITHUB_STEP_SUMMARY
                fi
                ;;
              verified)
                REASON="${{ steps.outcome.outputs.reason }}"
                if [ "$REASON" = "already_implemented" ]; then
                  echo "| Outcome | ✅ Verified (already implemented) |" >> $GITHUB_STEP_SUMMARY
                else
                  echo "| Outcome | ✅ Verified (implementation confirmed) |" >> $GITHUB_STEP_SUMMARY
                fi
                ;;
              blocked)
                echo "| Outcome | 🚫 Blocked (no Story ID found) |" >> $GITHUB_STEP_SUMMARY
                ;;
              needs_manual_review)
                REASON="${{ steps.outcome.outputs.reason }}"
                if [ "$REASON" = "verification_incomplete" ]; then
                  echo "| Outcome | 🔍 Needs Manual Review (verification timed out) |" >> $GITHUB_STEP_SUMMARY
                else
                  echo "| Outcome | 🔍 Needs Manual Review (partial implementation) |" >> $GITHUB_STEP_SUMMARY
                fi
                ;;
              partial)
                echo "| Outcome | ⚠️ Partial (review required) |" >> $GITHUB_STEP_SUMMARY
                ;;
              paused)
                echo "| Outcome | ⏸️ Paused (blocking issues) |" >> $GITHUB_STEP_SUMMARY
                ;;
              failure)
                echo "| Outcome | ❌ Failed |" >> $GITHUB_STEP_SUMMARY
                echo "| Reason | ${{ steps.outcome.outputs.reason }} |" >> $GITHUB_STEP_SUMMARY
                ;;
              skipped)
                SKIP_REASON="${{ needs.setup-and-plan.outputs.skip_reason }}"
                case "$SKIP_REASON" in
                  already_executed)
                    echo "| Outcome | ⏭️ Skipped (already executed) |" >> $GITHUB_STEP_SUMMARY
                    ;;
                  deps_unmet)
                    echo "| Outcome | 🚧 Blocked (unmet deps) |" >> $GITHUB_STEP_SUMMARY
                    ;;
                  *)
                    echo "| Outcome | ⏭️ Skipped ($SKIP_REASON) |" >> $GITHUB_STEP_SUMMARY
                    ;;
                esac
                ;;
              *)
                echo "| Outcome | ⚠️ Unknown |" >> $GITHUB_STEP_SUMMARY
                ;;
            esac
          else
            echo "No plan files available for execution." >> $GITHUB_STEP_SUMMARY
          fi

      - name: "4.8 Report pipeline status"
        if: always() && needs.setup-and-plan.outputs.plan_selected == 'true'
        run: |
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Pipeline Stages" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Stage | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| setup-and-plan | ✅ |" >> $GITHUB_STEP_SUMMARY

          # Report validate-plan stage if it ran (when story_id was 'none')
          STORY_ID="${{ needs.setup-and-plan.outputs.story_id }}"
          if [ "$STORY_ID" = "none" ]; then
            PLAN_BLOCKED="${{ needs.validate-plan.outputs.plan_blocked }}"
            VALIDATED_STORY_ID="${{ needs.validate-plan.outputs.story_id }}"
            if [ "$PLAN_BLOCKED" = "true" ]; then
              echo "| validate-plan | 🚫 blocked (no match) |" >> $GITHUB_STEP_SUMMARY
            elif [ -n "$VALIDATED_STORY_ID" ] && [ "$VALIDATED_STORY_ID" != "none" ]; then
              echo "| validate-plan | ✅ matched ($VALIDATED_STORY_ID) |" >> $GITHUB_STEP_SUMMARY
            else
              echo "| validate-plan | ⏭️ skipped |" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "| validate-plan | ⏭️ skipped (has ID) |" >> $GITHUB_STEP_SUMMARY
          fi

          # Report verification stage if it ran
          NEEDS_VERIFICATION="${{ needs.setup-and-plan.outputs.needs_verification }}"
          if [ "$NEEDS_VERIFICATION" = "true" ]; then
            VERIFICATION_PASSED="${{ needs.verify-implementation.outputs.verification_passed }}"
            VERIFICATION_INCOMPLETE="${{ needs.verify-implementation.outputs.verification_incomplete }}"
            if [ "$VERIFICATION_PASSED" = "true" ]; then
              echo "| verify-implementation | ✅ passed |" >> $GITHUB_STEP_SUMMARY
            elif [ "$VERIFICATION_INCOMPLETE" = "true" ]; then
              echo "| verify-implementation | ⏱️ timed out → manual review |" >> $GITHUB_STEP_SUMMARY
            else
              SHOULD_EXECUTE="${{ needs.verify-implementation.outputs.should_proceed_to_execute }}"
              if [ "$SHOULD_EXECUTE" = "true" ]; then
                echo "| verify-implementation | ⚠️ failed → re-execute |" >> $GITHUB_STEP_SUMMARY
              else
                echo "| verify-implementation | 🔍 partial → manual review |" >> $GITHUB_STEP_SUMMARY
              fi
            fi
          fi

          REVIEW="${{ needs.review-plan.outputs.outcome }}"
          if [ -n "$REVIEW" ]; then
            echo "| review-plan | $REVIEW |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| review-plan | ⏭️ skipped |" >> $GITHUB_STEP_SUMMARY
          fi

          COMPLEXITY="${{ needs.decompose.outputs.complexity }}"
          if [ -n "$COMPLEXITY" ]; then
            echo "| decompose | $COMPLEXITY |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| decompose | ⏭️ skipped |" >> $GITHUB_STEP_SUMMARY
          fi

          EXECUTE="${{ needs.execute.outputs.status }}"
          if [ -n "$EXECUTE" ]; then
            echo "| execute | $EXECUTE |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| execute | ⏭️ skipped |" >> $GITHUB_STEP_SUMMARY
          fi

          echo "| finalize | ${{ steps.outcome.outputs.outcome }} |" >> $GITHUB_STEP_SUMMARY

      - name: "4.9 Post results to story issue"
        if: |
          always() &&
          needs.setup-and-plan.outputs.plan_selected == 'true' &&
          (needs.setup-and-plan.outputs.story_id != 'none' && needs.setup-and-plan.outputs.story_id != '' ||
           needs.validate-plan.outputs.story_id != 'none' && needs.validate-plan.outputs.story_id != '')
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Use story_id from validate-plan if available, otherwise from setup-and-plan
          STORY_ID="${{ needs.validate-plan.outputs.story_id }}"
          if [ -z "$STORY_ID" ] || [ "$STORY_ID" = "none" ]; then
            STORY_ID="${{ needs.setup-and-plan.outputs.story_id }}"
          fi

          if [ -z "$STORY_ID" ] || [ "$STORY_ID" = "none" ]; then
            echo "No Story ID available, skipping issue posting"
            exit 0
          fi
          # Use decompose output if available, otherwise fall back to setup-and-plan
          EXECUTE_PLAN="${{ needs.decompose.outputs.execute_plan }}"
          if [ -z "$EXECUTE_PLAN" ]; then
            EXECUTE_PLAN="${{ needs.setup-and-plan.outputs.plan_path }}"
          fi
          PLAN_FILENAME="${{ needs.setup-and-plan.outputs.plan_filename }}"
          if [ -z "$PLAN_FILENAME" ]; then
            PLAN_FILENAME=$(basename "$EXECUTE_PLAN" 2>/dev/null || echo "unknown")
          fi
          COMPLEXITY="${{ needs.decompose.outputs.complexity }}"
          if [ -z "$COMPLEXITY" ]; then
            COMPLEXITY="(verified - skipped)"
          fi
          DB_PATH=".claude/data/story-tree.db"

          TITLE=""
          if [ -f "$DB_PATH" ]; then
            TITLE=$(python3 -c "import sqlite3; c=sqlite3.connect('$DB_PATH'); r=c.execute('SELECT title FROM story_nodes WHERE id=?',('$STORY_ID',)).fetchone(); print(r[0] if r else '')" 2>/dev/null)
          fi
          TITLE="${TITLE:-Story $STORY_ID}"

          ISSUE_TITLE="$STORY_ID - $TITLE"

          ISSUE_NUM=$(gh issue list --state all --search "\"$ISSUE_TITLE\" in:title" --json number,title --jq ".[] | select(.title == \"$ISSUE_TITLE\") | .number" | head -1)

          if [ -z "$ISSUE_NUM" ]; then
            ISSUE_NUM=$(gh issue create --title "$ISSUE_TITLE" --body "Tracking issue for story **$STORY_ID**" --label "story-tracking" 2>/dev/null | grep -oP 'issues/\K[0-9]+' || \
                        gh issue create --title "$ISSUE_TITLE" --body "Tracking issue for story **$STORY_ID**" | grep -oP 'issues/\K[0-9]+' || echo "")
          fi

          if [ -z "$ISSUE_NUM" ]; then
            echo "Could not find/create issue"
            exit 0
          fi

          OUTCOME="${{ steps.outcome.outputs.outcome }}"
          REASON="${{ steps.outcome.outputs.reason }}"
          case "$OUTCOME" in
            success)
              if [ "${{ steps.outcome.outputs.needs_review }}" = "true" ]; then
                STATUS="✅ Success (review required)"
              else
                STATUS="✅ Success"
              fi
              ;;
            verified)
              if [ "$REASON" = "already_implemented" ]; then
                STATUS="✅ Verified (already implemented - plan archived)"
              else
                STATUS="✅ Verified (implementation confirmed in codebase)"
              fi
              ;;
            blocked)
              STATUS="🚫 Blocked (no matching Story ID found)"
              ;;
            needs_manual_review)
              if [ "$REASON" = "verification_incomplete" ]; then
                STATUS="🔍 Needs Manual Review (verification timed out - please check if implementation exists)"
              else
                STATUS="🔍 Needs Manual Review (partial implementation detected)"
              fi
              ;;
            partial)
              STATUS="⚠️ Partial (review required)"
              ;;
            paused)
              STATUS="⏸️ Paused (blocking issues)"
              ;;
            failure)
              STATUS="❌ Failed"
              ;;
            skipped)
              SKIP_REASON="${{ needs.setup-and-plan.outputs.skip_reason }}"
              case "$SKIP_REASON" in
                already_executed) STATUS="⏭️ Skipped (already executed)" ;;
                deps_unmet) STATUS="🚧 Blocked (unmet dependencies)" ;;
                *) STATUS="⏭️ Skipped ($SKIP_REASON)" ;;
              esac
              ;;
            *)
              STATUS="⚠️ $OUTCOME"
              ;;
          esac

          RUN_URL="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"

          BODY="## $STATUS

          **Plan:** \`$PLAN_FILENAME\`
          **Complexity:** $COMPLEXITY
          **Time:** $(date -u +'%Y-%m-%d %H:%M:%S UTC')
          **Run:** [View Details]($RUN_URL)

          ---
          *Posted by [execute-stories workflow]($RUN_URL)*"

          echo "$BODY" | gh issue comment "$ISSUE_NUM" --body-file -
          echo "Posted to issue #$ISSUE_NUM"
