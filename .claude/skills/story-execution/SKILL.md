---
name: story-execution
description: Use when user says "execute plan", "implement story", "run plan for [ID]", "start implementation", or asks to execute a planned story - loads TDD implementation plan from .claude/data/plans/, executes RED-GREEN-COMMIT cycles for each task, updates story status through active→reviewing→implemented, verifies acceptance criteria, and outputs implementation report. (project)
---

# Story Execution - TDD Plan Implementation Engine

Execute TDD implementation plans generated by story-planning skill.

**Announce:** On activation, say: "I'm using the story-execution skill to implement the plan."

**Database:** `.claude/data/story-tree.db`
**Plans:** `.claude/data/plans/`

**Critical:** Use Python sqlite3 module, NOT sqlite3 CLI.

## Design Principles

- **TDD Discipline:** Follow RED→GREEN→COMMIT strictly - no shortcuts
- **Atomic Progress:** One task at a time, commit after each GREEN
- **Fail Fast:** Stop execution on RED verification failure (test passes when it shouldn't)
- **Traceability:** All commits include story ID for attribution
- **Recovery:** Track progress to allow resumption after interruption

## Mode Detection

**CI Mode** activates when:
- Environment variable `CI=true` is set, OR
- Trigger phrase includes "(ci)" like "execute plan (ci)"

**CI Mode behavior:**
- No confirmation prompts between tasks
- Compact progress output
- Auto-skip already-completed tasks (based on git history)
- Structured summary output

**Interactive Mode** (default):
- Pause after each task for confirmation
- Verbose progress with explanations
- Allow task-level skip/retry decisions

## Workflow

### Step 1: Load Plan File

**If user provides story ID:**
```python
python -c "
import json
from pathlib import Path

story_id = '[STORY_ID]'  # From user input
plans_dir = Path('.claude/data/plans')

# Find plan file matching story ID
matches = []
for plan_file in plans_dir.glob('*.md'):
    content = plan_file.read_text()
    if f'**Story ID:** {story_id}' in content or f'Story ID: {story_id}' in content:
        matches.append(plan_file.name)

print(json.dumps({'story_id': story_id, 'matches': matches}))
"
```

**If user provides filename:**
- Load directly from `.claude/data/plans/[filename]`

**If no plan specified:**
```python
python -c "
import sqlite3, json
from pathlib import Path

conn = sqlite3.connect('.claude/data/story-tree.db')
conn.row_factory = sqlite3.Row

# Get oldest planned story
planned = conn.execute('''
    SELECT id, title, notes FROM story_nodes
    WHERE status = 'planned'
    ORDER BY updated_at ASC
    LIMIT 1
''').fetchone()

if planned:
    # Extract plan path from notes
    notes = planned['notes'] or ''
    plan_line = [l for l in notes.split('\n') if 'Plan:' in l]
    plan_path = plan_line[0].split('Plan:')[1].strip() if plan_line else None
    print(json.dumps({
        'id': planned['id'],
        'title': planned['title'],
        'plan_path': plan_path
    }))
else:
    print(json.dumps({'error': 'No planned stories found'}))

conn.close()
"
```

### Step 2: Parse Plan Structure

Read the plan file and extract:

1. **Story Metadata:**
   - Story ID
   - Title
   - Acceptance criteria (checklist items)

2. **Prerequisites:**
   - Virtual environment activation
   - Baseline test verification
   - Dependency stories

3. **TDD Tasks:**
   For each `### Task N:` section, extract:
   - Task name
   - Files to create/modify
   - RED step (test code + verification command)
   - GREEN step (implementation code + verification command)
   - COMMIT step (git command)

4. **Verification Checklist:**
   - Final test commands
   - Manual verification steps

**Plan Parsing Pattern:**
```
### Task N: [Name]         → task_name
**Files:**                 → files_affected
**Step 1 - RED:**          → red_test_code, red_verify_cmd
**Step 2 - Verify RED:**   → red_expected_output
**Step 3 - GREEN:**        → green_impl_code
**Step 4 - Verify GREEN:** → green_verify_cmd
**Step 5 - COMMIT:**       → commit_cmd
```

### Step 3: Update Status to Active

```python
python -c "
import sqlite3
conn = sqlite3.connect('.claude/data/story-tree.db')
conn.execute('''
    UPDATE story_nodes
    SET status = 'active',
        notes = COALESCE(notes || chr(10), '') || 'Execution started: ' || datetime('now'),
        updated_at = datetime('now')
    WHERE id = '[STORY_ID]'
''')
conn.commit()
print('Status updated: planned -> active')
conn.close()
"
```

### Step 4: Execute TDD Cycles

For each task in the plan:

#### 4a. Announce Task
```
=== Task N/M: [Task Name] ===
Files: [list]
```

#### 4b. Execute RED Phase

1. **Write failing test:**
   - Use Edit/Write tool to create test file with code from plan
   - Ensure exact code from plan (copy-paste ready)

2. **Run test - verify failure:**
   ```bash
   [red_verify_cmd from plan]
   ```

3. **Validate RED:**
   - Test MUST fail with expected error
   - If test passes: **STOP** - test is not testing new behavior
   - If different error: Review and fix test

**RED Success Criteria:**
- Test runs without syntax errors
- Test fails for the expected reason
- Failure message matches expected pattern

#### 4c. Execute GREEN Phase

1. **Write minimal implementation:**
   - Use Edit/Write tool to modify files with code from plan
   - Follow exact line numbers and code from plan

2. **Run test - verify pass:**
   ```bash
   [green_verify_cmd from plan]
   ```

3. **Validate GREEN:**
   - Test MUST pass
   - If test fails: Debug and fix implementation
   - Run full test suite to check for regressions:
     ```bash
     python -m pytest -v
     ```

**GREEN Success Criteria:**
- Specific test passes
- No regressions in existing tests
- Implementation matches plan (no extra features)

#### 4d. Execute COMMIT Phase

1. **Stage and commit:**
   ```bash
   [commit_cmd from plan]
   ```

2. **Verify commit:**
   ```bash
   git log -1 --oneline
   ```

**Commit Message Format:**
Include story ID for traceability:
```
feat(module): description

Story: [STORY_ID]
```

#### 4e. Progress Tracking

After each task, update progress note:
```python
python -c "
import sqlite3
conn = sqlite3.connect('.claude/data/story-tree.db')
conn.execute('''
    UPDATE story_nodes
    SET notes = COALESCE(notes || chr(10), '') || 'Task N complete: [task_name] @ ' || datetime('now'),
        updated_at = datetime('now')
    WHERE id = '[STORY_ID]'
''')
conn.commit()
conn.close()
"
```

**Interactive Mode:** Pause for confirmation before next task
**CI Mode:** Continue automatically

### Step 5: Run Final Verification

After all tasks complete:

1. **Run full test suite:**
   ```bash
   python -m pytest -v
   ```

2. **Run module tests (if applicable):**
   ```bash
   python -m syncopaid.[module]
   ```

3. **Check acceptance criteria:**
   - Read original story acceptance criteria
   - Verify each criterion is met by implementation
   - Mark verified criteria in output

### Step 6: Update Status to Reviewing

```python
python -c "
import sqlite3
from datetime import datetime

conn = sqlite3.connect('.claude/data/story-tree.db')
conn.execute('''
    UPDATE story_nodes
    SET status = 'reviewing',
        notes = COALESCE(notes || chr(10), '') || 'Execution complete: ' || datetime('now'),
        updated_at = datetime('now')
    WHERE id = '[STORY_ID]'
''')
conn.commit()
print('Status updated: active -> reviewing')
conn.close()
"
```

### Step 7: Verify Acceptance Criteria

Read the story's acceptance criteria and verify each one:

```python
python -c "
import sqlite3, json
conn = sqlite3.connect('.claude/data/story-tree.db')
conn.row_factory = sqlite3.Row
story = conn.execute('''
    SELECT id, title, description, notes
    FROM story_nodes WHERE id = '[STORY_ID]'
''').fetchone()
print(json.dumps(dict(story), indent=2))
conn.close()
"
```

**For each acceptance criterion:**
1. Identify how to verify (test exists, behavior observable, etc.)
2. Execute verification
3. Document result

**If all criteria pass:** Proceed to Step 8
**If any criteria fail:**
- Document which failed
- Create follow-up task or fix immediately
- Keep status as `reviewing`

### Step 8: Update Status to Implemented

Only after all acceptance criteria verified:

```python
python -c "
import sqlite3
from datetime import datetime

conn = sqlite3.connect('.claude/data/story-tree.db')
conn.execute('''
    UPDATE story_nodes
    SET status = 'implemented',
        last_implemented = datetime('now'),
        notes = COALESCE(notes || chr(10), '') || 'Verified complete: ' || datetime('now'),
        updated_at = datetime('now')
    WHERE id = '[STORY_ID]'
''')
conn.commit()
print('Status updated: reviewing -> implemented')
conn.close()
"
```

### Step 9: Link Commits to Story

Record all commits made during execution:

```python
python -c "
import sqlite3
import subprocess
import re

story_id = '[STORY_ID]'

# Get commits from this execution (last N commits with story ID)
result = subprocess.run(
    ['git', 'log', '--oneline', '-20'],
    capture_output=True, text=True
)

commits = []
for line in result.stdout.strip().split('\n'):
    if story_id in line or len(commits) < 10:  # Rough filter
        parts = line.split(' ', 1)
        if len(parts) == 2:
            commits.append((parts[0], parts[1]))

conn = sqlite3.connect('.claude/data/story-tree.db')
for hash, msg in commits:
    conn.execute('''
        INSERT OR IGNORE INTO story_commits (story_id, commit_hash, commit_date, commit_message)
        VALUES (?, ?, datetime('now'), ?)
    ''', (story_id, hash, msg))
conn.commit()
print(f'Linked {len(commits)} commits to story {story_id}')
conn.close()
"
```

## Error Handling

### RED Phase Failure (Test Passes Unexpectedly)

**Problem:** Test should fail but passes - indicates test doesn't test new behavior.

**Resolution:**
1. Review test assertions
2. Check if feature already exists
3. Modify test to properly detect missing implementation
4. Re-run RED phase

### GREEN Phase Failure (Test Still Fails)

**Problem:** Implementation doesn't satisfy test.

**Resolution:**
1. Compare implementation to plan
2. Check for typos, missing imports
3. Debug with print statements or debugger
4. If plan is incorrect, note discrepancy and fix
5. Re-run GREEN phase

### Regression Detected

**Problem:** Existing test fails after implementation.

**Resolution:**
1. Identify which test fails
2. Determine if implementation broke existing behavior
3. Fix implementation to preserve existing behavior
4. Re-run full test suite

### Interrupted Execution

**Problem:** Execution stopped mid-plan.

**Resolution:**
1. Check git log for completed commits
2. Check story notes for completed tasks
3. Resume from next uncompleted task
4. Use `--resume` flag or specify starting task

## Output Format

### CI Mode - Success

```
=== Story Execution Complete ===
Story: [STORY_ID] - [Title]
Plan: [plan_filename]
Tasks: [N]/[N] completed
Commits: [list of commit hashes]
Status: planned -> active -> reviewing -> implemented

Acceptance Criteria:
[x] Criterion 1
[x] Criterion 2
[x] Criterion 3

Duration: [time]
```

### CI Mode - Partial

```
=== Story Execution Incomplete ===
Story: [STORY_ID] - [Title]
Plan: [plan_filename]
Tasks: [M]/[N] completed
Status: active (paused)

Blocked at: Task [M+1] - [task_name]
Reason: [RED/GREEN] phase failed
Error: [error message]

To resume: "execute plan [STORY_ID] --resume"
```

### Interactive Mode

Conversational progress with task-by-task confirmation and detailed output.

## Related Skills

- **story-planning:** Creates the plans this skill executes
- **story-tree:** Manages story hierarchy and status
- **prioritize-story-notes:** Selects which planned story to execute first

## References

- Plan format: `.claude/data/plans/*.md`
- Status workflow: concept → approved → planned → active → reviewing → implemented
- Commit format: Include `Story: [ID]` in commit body for traceability
