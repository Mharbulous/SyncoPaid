# UI Automation Integration - Implementation Plan

> **For Claude:** This plan follows strict TDD (Test-Driven Development). Each task MUST complete all 5 steps in order: Write test → Verify RED → Write code → Verify GREEN → Commit.

**Goal:** Extract email subjects from Outlook and folder paths from Windows Explorer for richer activity categorization.

**Approach:** Implement a new `ui_automation.py` module using `pywinauto` library with browser-specific extractors. Integrate with existing `TrackerLoop` via optional UI automation worker. Add configuration flags for granular enable/disable control per application.

**Tech Stack:** `pywinauto`, `syncopaid.tracker`, `syncopaid.config`, `syncopaid.database`, `pytest`

---

**Story ID:** 1.8.3
**Created:** 2025-12-16
**Status:** `planned`

---

## Story Context

**Title:** UI Automation Integration

**Description:**
**As a** lawyer using email and file explorer frequently
**I want** richer activity capture from Outlook and Windows Explorer
**So that** AI can see email subjects and folder paths for better activity categorization

**Acceptance Criteria:**
- [ ] Extract email subject/sender from Outlook (Legacy) reading pane or open email
- [ ] Extract current folder path from Windows Explorer address bar
- [ ] Store extracted data in events table (extend schema if needed)
- [ ] Handle applications not responding gracefully (timeout, fallback to title-only)
- [ ] Configurable enable/disable per application in settings
- [ ] Minimal performance impact (<100ms per extraction)

**Technical Notes:**
- Use `uiautomation` or `pywinauto` library (same as 1.8.2)
- Share UI Automation utilities with 1.8.2 if natural fit, but don't over-engineer
- Extract only when Outlook/Explorer is active window
- New Outlook app may not expose email subjects (Legacy Outlook recommended)
- Consider background thread to avoid blocking tracker

**Scope:**
- Outlook (Legacy): Email subject and sender when reading/composing
- Windows Explorer: Current folder path from address bar
- Browsers handled separately in 1.8.2

**Notes:** None

## Prerequisites

- [ ] Python 3.11+ with venv activated: `venv\Scripts\activate`
- [ ] Dependencies installed: `pywinauto` (will add to requirements.txt)
- [ ] Related stories complete: None (independent)
- [ ] Baseline tests passing: `python -m pytest -v`

## Files Affected

| File | Change Type | Purpose |
|------|-------------|---------|
| `tests/test_ui_automation.py` | Create | Test UI automation extraction logic |
| `src/syncopaid/ui_automation.py` | Create | New module for Outlook/Explorer extraction |
| `src/syncopaid/tracker.py:100-112` | Modify | Extend ActivityEvent to include extracted_metadata field |
| `src/syncopaid/tracker.py:257-335` | Modify | Integrate UI automation extraction in TrackerLoop.start() |
| `src/syncopaid/config.py:16-37` | Modify | Add ui_automation_enabled config settings |
| `src/syncopaid/database.py:80-112` | Modify | Extend events table schema with metadata column |
| `requirements.txt` | Modify | Add pywinauto dependency |

## TDD Implementation Tasks

### Task 1: Add pywinauto Dependency

**Objective:** Install and configure pywinauto library for UI automation testing.

**Files:**
- Implementation: `requirements.txt`

---

**⚠️ TDD CHECKPOINT 1: RED - Write Failing Test**

Create test that verifies pywinauto is importable:

```python
# tests/test_ui_automation.py
def test_pywinauto_available():
    """Test that pywinauto library is installed and importable."""
    try:
        import pywinauto
        assert pywinauto is not None
    except ImportError:
        pytest.fail("pywinauto library not installed")
```

**Verify RED:**
```bash
python -m pytest tests/test_ui_automation.py::test_pywinauto_available -v
```
**Expected output:** `FAILED` - ImportError: No module named 'pywinauto'

---

**⚠️ TDD CHECKPOINT 2: GREEN - Minimal Implementation**

Add pywinauto to requirements:

```
# requirements.txt (add this line)
pywinauto>=0.6.8
```

Install dependency:
```bash
pip install pywinauto
```

**Verify GREEN:**
```bash
python -m pytest tests/test_ui_automation.py::test_pywinauto_available -v
```
**Expected output:** `PASSED` - Test succeeds

---

**⚠️ TDD CHECKPOINT 3: COMMIT**

Commit working test + implementation:

```bash
git add tests/test_ui_automation.py requirements.txt
git commit -m "feat: add pywinauto dependency for UI automation

- Add test verifying pywinauto installation
- Add pywinauto>=0.6.8 to requirements.txt
- Acceptance criteria: UI automation library available"
```

**Expected output:** Commit created with hash

---

### Task 2: Extend Database Schema with Metadata Column

**Objective:** Add `metadata` JSON column to events table for storing extracted UI automation data.

**Files:**
- Test: `tests/test_database.py` (extend existing tests)
- Implementation: `src/syncopaid/database.py:80-112`

---

**⚠️ TDD CHECKPOINT 1: RED - Write Failing Test**

Create test that verifies metadata column exists and can store JSON:

```python
# tests/test_database.py (add to existing file)
def test_metadata_column_stores_json():
    """Test that events table has metadata column that accepts JSON."""
    import tempfile
    from syncopaid.database import Database
    from syncopaid.tracker import ActivityEvent

    with tempfile.NamedTemporaryFile(suffix='.db', delete=False) as tmp:
        db = Database(tmp.name)

        # Create event with metadata
        event = ActivityEvent(
            timestamp="2025-12-16T10:00:00",
            duration_seconds=120.0,
            app="OUTLOOK.EXE",
            title="Inbox - Outlook"
        )
        event.metadata = {"email_subject": "Re: Smith Case", "sender": "client@example.com"}

        # Insert event
        event_id = db.insert_event(event)

        # Query back
        events = db.get_events()
        assert len(events) == 1
        assert events[0]['metadata'] == {"email_subject": "Re: Smith Case", "sender": "client@example.com"}
```

**Verify RED:**
```bash
python -m pytest tests/test_database.py::test_metadata_column_stores_json -v
```
**Expected output:** `FAILED` - AttributeError: 'ActivityEvent' has no attribute 'metadata'

---

**⚠️ TDD CHECKPOINT 2: GREEN - Minimal Implementation**

Extend ActivityEvent dataclass and database schema:

```python
# src/syncopaid/tracker.py:88-117 (modify ActivityEvent)
@dataclass
class ActivityEvent:
    """
    Represents a single captured activity event.

    Fields:
        timestamp: Start time in ISO8601 format
        duration_seconds: Duration in seconds
        end_time: End time in ISO8601 format
        app: Application executable name
        title: Window title
        url: URL if applicable
        metadata: Additional extracted data (email subject, folder path, etc.)
        is_idle: Whether this was an idle period (deprecated - use state)
        state: Activity state or client matter number
    """
    timestamp: str
    duration_seconds: Optional[float]
    app: Optional[str]
    title: Optional[str]
    end_time: Optional[str] = None
    url: Optional[str] = None
    metadata: Optional[Dict[str, str]] = None  # NEW FIELD
    is_idle: bool = False
    state: str = STATE_ACTIVE

    def to_dict(self) -> dict:
        """Convert to dictionary for JSON export or database storage."""
        return asdict(self)
```

```python
# src/syncopaid/database.py:67-143 (modify _init_schema)
def _init_schema(self):
    """Create database schema if it doesn't exist."""
    with self._get_connection() as conn:
        cursor = conn.cursor()

        # Create events table
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS events (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                timestamp TEXT NOT NULL,
                duration_seconds REAL,
                end_time TEXT,
                app TEXT,
                title TEXT,
                url TEXT,
                metadata TEXT,
                is_idle INTEGER DEFAULT 0
            )
        """)

        # Migration: Add metadata column if it doesn't exist
        cursor.execute("PRAGMA table_info(events)")
        columns = [row[1] for row in cursor.fetchall()]

        if 'metadata' not in columns:
            cursor.execute("ALTER TABLE events ADD COLUMN metadata TEXT")
            logging.info("Database migration: Added metadata column to events table")

        # ... rest of existing migrations (end_time, state) ...
```

```python
# src/syncopaid/database.py:144-176 (modify insert_event)
def insert_event(self, event: ActivityEvent) -> int:
    """Insert a single activity event into the database."""
    import json

    with self._get_connection() as conn:
        cursor = conn.cursor()

        # Get optional fields
        end_time = getattr(event, 'end_time', None)
        state = getattr(event, 'state', 'Active')
        metadata = getattr(event, 'metadata', None)

        # Serialize metadata to JSON if present
        metadata_json = json.dumps(metadata) if metadata else None

        cursor.execute("""
            INSERT INTO events (timestamp, duration_seconds, end_time, app, title, url, metadata, is_idle, state)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        """, (
            event.timestamp,
            event.duration_seconds,
            end_time,
            event.app,
            event.title,
            event.url,
            metadata_json,
            1 if event.is_idle else 0,
            state
        ))

        return cursor.lastrowid
```

```python
# src/syncopaid/database.py:204-273 (modify get_events)
def get_events(self, start_date=None, end_date=None, include_idle=True, limit=None):
    """Query events with optional filtering."""
    import json

    # ... existing query building code ...

    # Convert rows to dictionaries
    events = []
    for row in cursor.fetchall():
        # Derive state from is_idle if column doesn't exist
        if 'state' in row.keys() and row['state']:
            state = row['state']
        else:
            state = 'Inactive' if row['is_idle'] else 'Active'

        # Deserialize metadata JSON if present
        metadata = None
        if 'metadata' in row.keys() and row['metadata']:
            try:
                metadata = json.loads(row['metadata'])
            except json.JSONDecodeError:
                logging.warning(f"Invalid metadata JSON in event {row['id']}")
                metadata = None

        events.append({
            'id': row['id'],
            'timestamp': row['timestamp'],
            'duration_seconds': row['duration_seconds'],
            'end_time': row['end_time'] if 'end_time' in row.keys() else None,
            'app': row['app'],
            'title': row['title'],
            'url': row['url'],
            'metadata': metadata,  # NEW FIELD
            'is_idle': bool(row['is_idle']),
            'state': state
        })

    return events
```

**Verify GREEN:**
```bash
python -m pytest tests/test_database.py::test_metadata_column_stores_json -v
```
**Expected output:** `PASSED` - Test succeeds

---

**⚠️ TDD CHECKPOINT 3: COMMIT**

Commit working test + implementation:

```bash
git add tests/test_database.py src/syncopaid/tracker.py src/syncopaid/database.py
git commit -m "feat: add metadata column to events table

- Extend ActivityEvent with optional metadata field
- Add metadata column to events table schema
- Serialize/deserialize metadata as JSON in database
- Acceptance criteria: Store extracted data in events table"
```

**Expected output:** Commit created with hash

---

### Task 3: Create UI Automation Extractor Module

**Objective:** Implement core UI automation extraction logic for Outlook and Windows Explorer.

**Files:**
- Test: `tests/test_ui_automation.py`
- Implementation: `src/syncopaid/ui_automation.py`

---

**⚠️ TDD CHECKPOINT 1: RED - Write Failing Test**

Create test that verifies UI automation extraction interface:

```python
# tests/test_ui_automation.py (add to existing file)
def test_outlook_extractor_interface():
    """Test that OutlookExtractor has correct interface."""
    from syncopaid.ui_automation import OutlookExtractor

    extractor = OutlookExtractor()

    # Mock window info
    window_info = {
        'app': 'OUTLOOK.EXE',
        'title': 'Inbox - user@lawfirm.com - Outlook',
        'pid': 1234
    }

    # Extract should return dict or None
    result = extractor.extract(window_info)
    assert result is None or isinstance(result, dict)

    # Should handle gracefully with timeout
    assert extractor.timeout_ms == 100  # Default 100ms timeout


def test_explorer_extractor_interface():
    """Test that ExplorerExtractor has correct interface."""
    from syncopaid.ui_automation import ExplorerExtractor

    extractor = ExplorerExtractor()

    # Mock window info
    window_info = {
        'app': 'explorer.exe',
        'title': 'Cases',
        'pid': 5678
    }

    # Extract should return dict or None
    result = extractor.extract(window_info)
    assert result is None or isinstance(result, dict)

    # Should handle gracefully with timeout
    assert extractor.timeout_ms == 100  # Default 100ms timeout
```

**Verify RED:**
```bash
python -m pytest tests/test_ui_automation.py::test_outlook_extractor_interface -v
python -m pytest tests/test_ui_automation.py::test_explorer_extractor_interface -v
```
**Expected output:** `FAILED` - ImportError: cannot import name 'OutlookExtractor'

---

**⚠️ TDD CHECKPOINT 2: GREEN - Minimal Implementation**

Create UI automation module with extractors:

```python
# src/syncopaid/ui_automation.py (NEW FILE)
"""
UI Automation module for extracting rich context from applications.

Provides extractors for:
- Outlook (Legacy): Email subject and sender
- Windows Explorer: Current folder path

Uses pywinauto for UI element inspection with strict timeouts to avoid blocking.
"""

import logging
from typing import Dict, Optional
from abc import ABC, abstractmethod

# Platform detection
import sys
WINDOWS = sys.platform == 'win32'

if WINDOWS:
    try:
        import pywinauto
        from pywinauto import Application
        from pywinauto.timings import TimeoutError
        PYWINAUTO_AVAILABLE = True
    except ImportError:
        PYWINAUTO_AVAILABLE = False
        logging.warning("pywinauto not available. UI automation disabled.")
else:
    PYWINAUTO_AVAILABLE = False


class BaseExtractor(ABC):
    """Base class for UI automation extractors."""

    def __init__(self, timeout_ms: int = 100):
        """
        Initialize extractor.

        Args:
            timeout_ms: Maximum time to spend on extraction (default 100ms)
        """
        self.timeout_ms = timeout_ms

    @abstractmethod
    def extract(self, window_info: Dict) -> Optional[Dict[str, str]]:
        """
        Extract metadata from application window.

        Args:
            window_info: Dict with 'app', 'title', 'pid' keys

        Returns:
            Dict with extracted metadata or None if extraction failed/not applicable
        """
        pass


class OutlookExtractor(BaseExtractor):
    """
    Extract email subject and sender from Outlook (Legacy).

    Note: New Outlook app may not expose email subjects via UI Automation.
    """

    def extract(self, window_info: Dict) -> Optional[Dict[str, str]]:
        """
        Extract email subject and sender from Outlook window.

        Returns:
            Dict with 'email_subject' and 'sender' keys, or None if extraction failed
        """
        if not PYWINAUTO_AVAILABLE:
            return None

        app_name = window_info.get('app', '').upper()
        if 'OUTLOOK' not in app_name:
            return None

        try:
            # TODO: Implement actual extraction using pywinauto
            # For now, return None (graceful fallback)
            logging.debug(f"Outlook extraction not yet implemented for {window_info['title']}")
            return None

        except Exception as e:
            logging.debug(f"Outlook extraction failed: {e}")
            return None


class ExplorerExtractor(BaseExtractor):
    """Extract current folder path from Windows Explorer."""

    def extract(self, window_info: Dict) -> Optional[Dict[str, str]]:
        """
        Extract current folder path from Explorer address bar.

        Returns:
            Dict with 'folder_path' key, or None if extraction failed
        """
        if not PYWINAUTO_AVAILABLE:
            return None

        app_name = window_info.get('app', '').lower()
        if 'explorer' not in app_name:
            return None

        try:
            # TODO: Implement actual extraction using pywinauto
            # For now, return None (graceful fallback)
            logging.debug(f"Explorer extraction not yet implemented for {window_info['title']}")
            return None

        except Exception as e:
            logging.debug(f"Explorer extraction failed: {e}")
            return None


class UIAutomationWorker:
    """
    Coordinates UI automation extraction across multiple applications.

    Manages extractors and provides unified interface for TrackerLoop integration.
    """

    def __init__(self, enabled: bool = True, outlook_enabled: bool = True, explorer_enabled: bool = True):
        """
        Initialize UI automation worker.

        Args:
            enabled: Master enable/disable for all UI automation
            outlook_enabled: Enable/disable Outlook extraction
            explorer_enabled: Enable/disable Explorer extraction
        """
        self.enabled = enabled
        self.outlook_enabled = outlook_enabled
        self.explorer_enabled = explorer_enabled

        # Initialize extractors
        self.outlook_extractor = OutlookExtractor() if outlook_enabled else None
        self.explorer_extractor = ExplorerExtractor() if explorer_enabled else None

        logging.info(f"UIAutomationWorker initialized: enabled={enabled}, outlook={outlook_enabled}, explorer={explorer_enabled}")

    def extract(self, window_info: Dict) -> Optional[Dict[str, str]]:
        """
        Extract metadata from current window using appropriate extractor.

        Args:
            window_info: Dict with 'app', 'title', 'pid' keys

        Returns:
            Dict with extracted metadata or None if no extraction performed
        """
        if not self.enabled:
            return None

        app_name = window_info.get('app', '').upper()

        # Try Outlook extractor
        if self.outlook_extractor and 'OUTLOOK' in app_name:
            return self.outlook_extractor.extract(window_info)

        # Try Explorer extractor
        if self.explorer_extractor and 'EXPLORER' in app_name:
            return self.explorer_extractor.extract(window_info)

        # No applicable extractor
        return None
```

**Verify GREEN:**
```bash
python -m pytest tests/test_ui_automation.py::test_outlook_extractor_interface -v
python -m pytest tests/test_ui_automation.py::test_explorer_extractor_interface -v
```
**Expected output:** `PASSED` - Tests succeed

---

**⚠️ TDD CHECKPOINT 3: COMMIT**

Commit working test + implementation:

```bash
git add tests/test_ui_automation.py src/syncopaid/ui_automation.py
git commit -m "feat: create UI automation extractor module

- Add BaseExtractor abstract class
- Implement OutlookExtractor stub (graceful fallback)
- Implement ExplorerExtractor stub (graceful fallback)
- Add UIAutomationWorker coordinator
- Acceptance criteria: Handle applications gracefully"
```

**Expected output:** Commit created with hash

---

### Task 4: Add Configuration Settings for UI Automation

**Objective:** Add config flags to enable/disable UI automation per application.

**Files:**
- Test: `tests/test_config.py` (extend existing)
- Implementation: `src/syncopaid/config.py:16-37`

---

**⚠️ TDD CHECKPOINT 1: RED - Write Failing Test**

Create test that verifies UI automation config settings:

```python
# tests/test_config.py (add to existing file or create new)
def test_ui_automation_config_defaults():
    """Test that UI automation config has correct defaults."""
    import tempfile
    from pathlib import Path
    from syncopaid.config import ConfigManager

    with tempfile.TemporaryDirectory() as tmpdir:
        config_path = Path(tmpdir) / "test_config.json"
        manager = ConfigManager(config_path=config_path)

        # Check defaults
        assert manager.config.ui_automation_enabled == True
        assert manager.config.ui_automation_outlook_enabled == True
        assert manager.config.ui_automation_explorer_enabled == True
```

**Verify RED:**
```bash
python -m pytest tests/test_config.py::test_ui_automation_config_defaults -v
```
**Expected output:** `FAILED` - AttributeError: 'Config' object has no attribute 'ui_automation_enabled'

---

**⚠️ TDD CHECKPOINT 2: GREEN - Minimal Implementation**

Add UI automation config settings:

```python
# src/syncopaid/config.py:16-42 (modify DEFAULT_CONFIG)
DEFAULT_CONFIG = {
    "poll_interval_seconds": 1.0,
    "idle_threshold_seconds": 180,
    "merge_threshold_seconds": 2.0,
    "database_path": None,
    "start_on_boot": False,
    "start_tracking_on_launch": True,
    # Screenshot settings (periodic)
    "screenshot_enabled": True,
    "screenshot_interval_seconds": 10,
    "screenshot_threshold_identical": 0.92,
    "screenshot_threshold_significant": 0.70,
    "screenshot_threshold_identical_same_window": 0.90,
    "screenshot_threshold_identical_different_window": 0.99,
    "screenshot_quality": 65,
    "screenshot_max_dimension": 1920,
    # Action screenshot settings
    "action_screenshot_enabled": True,
    "action_screenshot_throttle_seconds": 0.5,
    "action_screenshot_quality": 65,
    "action_screenshot_max_dimension": 1920,
    # UI Automation settings (NEW)
    "ui_automation_enabled": True,
    "ui_automation_outlook_enabled": True,
    "ui_automation_explorer_enabled": True
}
```

```python
# src/syncopaid/config.py:40-88 (modify Config dataclass)
@dataclass
class Config:
    """
    Application configuration settings.

    Attributes:
        ... (existing attributes) ...
        ui_automation_enabled: Enable UI automation extraction (default: True)
        ui_automation_outlook_enabled: Enable Outlook email subject extraction (default: True)
        ui_automation_explorer_enabled: Enable Explorer folder path extraction (default: True)
    """
    poll_interval_seconds: float = 1.0
    idle_threshold_seconds: float = 180.0
    merge_threshold_seconds: float = 2.0
    database_path: Optional[str] = None
    start_on_boot: bool = False
    start_tracking_on_launch: bool = True
    # Screenshot settings (periodic)
    screenshot_enabled: bool = True
    screenshot_interval_seconds: float = 10.0
    screenshot_threshold_identical: float = 0.92
    screenshot_threshold_significant: float = 0.70
    screenshot_threshold_identical_same_window: float = 0.90
    screenshot_threshold_identical_different_window: float = 0.99
    screenshot_quality: int = 65
    screenshot_max_dimension: int = 1920
    # Action screenshot settings
    action_screenshot_enabled: bool = True
    action_screenshot_throttle_seconds: float = 0.5
    action_screenshot_quality: int = 65
    action_screenshot_max_dimension: int = 1920
    # UI Automation settings (NEW)
    ui_automation_enabled: bool = True
    ui_automation_outlook_enabled: bool = True
    ui_automation_explorer_enabled: bool = True

    def to_dict(self) -> Dict[str, Any]:
        """Convert config to dictionary."""
        return asdict(self)
```

**Verify GREEN:**
```bash
python -m pytest tests/test_config.py::test_ui_automation_config_defaults -v
```
**Expected output:** `PASSED` - Test succeeds

---

**⚠️ TDD CHECKPOINT 3: COMMIT**

Commit working test + implementation:

```bash
git add tests/test_config.py src/syncopaid/config.py
git commit -m "feat: add UI automation configuration settings

- Add ui_automation_enabled master flag
- Add ui_automation_outlook_enabled flag
- Add ui_automation_explorer_enabled flag
- Default all to True
- Acceptance criteria: Configurable enable/disable per application"
```

**Expected output:** Commit created with hash

---

### Task 5: Integrate UI Automation with TrackerLoop

**Objective:** Integrate UIAutomationWorker into TrackerLoop to extract metadata during tracking.

**Files:**
- Test: `tests/test_tracker.py` (extend existing)
- Implementation: `src/syncopaid/tracker.py:204-335`

---

**⚠️ TDD CHECKPOINT 1: RED - Write Failing Test**

Create test that verifies TrackerLoop uses UI automation worker:

```python
# tests/test_tracker.py (add to existing file)
def test_tracker_loop_ui_automation_integration():
    """Test that TrackerLoop integrates with UI automation worker."""
    from syncopaid.tracker import TrackerLoop
    from syncopaid.ui_automation import UIAutomationWorker

    # Create UI automation worker
    ui_worker = UIAutomationWorker(enabled=True, outlook_enabled=True, explorer_enabled=True)

    # Create tracker with UI automation worker
    tracker = TrackerLoop(
        poll_interval=1.0,
        idle_threshold=180.0,
        merge_threshold=2.0,
        ui_automation_worker=ui_worker
    )

    # Verify worker is attached
    assert tracker.ui_automation_worker is ui_worker
```

**Verify RED:**
```bash
python -m pytest tests/test_tracker.py::test_tracker_loop_ui_automation_integration -v
```
**Expected output:** `FAILED` - TypeError: __init__() got unexpected keyword argument 'ui_automation_worker'

---

**⚠️ TDD CHECKPOINT 2: GREEN - Minimal Implementation**

Integrate UI automation into TrackerLoop:

```python
# src/syncopaid/tracker.py:204-256 (modify TrackerLoop.__init__)
class TrackerLoop:
    """
    Main tracking loop that captures window activity and generates events.

    Configuration:
        poll_interval: How often to check active window (seconds)
        idle_threshold: Seconds before marking as idle
        merge_threshold: Max gap to merge identical windows (seconds)
        screenshot_worker: Optional ScreenshotWorker for capturing screenshots
        screenshot_interval: Seconds between screenshot attempts
        ui_automation_worker: Optional UIAutomationWorker for rich context extraction
    """

    def __init__(
        self,
        poll_interval: float = 1.0,
        idle_threshold: float = 180.0,
        merge_threshold: float = 2.0,
        screenshot_worker=None,
        screenshot_interval: float = 10.0,
        ui_automation_worker=None  # NEW PARAMETER
    ):
        self.poll_interval = poll_interval
        self.idle_threshold = idle_threshold
        self.merge_threshold = merge_threshold
        self.screenshot_worker = screenshot_worker
        self.screenshot_interval = screenshot_interval
        self.ui_automation_worker = ui_automation_worker  # NEW FIELD

        # State tracking for event merging
        self.current_event: Optional[Dict] = None
        self.event_start_time: Optional[datetime] = None

        # Screenshot timing
        self.last_screenshot_time: float = 0

        self.running = False

        # Statistics
        self.total_events = 0
        self.merged_events = 0

        logging.info(
            f"TrackerLoop initialized: "
            f"poll={poll_interval}s, idle_threshold={idle_threshold}s, "
            f"merge_threshold={merge_threshold}s, "
            f"screenshot_enabled={screenshot_worker is not None}, "
            f"ui_automation_enabled={ui_automation_worker is not None}"
        )
```

```python
# src/syncopaid/tracker.py:365-399 (modify _finalize_current_event)
def _finalize_current_event(self) -> Optional[ActivityEvent]:
    """
    Convert the current tracked event into an ActivityEvent object.

    Returns None if the event is too short or invalid.
    """
    if not self.current_event or not self.event_start_time:
        return None

    # Calculate duration and end time
    end_time = datetime.now(timezone.utc)
    duration = (end_time - self.event_start_time).total_seconds()

    # Skip events that are too short (< 0.5 seconds)
    if duration < 0.5:
        return None

    # Derive state from is_idle flag
    event_state = STATE_INACTIVE if self.current_event['is_idle'] else STATE_ACTIVE

    # Extract metadata if UI automation worker is available
    metadata = None
    if self.ui_automation_worker and 'window_info' in self.current_event:
        metadata = self.ui_automation_worker.extract(self.current_event['window_info'])

    # Create event with start time, duration, end time, state, and metadata
    event = ActivityEvent(
        timestamp=self.event_start_time.isoformat(),
        duration_seconds=round(duration, 2),
        app=self.current_event['app'],
        title=self.current_event['title'],
        end_time=end_time.isoformat(),
        url=None,  # URL extraction is handled separately (story 1.8.2)
        metadata=metadata,  # NEW FIELD
        is_idle=self.current_event['is_idle'],
        state=event_state
    )

    self.total_events += 1
    return event
```

```python
# src/syncopaid/tracker.py:270-283 (modify start() to store window_info)
# Inside the while self.running loop, after getting window info:

# Get current state
window = get_active_window()
idle_seconds = get_idle_seconds()
is_idle = idle_seconds >= self.idle_threshold

# Create state dict for comparison
state = {
    'app': window['app'],
    'title': window['title'],
    'is_idle': is_idle,
    'window_info': window  # NEW: Store full window info for UI automation
}
```

**Verify GREEN:**
```bash
python -m pytest tests/test_tracker.py::test_tracker_loop_ui_automation_integration -v
```
**Expected output:** `PASSED` - Test succeeds

---

**⚠️ TDD CHECKPOINT 3: COMMIT**

Commit working test + implementation:

```bash
git add tests/test_tracker.py src/syncopaid/tracker.py
git commit -m "feat: integrate UI automation with TrackerLoop

- Add ui_automation_worker parameter to TrackerLoop
- Call worker.extract() in _finalize_current_event()
- Store window_info in state dict for extraction
- Populate metadata field in ActivityEvent
- Acceptance criteria: Minimal performance impact (extraction on finalize only)"
```

**Expected output:** Commit created with hash

---

### Task 6: Implement Outlook Email Subject Extraction

**Objective:** Use pywinauto to extract email subject and sender from Outlook Legacy reading pane.

**Files:**
- Test: `tests/test_ui_automation.py`
- Implementation: `src/syncopaid/ui_automation.py:60-95`

---

**⚠️ TDD CHECKPOINT 1: RED - Write Failing Test**

Create integration test for Outlook extraction (mocked):

```python
# tests/test_ui_automation.py (add to existing file)
def test_outlook_extractor_returns_subject_and_sender():
    """Test that OutlookExtractor can extract email subject and sender."""
    from syncopaid.ui_automation import OutlookExtractor
    from unittest.mock import MagicMock, patch

    extractor = OutlookExtractor()

    # Mock pywinauto Application
    with patch('syncopaid.ui_automation.Application') as mock_app:
        # Mock UI element hierarchy
        mock_window = MagicMock()
        mock_subject_elem = MagicMock()
        mock_subject_elem.window_text.return_value = "Re: Smith Case"
        mock_sender_elem = MagicMock()
        mock_sender_elem.window_text.return_value = "client@example.com"

        mock_window.child_window.side_effect = [mock_subject_elem, mock_sender_elem]
        mock_app.return_value.window.return_value = mock_window

        # Extract metadata
        window_info = {
            'app': 'OUTLOOK.EXE',
            'title': 'Re: Smith Case - Outlook',
            'pid': 1234
        }

        result = extractor.extract(window_info)

        # Verify extraction
        assert result is not None
        assert result['email_subject'] == "Re: Smith Case"
        assert result['sender'] == "client@example.com"
```

**Verify RED:**
```bash
python -m pytest tests/test_ui_automation.py::test_outlook_extractor_returns_subject_and_sender -v
```
**Expected output:** `FAILED` - AssertionError: result is None

---

**⚠️ TDD CHECKPOINT 2: GREEN - Minimal Implementation**

Implement Outlook extraction logic:

```python
# src/syncopaid/ui_automation.py:60-110 (modify OutlookExtractor.extract)
class OutlookExtractor(BaseExtractor):
    """
    Extract email subject and sender from Outlook (Legacy).

    Note: New Outlook app may not expose email subjects via UI Automation.
    """

    def extract(self, window_info: Dict) -> Optional[Dict[str, str]]:
        """
        Extract email subject and sender from Outlook window.

        Strategy:
        1. Connect to Outlook window by PID
        2. Find subject control (usually has class "_WwG" or AutomationId "Subject")
        3. Find sender/from control
        4. Return extracted values with timeout protection

        Returns:
            Dict with 'email_subject' and 'sender' keys, or None if extraction failed
        """
        if not PYWINAUTO_AVAILABLE:
            return None

        app_name = window_info.get('app', '').upper()
        if 'OUTLOOK' not in app_name:
            return None

        pid = window_info.get('pid')
        if not pid:
            return None

        try:
            # Connect to Outlook process with timeout
            app = Application(backend='uia').connect(process=pid, timeout=self.timeout_ms / 1000.0)

            # Get main window
            main_window = app.window(pid=pid)

            # Try to find subject field (common AutomationIds: "Subject", "4292")
            subject_text = None
            try:
                subject_elem = main_window.child_window(auto_id="Subject", control_type="Edit")
                subject_text = subject_elem.window_text()
            except Exception:
                # Fallback: try by class name
                try:
                    subject_elem = main_window.child_window(class_name="_WwG", found_index=0)
                    subject_text = subject_elem.window_text()
                except Exception:
                    pass

            # Try to find sender/from field (common AutomationIds: "From", "4293")
            sender_text = None
            try:
                sender_elem = main_window.child_window(auto_id="From", control_type="Edit")
                sender_text = sender_elem.window_text()
            except Exception:
                pass

            # Return extracted data if we got at least subject
            if subject_text:
                result = {'email_subject': subject_text}
                if sender_text:
                    result['sender'] = sender_text
                logging.debug(f"Extracted Outlook metadata: {result}")
                return result

            return None

        except TimeoutError:
            logging.debug(f"Outlook extraction timeout after {self.timeout_ms}ms")
            return None

        except Exception as e:
            logging.debug(f"Outlook extraction failed: {e}")
            return None
```

**Verify GREEN:**
```bash
python -m pytest tests/test_ui_automation.py::test_outlook_extractor_returns_subject_and_sender -v
```
**Expected output:** `PASSED` - Test succeeds

---

**⚠️ TDD CHECKPOINT 3: COMMIT**

Commit working test + implementation:

```bash
git add tests/test_ui_automation.py src/syncopaid/ui_automation.py
git commit -m "feat: implement Outlook email subject extraction

- Use pywinauto to extract subject and sender fields
- Try multiple UI element strategies (AutomationId, class name)
- Respect 100ms timeout to avoid blocking
- Graceful fallback if extraction fails
- Acceptance criteria: Extract email subject/sender from Outlook"
```

**Expected output:** Commit created with hash

---

### Task 7: Implement Windows Explorer Folder Path Extraction

**Objective:** Use pywinauto to extract current folder path from Explorer address bar.

**Files:**
- Test: `tests/test_ui_automation.py`
- Implementation: `src/syncopaid/ui_automation.py:113-155`

---

**⚠️ TDD CHECKPOINT 1: RED - Write Failing Test**

Create integration test for Explorer extraction (mocked):

```python
# tests/test_ui_automation.py (add to existing file)
def test_explorer_extractor_returns_folder_path():
    """Test that ExplorerExtractor can extract folder path."""
    from syncopaid.ui_automation import ExplorerExtractor
    from unittest.mock import MagicMock, patch

    extractor = ExplorerExtractor()

    # Mock pywinauto Application
    with patch('syncopaid.ui_automation.Application') as mock_app:
        # Mock UI element hierarchy
        mock_window = MagicMock()
        mock_address_bar = MagicMock()
        mock_address_bar.window_text.return_value = "C:\\Cases\\Smith_v_Jones"

        mock_window.child_window.return_value = mock_address_bar
        mock_app.return_value.window.return_value = mock_window

        # Extract metadata
        window_info = {
            'app': 'explorer.exe',
            'title': 'Smith_v_Jones',
            'pid': 5678
        }

        result = extractor.extract(window_info)

        # Verify extraction
        assert result is not None
        assert result['folder_path'] == "C:\\Cases\\Smith_v_Jones"
```

**Verify RED:**
```bash
python -m pytest tests/test_ui_automation.py::test_explorer_extractor_returns_folder_path -v
```
**Expected output:** `FAILED` - AssertionError: result is None

---

**⚠️ TDD CHECKPOINT 2: GREEN - Minimal Implementation**

Implement Explorer extraction logic:

```python
# src/syncopaid/ui_automation.py:113-165 (modify ExplorerExtractor.extract)
class ExplorerExtractor(BaseExtractor):
    """Extract current folder path from Windows Explorer."""

    def extract(self, window_info: Dict) -> Optional[Dict[str, str]]:
        """
        Extract current folder path from Explorer address bar.

        Strategy:
        1. Connect to Explorer window by PID
        2. Find address bar control (class "Edit" or AutomationId "41477")
        3. Extract path text
        4. Return with timeout protection

        Returns:
            Dict with 'folder_path' key, or None if extraction failed
        """
        if not PYWINAUTO_AVAILABLE:
            return None

        app_name = window_info.get('app', '').lower()
        if 'explorer' not in app_name:
            return None

        pid = window_info.get('pid')
        if not pid:
            return None

        try:
            # Connect to Explorer process with timeout
            app = Application(backend='uia').connect(process=pid, timeout=self.timeout_ms / 1000.0)

            # Get main window
            main_window = app.window(pid=pid)

            # Try to find address bar (AutomationId "41477" is standard for Explorer)
            folder_path = None
            try:
                address_bar = main_window.child_window(auto_id="41477", control_type="Edit")
                folder_path = address_bar.window_text()
            except Exception:
                # Fallback: try by control type and class
                try:
                    address_bar = main_window.child_window(control_type="Edit", class_name="Edit", found_index=0)
                    folder_path = address_bar.window_text()
                except Exception:
                    pass

            # Return extracted path
            if folder_path:
                result = {'folder_path': folder_path}
                logging.debug(f"Extracted Explorer metadata: {result}")
                return result

            return None

        except TimeoutError:
            logging.debug(f"Explorer extraction timeout after {self.timeout_ms}ms")
            return None

        except Exception as e:
            logging.debug(f"Explorer extraction failed: {e}")
            return None
```

**Verify GREEN:**
```bash
python -m pytest tests/test_ui_automation.py::test_explorer_extractor_returns_folder_path -v
```
**Expected output:** `PASSED` - Test succeeds

---

**⚠️ TDD CHECKPOINT 3: COMMIT**

Commit working test + implementation:

```bash
git add tests/test_ui_automation.py src/syncopaid/ui_automation.py
git commit -m "feat: implement Windows Explorer folder path extraction

- Use pywinauto to extract address bar path
- Try multiple UI element strategies (AutomationId 41477, Edit control)
- Respect 100ms timeout to avoid blocking
- Graceful fallback if extraction fails
- Acceptance criteria: Extract folder path from Windows Explorer"
```

**Expected output:** Commit created with hash

---

## Verification Checklist

**Before marking story complete:**

- [ ] All tests pass: `python -m pytest -v`
- [ ] Module test works: `python -m syncopaid.tracker` (should run without errors)
- [ ] Manual test with Outlook: Open Outlook Legacy, verify email subjects extracted
- [ ] Manual test with Explorer: Navigate folders, verify paths extracted
- [ ] Configuration flags work: Disable outlook_enabled, verify extraction skipped
- [ ] Performance acceptable: Extraction takes <100ms per event finalization
- [ ] All acceptance criteria verified:
  - [ ] Extract email subject/sender from Outlook (Legacy) reading pane or open email
  - [ ] Extract current folder path from Windows Explorer address bar
  - [ ] Store extracted data in events table (metadata column)
  - [ ] Handle applications not responding gracefully (timeout, fallback to title-only)
  - [ ] Configurable enable/disable per application in settings
  - [ ] Minimal performance impact (<100ms per extraction)

## Rollback Plan

**If issues occur:**
1. Identify last known good commit: `git log --oneline`
2. Revert problematic commit: `git revert [hash]`
3. Document issue in story notes
4. Re-plan if fundamental approach flawed

**Known risks:**
- UI Automation IDs may differ across Windows versions (test on Windows 10 and 11)
- New Outlook app won't work (documented limitation)
- Some Explorer views may not expose address bar (graceful fallback to title-only)

## Implementation Notes

**Edge cases handled:**
- Timeout protection: All extractions limited to 100ms
- Missing UI elements: Multiple fallback strategies per application
- Platform compatibility: Graceful degradation if pywinauto unavailable
- Configuration flexibility: Per-app enable/disable flags

**Alternatives considered:**
- `uiautomation` library: Rejected in favor of `pywinauto` (more mature, better docs)
- Background thread extraction: pending (adds complexity, not needed for 100ms timeout)
- Storing metadata in separate table: Rejected (simpler to use JSON column)

**Follow-up work:**
- Story 1.8.2 (Browser URL Extraction) can reuse UIAutomationWorker pattern
- Story 1.8.4 (AI Disambiguation) will consume metadata for better categorization
- Consider adding extraction for other apps (Word, Excel) in future stories
