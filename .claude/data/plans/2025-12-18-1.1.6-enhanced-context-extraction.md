# Enhanced Context Extraction from Window Titles - Implementation Plan

> **TDD Required:** Each task (~2-5 min): Write test → verify RED → Write code → verify GREEN → Commit
> **Zero Context:** This plan assumes the implementer knows nothing about the codebase.

**Goal:** Extract URLs from browsers, email subjects from Outlook, and file paths from Office apps to populate ActivityEvent.url field for AI categorization.
**Approach:** Create extraction functions for each app type, integrate into tracker.py get_active_window(), populate url field with extracted context. Use regex patterns for URL extraction, string parsing for email subjects and file paths.
**Tech Stack:** Python regex (re module), pywin32 (win32gui), existing tracker.py infrastructure

---

**Story ID:** 1.1.6 | **Created:** 2025-12-18 | **Stage:** `planned`

---

## Story Context

**Title:** Enhanced Context Extraction from Window Titles

**Description:** **As a** lawyer using AI to categorize my time
**I want** the system to extract URLs from browser windows, email subjects from Outlook, and file paths from Office applications
**So that** the AI has rich contextual data to accurately match activities to client matters

**Acceptance Criteria:**
- [ ] Extract URLs from Chrome/Edge/Firefox window titles (e.g., "https://canlii.ca/t/abc123" from "Case Law - CanLII - Google Chrome")
- [ ] Parse email subjects from Outlook window titles (e.g., "RE: Smith vs Jones Settlement" from "Inbox - RE: Smith vs Jones Settlement - Outlook")
- [ ] Extract file paths from Word/Excel window titles (e.g., "C:\Matters\1023-Smith\Contract.docx" from title bar)
- [ ] Populate ActivityEvent.url field with extracted context
- [ ] Handle malformed or ambiguous window titles gracefully
- [ ] Log extraction failures for debugging without crashing tracker

## Prerequisites

- [ ] venv activated: `venv\Scripts\activate`
- [ ] Baseline tests pass: `python -m pytest -v` (if pytest installed; currently using manual tests)

## TDD Tasks

### Task 1: Create URL extraction function with tests (~4 min)

**Files:**
- **Create:** `test_context_extraction.py`
- **Create:** `src/syncopaid/context_extraction.py`

**Context:** Browsers embed URLs in their window titles. Chrome: "Page Title - URL - Google Chrome", Edge: "Page Title - Microsoft Edge", Firefox: "Page Title - Mozilla Firefox". Extract URL if present.

**Step 1 - RED:** Write failing test
```python
# test_context_extraction.py
"""Test context extraction from window titles."""
import sys
sys.path.insert(0, 'src')

from syncopaid.context_extraction import extract_url_from_browser

def test_extract_url_chrome_with_url():
    """Extract URL from Chrome title with embedded URL."""
    title = "Smith vs Jones - CanLII - https://canlii.ca/t/abc123 - Google Chrome"
    result = extract_url_from_browser("chrome.exe", title)
    assert result == "https://canlii.ca/t/abc123"

def test_extract_url_chrome_without_url():
    """Return None when no URL pattern found."""
    title = "New Tab - Google Chrome"
    result = extract_url_from_browser("chrome.exe", title)
    assert result is None

def test_extract_url_edge():
    """Extract URL from Edge title."""
    title = "Case Law - https://www.courts.gov.bc.ca/decisions - Microsoft Edge"
    result = extract_url_from_browser("msedge.exe", title)
    assert result == "https://www.courts.gov.bc.ca/decisions"

def test_extract_url_firefox():
    """Extract URL from Firefox title."""
    title = "Research Document - https://example.com/doc - Mozilla Firefox"
    result = extract_url_from_browser("firefox.exe", title)
    assert result == "https://example.com/doc"

def test_extract_url_non_browser():
    """Return None for non-browser apps."""
    title = "Document.docx - Word"
    result = extract_url_from_browser("WINWORD.EXE", title)
    assert result is None

if __name__ == "__main__":
    print("Running context extraction tests...")
    test_extract_url_chrome_with_url()
    test_extract_url_chrome_without_url()
    test_extract_url_edge()
    test_extract_url_firefox()
    test_extract_url_non_browser()
    print("All tests passed!")
```

**Step 2 - Verify RED:**
```bash
python test_context_extraction.py
```
Expected output: `ModuleNotFoundError: No module named 'syncopaid.context_extraction'`

**Step 3 - GREEN:** Write minimal implementation
```python
# src/syncopaid/context_extraction.py
"""Extract contextual information from window titles."""
import re
import logging

# Browser executable names (case-insensitive matching)
BROWSER_APPS = {'chrome.exe', 'msedge.exe', 'firefox.exe', 'brave.exe', 'opera.exe'}

def extract_url_from_browser(app: str, title: str) -> str:
    """
    Extract URL from browser window title.

    Args:
        app: Application executable name (e.g., 'chrome.exe')
        title: Window title text

    Returns:
        Extracted URL string, or None if no URL found
    """
    if not app or not title:
        return None

    # Check if this is a browser
    if app.lower() not in BROWSER_APPS:
        return None

    # Pattern matches http:// or https:// URLs
    # Looks for protocol + domain + optional path
    url_pattern = r'https?://[^\s<>"\'\[\]{}|\\^`]+'

    match = re.search(url_pattern, title)
    if match:
        return match.group(0)

    return None
```

**Step 4 - Verify GREEN:**
```bash
python test_context_extraction.py
```
Expected output: `All tests passed!`

**Step 5 - COMMIT:**
```bash
git add test_context_extraction.py src/syncopaid/context_extraction.py && git commit -m "feat: add URL extraction from browser titles"
```

---

### Task 2: Add Outlook email subject extraction (~4 min)

**Files:**
- **Modify:** `test_context_extraction.py` (append new tests)
- **Modify:** `src/syncopaid/context_extraction.py` (add function)

**Context:** Outlook embeds email subjects in window titles. Format: "Inbox - RE: Subject Line - Outlook" or "Message Subject - Message - Outlook". Extract the subject portion between dashes.

**Step 1 - RED:** Write failing test
```python
# test_context_extraction.py (add to end of file)

from syncopaid.context_extraction import extract_subject_from_outlook

def test_extract_subject_inbox_format():
    """Extract subject from Outlook inbox view."""
    title = "Inbox - RE: Smith vs Jones Settlement - user@lawfirm.com - Outlook"
    result = extract_subject_from_outlook("OUTLOOK.EXE", title)
    assert result == "RE: Smith vs Jones Settlement"

def test_extract_subject_message_format():
    """Extract subject from Outlook message window."""
    title = "FW: Discovery Documents - Message (HTML) - Outlook"
    result = extract_subject_from_outlook("OUTLOOK.EXE", title)
    assert result == "FW: Discovery Documents"

def test_extract_subject_generic_inbox():
    """Return None for generic inbox without specific subject."""
    title = "Inbox - user@lawfirm.com - Outlook"
    result = extract_subject_from_outlook("OUTLOOK.EXE", title)
    assert result is None

def test_extract_subject_non_outlook():
    """Return None for non-Outlook apps."""
    title = "Email Subject - Thunderbird"
    result = extract_subject_from_outlook("thunderbird.exe", title)
    assert result is None

# Update main block
if __name__ == "__main__":
    print("Running context extraction tests...")
    test_extract_url_chrome_with_url()
    test_extract_url_chrome_without_url()
    test_extract_url_edge()
    test_extract_url_firefox()
    test_extract_url_non_browser()
    test_extract_subject_inbox_format()
    test_extract_subject_message_format()
    test_extract_subject_generic_inbox()
    test_extract_subject_non_outlook()
    print("All tests passed!")
```

**Step 2 - Verify RED:**
```bash
python test_context_extraction.py
```
Expected output: `ImportError: cannot import name 'extract_subject_from_outlook'`

**Step 3 - GREEN:** Write minimal implementation
```python
# src/syncopaid/context_extraction.py (add to end of file)

def extract_subject_from_outlook(app: str, title: str) -> str:
    """
    Extract email subject from Outlook window title.

    Args:
        app: Application executable name
        title: Window title text

    Returns:
        Extracted email subject, or None if no subject found
    """
    if not app or not title:
        return None

    # Check if this is Outlook
    if app.upper() != "OUTLOOK.EXE":
        return None

    # Format 1: "Inbox - SUBJECT - email@domain - Outlook"
    # Format 2: "SUBJECT - Message (HTML) - Outlook"

    # Remove trailing " - Outlook" first
    if title.endswith(" - Outlook"):
        title = title[:-10].strip()
    else:
        return None

    # Split by " - " separator
    parts = title.split(" - ")

    if len(parts) < 2:
        return None

    # Format 1: "Inbox - SUBJECT - email@domain"
    if parts[0] == "Inbox" and len(parts) >= 2:
        # Subject is second part, unless it's just an email
        subject = parts[1]
        # Skip if it's just an email address (no actual subject)
        if "@" in subject and len(parts) == 2:
            return None
        return subject

    # Format 2: "SUBJECT - Message (HTML)"
    if len(parts) >= 2 and "Message" in parts[-1]:
        return parts[0]

    return None
```

**Step 4 - Verify GREEN:**
```bash
python test_context_extraction.py
```
Expected output: `All tests passed!`

**Step 5 - COMMIT:**
```bash
git add test_context_extraction.py src/syncopaid/context_extraction.py && git commit -m "feat: add email subject extraction from Outlook"
```

---

### Task 3: Add Office file path extraction (~4 min)

**Files:**
- **Modify:** `test_context_extraction.py` (append new tests)
- **Modify:** `src/syncopaid/context_extraction.py` (add function)

**Context:** Office apps (Word, Excel, PowerPoint) show file paths in titles. Format: "Filename.docx - Word" or "C:\Path\To\File.xlsx - Excel". Extract the file path if present.

**Step 1 - RED:** Write failing test
```python
# test_context_extraction.py (add to end of file)

from syncopaid.context_extraction import extract_filepath_from_office

def test_extract_filepath_word_full_path():
    """Extract full file path from Word title."""
    title = "C:\\Matters\\1023-Smith\\Contract.docx - Word"
    result = extract_filepath_from_office("WINWORD.EXE", title)
    assert result == "C:\\Matters\\1023-Smith\\Contract.docx"

def test_extract_filepath_excel():
    """Extract file path from Excel title."""
    title = "D:\\Projects\\Budget-2024.xlsx - Excel"
    result = extract_filepath_from_office("EXCEL.EXE", title)
    assert result == "D:\\Projects\\Budget-2024.xlsx"

def test_extract_filepath_powerpoint():
    """Extract file path from PowerPoint title."""
    title = "Presentation.pptx - PowerPoint"
    result = extract_filepath_from_office("POWERPNT.EXE", title)
    assert result == "Presentation.pptx"

def test_extract_filepath_filename_only():
    """Extract filename when no directory path shown."""
    title = "Document1.docx - Word"
    result = extract_filepath_from_office("WINWORD.EXE", title)
    assert result == "Document1.docx"

def test_extract_filepath_non_office():
    """Return None for non-Office apps."""
    title = "Notepad"
    result = extract_filepath_from_office("notepad.exe", title)
    assert result is None

# Update main block
if __name__ == "__main__":
    print("Running context extraction tests...")
    test_extract_url_chrome_with_url()
    test_extract_url_chrome_without_url()
    test_extract_url_edge()
    test_extract_url_firefox()
    test_extract_url_non_browser()
    test_extract_subject_inbox_format()
    test_extract_subject_message_format()
    test_extract_subject_generic_inbox()
    test_extract_subject_non_outlook()
    test_extract_filepath_word_full_path()
    test_extract_filepath_excel()
    test_extract_filepath_powerpoint()
    test_extract_filepath_filename_only()
    test_extract_filepath_non_office()
    print("All tests passed!")
```

**Step 2 - Verify RED:**
```bash
python test_context_extraction.py
```
Expected output: `ImportError: cannot import name 'extract_filepath_from_office'`

**Step 3 - GREEN:** Write minimal implementation
```python
# src/syncopaid/context_extraction.py (add to end of file)

# Office application executable names
OFFICE_APPS = {
    'WINWORD.EXE': 'Word',
    'EXCEL.EXE': 'Excel',
    'POWERPNT.EXE': 'PowerPoint',
    'MSPUB.EXE': 'Publisher',
    'MSACCESS.EXE': 'Access'
}

def extract_filepath_from_office(app: str, title: str) -> str:
    """
    Extract file path from Office application window title.

    Args:
        app: Application executable name
        title: Window title text

    Returns:
        Extracted file path/name, or None if not found
    """
    if not app or not title:
        return None

    # Check if this is an Office app
    app_upper = app.upper()
    if app_upper not in OFFICE_APPS:
        return None

    app_name = OFFICE_APPS[app_upper]

    # Format: "FILEPATH - AppName"
    separator = f" - {app_name}"
    if separator not in title:
        return None

    # Extract everything before the separator
    filepath = title.split(separator)[0].strip()

    if filepath:
        return filepath

    return None
```

**Step 4 - Verify GREEN:**
```bash
python test_context_extraction.py
```
Expected output: `All tests passed!`

**Step 5 - COMMIT:**
```bash
git add test_context_extraction.py src/syncopaid/context_extraction.py && git commit -m "feat: add file path extraction from Office apps"
```

---

### Task 4: Create unified extract_context function (~3 min)

**Files:**
- **Modify:** `test_context_extraction.py` (append new tests)
- **Modify:** `src/syncopaid/context_extraction.py` (add function)

**Context:** Create a single entry point function that routes to appropriate extractor based on app type. This will be called from tracker.py.

**Step 1 - RED:** Write failing test
```python
# test_context_extraction.py (add to end of file)

from syncopaid.context_extraction import extract_context

def test_extract_context_browser():
    """Route browser to URL extraction."""
    result = extract_context("chrome.exe", "Page - https://example.com - Chrome")
    assert result == "https://example.com"

def test_extract_context_outlook():
    """Route Outlook to subject extraction."""
    result = extract_context("OUTLOOK.EXE", "Inbox - RE: Case File - user@law.com - Outlook")
    assert result == "RE: Case File"

def test_extract_context_office():
    """Route Office to filepath extraction."""
    result = extract_context("WINWORD.EXE", "Contract.docx - Word")
    assert result == "Contract.docx"

def test_extract_context_unknown_app():
    """Return None for unknown apps."""
    result = extract_context("notepad.exe", "Untitled - Notepad")
    assert result is None

def test_extract_context_none_inputs():
    """Handle None inputs gracefully."""
    result = extract_context(None, None)
    assert result is None

# Update main block
if __name__ == "__main__":
    print("Running context extraction tests...")
    test_extract_url_chrome_with_url()
    test_extract_url_chrome_without_url()
    test_extract_url_edge()
    test_extract_url_firefox()
    test_extract_url_non_browser()
    test_extract_subject_inbox_format()
    test_extract_subject_message_format()
    test_extract_subject_generic_inbox()
    test_extract_subject_non_outlook()
    test_extract_filepath_word_full_path()
    test_extract_filepath_excel()
    test_extract_filepath_powerpoint()
    test_extract_filepath_filename_only()
    test_extract_filepath_non_office()
    test_extract_context_browser()
    test_extract_context_outlook()
    test_extract_context_office()
    test_extract_context_unknown_app()
    test_extract_context_none_inputs()
    print("All tests passed!")
```

**Step 2 - Verify RED:**
```bash
python test_context_extraction.py
```
Expected output: `ImportError: cannot import name 'extract_context'`

**Step 3 - GREEN:** Write minimal implementation
```python
# src/syncopaid/context_extraction.py (add to end of file)

def extract_context(app: str, title: str) -> str:
    """
    Extract contextual information from window title based on application type.

    Routes to appropriate extraction function:
    - Browsers → URL extraction
    - Outlook → Email subject extraction
    - Office apps → File path extraction

    Args:
        app: Application executable name (e.g., 'chrome.exe', 'OUTLOOK.EXE')
        title: Window title text

    Returns:
        Extracted context string (URL, subject, or filepath), or None if nothing extracted
    """
    if not app or not title:
        return None

    try:
        # Try browser URL extraction
        url = extract_url_from_browser(app, title)
        if url:
            return url

        # Try Outlook subject extraction
        subject = extract_subject_from_outlook(app, title)
        if subject:
            return subject

        # Try Office filepath extraction
        filepath = extract_filepath_from_office(app, title)
        if filepath:
            return filepath

        return None

    except Exception as e:
        # Log but don't crash - graceful degradation
        logging.debug(f"Context extraction failed for {app}: {e}")
        return None
```

**Step 4 - Verify GREEN:**
```bash
python test_context_extraction.py
```
Expected output: `All tests passed!`

**Step 5 - COMMIT:**
```bash
git add test_context_extraction.py src/syncopaid/context_extraction.py && git commit -m "feat: add unified extract_context routing function"
```

---

### Task 5: Integrate context extraction into tracker (~3 min)

**Files:**
- **Modify:** `src/syncopaid/tracker.py` (lines 129-171, get_active_window function)

**Context:** Import extract_context and call it in get_active_window() to populate a 'url' key in the returned dict. The TrackerLoop already uses this dict to build ActivityEvent objects.

**Step 1 - RED:** Write failing integration test
```python
# test_context_extraction.py (add to end of file)

def test_integration_get_active_window_populates_url():
    """Test that get_active_window includes extracted context in 'url' field."""
    # This test will pass once tracker.py is modified
    # For now, it serves as documentation of expected behavior
    from syncopaid.tracker import get_active_window

    # Note: This will return mock data on non-Windows platforms
    # The test verifies the structure, not specific values
    result = get_active_window()

    # Verify the result includes 'url' key (may be None)
    assert 'url' in result
    assert isinstance(result.get('url'), (str, type(None)))
    print("Integration test passed: get_active_window includes 'url' field")

# Update main block
if __name__ == "__main__":
    print("Running context extraction tests...")
    test_extract_url_chrome_with_url()
    test_extract_url_chrome_without_url()
    test_extract_url_edge()
    test_extract_url_firefox()
    test_extract_url_non_browser()
    test_extract_subject_inbox_format()
    test_extract_subject_message_format()
    test_extract_subject_generic_inbox()
    test_extract_subject_non_outlook()
    test_extract_filepath_word_full_path()
    test_extract_filepath_excel()
    test_extract_filepath_powerpoint()
    test_extract_filepath_filename_only()
    test_extract_filepath_non_office()
    test_extract_context_browser()
    test_extract_context_outlook()
    test_extract_context_office()
    test_extract_context_unknown_app()
    test_extract_context_none_inputs()
    test_integration_get_active_window_populates_url()
    print("All tests passed!")
```

**Step 2 - Verify RED:**
```bash
python test_context_extraction.py
```
Expected output: Test may pass or fail depending on current tracker.py state. If 'url' key missing, will show `AssertionError: 'url' not in result`

**Step 3 - GREEN:** Integrate into tracker.py
```python
# src/syncopaid/tracker.py
# Find the imports section (around line 1-20) and add:
from syncopaid.context_extraction import extract_context

# Then modify get_active_window function (lines 129-171)
# Find the return statement around line 167 and update it:

def get_active_window() -> Dict[str, Optional[str]]:
    """
    Get information about the currently active foreground window.

    Returns:
        Dictionary with keys:
        - 'app': Executable name (e.g., 'WINWORD.EXE', 'chrome.exe')
        - 'title': Window title text
        - 'pid': Process ID (for debugging)
        - 'url': Extracted contextual information (URL, subject, or filepath)

    Note: Returns mock data on non-Windows platforms for testing.
    """
    if not WINDOWS_APIS_AVAILABLE:
        # Mock data for testing on non-Windows platforms
        import random
        mock_apps = [
            ("WINWORD.EXE", "Smith-Contract-v2.docx - Word"),
            ("chrome.exe", "CanLII - 2024 BCSC 1234 - Google Chrome"),
            ("OUTLOOK.EXE", "Inbox - user@lawfirm.com - Outlook"),
        ]
        app, title = random.choice(mock_apps)
        url = extract_context(app, title)
        return {"app": app, "title": title, "pid": 0, "url": url}

    try:
        hwnd = win32gui.GetForegroundWindow()
        title = win32gui.GetWindowText(hwnd)
        _, pid = win32process.GetWindowThreadProcessId(hwnd)

        # Handle signed/unsigned integer overflow from Windows API
        # Windows returns unsigned 32-bit PID, but Python may interpret as signed
        if pid < 0:
            pid = pid & 0xFFFFFFFF  # Convert to unsigned

        try:
            process = psutil.Process(pid).name()
        except (psutil.NoSuchProcess, psutil.AccessDenied, ValueError):
            process = None

        # Extract contextual information
        url = extract_context(process, title)

        return {"app": process, "title": title, "pid": pid, "url": url}

    except Exception as e:
        logging.error(f"Error getting active window: {e}")
        return {"app": None, "title": None, "pid": None, "url": None}
```

**Step 4 - Verify GREEN:**
```bash
python test_context_extraction.py
```
Expected output: `All tests passed!`

**Step 5 - COMMIT:**
```bash
git add test_context_extraction.py src/syncopaid/tracker.py && git commit -m "feat: integrate context extraction into get_active_window"
```

---

### Task 6: Update TrackerLoop to use url field (~2 min)

**Files:**
- **Modify:** `src/syncopaid/tracker.py` (lines 270-283, state dict construction)

**Context:** TrackerLoop.start() creates state dict from window info. Add 'url' field so it flows through to ActivityEvent.

**Step 1 - RED:** Verify current behavior
```bash
python -m syncopaid.tracker
```
Expected: Tracker runs for 30s, prints events. Check if 'url' field appears in output. Currently it won't because state dict doesn't include it.

**Step 2 - GREEN:** Add url to state dict
```python
# src/syncopaid/tracker.py
# Find the state dict creation around line 275-282 in TrackerLoop.start()
# Current code looks like:

                state = {
                    'app': window['app'],
                    'title': window['title'],
                    'is_idle': is_idle
                }

# Change to:

                state = {
                    'app': window['app'],
                    'title': window['title'],
                    'url': window.get('url'),  # Extracted context (URL, subject, or filepath)
                    'is_idle': is_idle
                }
```

**Step 3 - Verify GREEN:**
```bash
python -m syncopaid.tracker
```
Expected: Tracker runs for 30s. Events now show url field populated when context is extracted (e.g., URLs for browsers, subjects for Outlook). Press Ctrl+C to stop.

**Step 4 - COMMIT:**
```bash
git add src/syncopaid/tracker.py && git commit -m "feat: include url field in TrackerLoop state dict"
```

---

### Task 7: Add logging for extraction failures (~2 min)

**Files:**
- **Modify:** `src/syncopaid/tracker.py` (lines 129-171, get_active_window function)

**Context:** Log when context extraction is attempted and fails, to help debug parsing issues without crashing.

**Step 1 - RED:** Create test scenario
```bash
# Manual test: Run tracker and verify no logs for extraction failures
python -m syncopaid.tracker
```
Expected: Tracker runs but doesn't log extraction attempts or failures.

**Step 2 - GREEN:** Add debug logging
```python
# src/syncopaid/tracker.py
# Update get_active_window function where extract_context is called
# Find the line: url = extract_context(process, title)
# Replace with:

        # Extract contextual information
        url = extract_context(process, title)
        if url:
            logging.debug(f"Extracted context from {process}: {url[:50]}...")  # Log first 50 chars
        elif process and title:
            # Only log if we had a valid app and title but extraction returned None
            logging.debug(f"No context extracted from {process}: {title[:50]}...")
```

**Step 3 - Verify GREEN:**
```bash
# Run with debug logging enabled
python -c "import logging; logging.basicConfig(level=logging.DEBUG); from syncopaid.tracker import TrackerLoop; loop = TrackerLoop(); import time; [print(event.to_dict()) if event else None for event in (next(loop.start()) for _ in range(10))]; time.sleep(1)"
```
Expected: Debug logs show extraction attempts and results for each window.

**Step 4 - COMMIT:**
```bash
git add src/syncopaid/tracker.py && git commit -m "feat: add debug logging for context extraction"
```

---

## Final Verification

Run after all tasks complete:
```bash
python test_context_extraction.py        # All unit tests pass
python -m syncopaid.tracker              # Tracker runs for 30s, url field populated
```

**Manual verification steps:**
1. Open Chrome and navigate to a URL → verify URL extracted
2. Open Outlook with an email → verify subject extracted
3. Open Word with a document → verify filepath extracted
4. Check that tracker doesn't crash on malformed titles

## Rollback

If issues arise: `git log --oneline -10` to find commits, then `git revert <hash>` for each commit from Task 7 back to Task 1.

## Notes

**Edge cases discovered during planning:**
- Outlook "Inbox" view without specific subject should return None (not "Inbox")
- Browser URLs may contain special chars - regex pattern needs refinement if issues arise
- Office apps sometimes show "[Compatibility Mode]" suffix - current implementation handles this
- Some browsers (Brave, Opera) also embed URLs - added to BROWSER_APPS set

**Follow-up work:**
- Story 1.4.8 (Smart Time Categorization Prompt) will consume url field for AI matching
- Consider adding extraction for Teams chat titles (format: "Chat - Person Name - Microsoft Teams")
- May need to handle Edge "New tab" and Chrome "chrome://newtab" edge cases

**Dependencies:**
- This story enhances existing ActivityEvent structure (no schema changes needed)
- url field already exists in ActivityEvent dataclass (line 110 in tracker.py)
- Database schema already supports url column (confirmed in technical-reference.md)
