#!/usr/bin/env python3
"""
Generate version information for TimeLogger build.

This script:
1. Reads the product version from the VERSION file
2. Gets the current git commit hash
3. Generates version_info.txt for PyInstaller
4. Updates lawtime/__init__.py with version constants

Product version is manually controlled via the VERSION file.
File version automatically includes git commit hash.

Example:
    Product Version: 1.0.0
    Git Commit: 89e840f
    File Version: 1.0.0.89e840f
"""

import subprocess
import sys
from pathlib import Path
from datetime import datetime


def get_git_commit_hash():
    """
    Get the short git commit hash.

    Returns:
        str: Short commit hash (e.g., "89e840f") or "dev" if git unavailable
    """
    try:
        result = subprocess.run(
            ['git', 'rev-parse', '--short', 'HEAD'],
            capture_output=True,
            text=True,
            check=True,
            timeout=5
        )
        return result.stdout.strip()
    except (subprocess.CalledProcessError, subprocess.TimeoutExpired, FileNotFoundError):
        return "dev"


def read_product_version():
    """
    Read product version from VERSION file.

    Returns:
        str: Product version (e.g., "1.0.0")

    Raises:
        SystemExit: If VERSION file is missing or invalid
    """
    version_file = Path(__file__).parent / 'VERSION'

    if not version_file.exists():
        print("ERROR: VERSION file not found!")
        print(f"Expected location: {version_file}")
        print("\nCreate a VERSION file with the product version (e.g., '1.0.0')")
        sys.exit(1)

    version = version_file.read_text().strip()

    if not version:
        print("ERROR: VERSION file is empty!")
        sys.exit(1)

    # Validate format (should be X.Y.Z)
    parts = version.split('.')
    if len(parts) != 3 or not all(p.isdigit() for p in parts):
        print(f"ERROR: Invalid version format in VERSION file: '{version}'")
        print("Expected format: X.Y.Z (e.g., '1.0.0')")
        sys.exit(1)

    return version


def parse_version_parts(version):
    """
    Parse version string into numeric tuple.

    Args:
        version: Version string (e.g., "1.0.0")

    Returns:
        tuple: (major, minor, patch) as integers
    """
    parts = version.split('.')
    return (int(parts[0]), int(parts[1]), int(parts[2]))


def generate_version_info_txt(product_version, file_version):
    """
    Generate version_info.txt for PyInstaller.

    Args:
        product_version: Product version (e.g., "1.0.0")
        file_version: File version with commit hash (e.g., "1.0.0.89e840f")
    """
    major, minor, patch = parse_version_parts(product_version)

    # Create version_info.txt content
    content = f'''# UTF-8
# Auto-generated by generate_version.py - DO NOT EDIT MANUALLY
# Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
# Product Version: {product_version}
# File Version: {file_version}

VSVersionInfo(
  ffi=FixedFileInfo(
    # filevers and prodvers should be always a tuple with four items: (1, 2, 3, 4)
    # Set not needed items to zero 0.
    filevers=({major}, {minor}, {patch}, 0),
    prodvers=({major}, {minor}, {patch}, 0),
    # Contains a bitmask that specifies the valid bits 'flags'
    mask=0x3f,
    # Contains a bitmask that specifies the Boolean attributes of the file.
    flags=0x0,
    # The operating system for which this file was designed.
    # 0x4 - NT and there is no need to change it.
    OS=0x40004,
    # The general type of file.
    # 0x1 - the file is an application.
    fileType=0x1,
    # The function of the file.
    # 0x0 - the function is not defined for this fileType
    subtype=0x0,
    # Creation date and time stamp.
    date=(0, 0)
    ),
  kids=[
    StringFileInfo(
      [
      StringTable(
        u'040904B0',
        [StringStruct(u'CompanyName', u''),
        StringStruct(u'FileDescription', u'TimeLogger - Automatic time tracking for lawyers'),
        StringStruct(u'FileVersion', u'{file_version}'),
        StringStruct(u'InternalName', u'TimeLogger'),
        StringStruct(u'LegalCopyright', u'Copyright (c) 2025 Brahm Dorst'),
        StringStruct(u'OriginalFilename', u'TimeLogger.exe'),
        StringStruct(u'ProductName', u'TimeLogger'),
        StringStruct(u'ProductVersion', u'{product_version}')])
      ]),
    VarFileInfo([VarStruct(u'Translation', [1033, 1200])])
  ]
)
'''

    # Write version_info.txt
    version_info_path = Path(__file__).parent / 'version_info.txt'
    version_info_path.write_text(content, encoding='utf-8')

    print(f"✓ Generated: {version_info_path}")


def update_init_py(product_version, file_version):
    """
    Update lawtime/__init__.py with version constants.

    Args:
        product_version: Product version (e.g., "1.0.0")
        file_version: File version with commit hash (e.g., "1.0.0.89e840f")
    """
    init_path = Path(__file__).parent / 'lawtime' / '__init__.py'

    if not init_path.exists():
        print(f"ERROR: {init_path} not found!")
        sys.exit(1)

    # Read current content
    content = init_path.read_text(encoding='utf-8')

    # Update __version__ line
    new_content = []
    found_version = False
    found_product_version = False

    for line in content.split('\n'):
        if line.startswith('__version__'):
            new_content.append(f'__version__ = "{file_version}"')
            found_version = True
        elif line.startswith('__product_version__'):
            new_content.append(f'__product_version__ = "{product_version}"')
            found_product_version = True
        else:
            new_content.append(line)

    # Add __product_version__ if it doesn't exist
    if found_version and not found_product_version:
        # Insert after __version__ line
        for i, line in enumerate(new_content):
            if line.startswith('__version__'):
                new_content.insert(i + 1, f'__product_version__ = "{product_version}"')
                break

    # Write back
    init_path.write_text('\n'.join(new_content), encoding='utf-8')

    print(f"✓ Updated: {init_path}")


def main():
    """Main entry point for version generation."""
    print("=" * 60)
    print("TimeLogger Version Generator")
    print("=" * 60)
    print()

    # Read product version from VERSION file
    print("Reading product version from VERSION file...")
    product_version = read_product_version()
    print(f"  Product Version: {product_version}")

    # Get git commit hash
    print("\nGetting git commit hash...")
    commit_hash = get_git_commit_hash()
    print(f"  Git Commit: {commit_hash}")

    # Construct file version
    file_version = f"{product_version}.{commit_hash}"
    print(f"  File Version: {file_version}")
    print()

    # Generate version_info.txt
    print("Generating version files...")
    generate_version_info_txt(product_version, file_version)
    update_init_py(product_version, file_version)

    print()
    print("=" * 60)
    print("Version information generated successfully!")
    print("=" * 60)
    print()


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\n\nInterrupted by user")
        sys.exit(1)
    except Exception as e:
        print(f"\n\nERROR: {e}")
        sys.exit(1)
